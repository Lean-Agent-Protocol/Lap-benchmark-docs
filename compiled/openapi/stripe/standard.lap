@lap v0.3
# Machine-readable API spec. Each @endpoint block is one API call.
@api Stripe API
@base https://api.stripe.com/
@version 2026-01-28.clover
@auth Bearer basic | Bearer bearer
@endpoints 588
@hint download_for_search
@toc account(1), account_links(1), account_sessions(1), accounts(29), apple_pay(4), application_fees(7), apps(4), balance(3), balance_settings(2), balance_transactions(2), billing(24), billing_portal(5), charges(14), checkout(6), climate(9), confirmation_tokens(1), country_specs(2), coupons(5), credit_notes(8), customer_sessions(1), customers(47), disputes(4), entitlements(6), ephemeral_keys(2), events(2), exchange_rates(2), external_accounts(1), fabric(2), file_links(4), files(3), financial_connections(11), forwarding(3), identity(8), invoice_payments(2), invoice_rendering_templates(4), invoiceitems(5), invoices(18), issuing(32), link_account_sessions(2), linked_accounts(5), mandates(1), payment_attempt_records(2), payment_intents(12), payment_links(5), payment_method_configurations(4), payment_method_domains(5), payment_methods(6), payment_records(8), payouts(6), plans(5), prices(5), products(10), promotion_codes(4), quotes(10), radar(12), refunds(5), reporting(5), reviews(3), setup_attempts(1), setup_intents(7), shipping_rates(4), sigma(3), sources(7), subscription_items(5), subscription_schedules(6), subscriptions(9), tax(14), tax_codes(2), tax_ids(4), tax_rates(4), terminal(25), test_helpers(44), tokens(2), topups(5), transfers(8), treasury(33), webhook_endpoints(5)

@group account
@endpoint GET /v1/account
@desc Retrieve account
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {business_profile: any?, business_type: str?, capabilities: map{acss_debit_payments: str, affirm_payments: str, afterpay_clearpay_payments: str, alma_payments: str, amazon_pay_payments: str, au_becs_debit_payments: str, bacs_debit_payments: str, bancontact_payments: str, bank_transfer_payments: str, billie_payments: str, blik_payments: str, boleto_payments: str, card_issuing: str, card_payments: str, cartes_bancaires_payments: str, cashapp_payments: str, crypto_payments: str, eps_payments: str, fpx_payments: str, gb_bank_transfer_payments: str, giropay_payments: str, grabpay_payments: str, ideal_payments: str, india_international_payments: str, jcb_payments: str, jp_bank_transfer_payments: str, kakao_pay_payments: str, klarna_payments: str, konbini_payments: str, kr_card_payments: str, legacy_payments: str, link_payments: str, mb_way_payments: str, mobilepay_payments: str, multibanco_payments: str, mx_bank_transfer_payments: str, naver_pay_payments: str, nz_bank_account_becs_debit_payments: str, oxxo_payments: str, p24_payments: str, pay_by_bank_payments: str, payco_payments: str, paynow_payments: str, payto_payments: str, pix_payments: str, promptpay_payments: str, revolut_pay_payments: str, samsung_pay_payments: str, satispay_payments: str, sepa_bank_transfer_payments: str, sepa_debit_payments: str, sofort_payments: str, swish_payments: str, tax_reporting_us_1099_k: str, tax_reporting_us_1099_misc: str, transfers: str, treasury: str, twint_payments: str, us_bank_account_ach_payments: str, us_bank_transfer_payments: str, zip_payments: str}, charges_enabled: bool, company: map{address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, directors_provided: bool, directorship_declaration: any?, executives_provided: bool, export_license_id: str, export_purpose_code: str, name: str?, name_kana: str?, name_kanji: str?, owners_provided: bool, ownership_declaration: any?, ownership_exemption_reason: str, phone: str?, registration_date: map{day: int?, month: int?, year: int?}, representative_declaration: any?, structure: str, tax_id_provided: bool, tax_id_registrar: str, vat_id_provided: bool, verification: any?}, controller: map{fees: map{payer: str}, is_controller: bool, losses: map{payments: str}, requirement_collection: str, stripe_dashboard: map{type: str}, type: str}, country: str, created: int(unix-time), default_currency: str, details_submitted: bool, email: str?, external_accounts: map{data: [any], has_more: bool, object: str, url: str}, future_requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, groups: any?, id: str, individual: map{account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map, status: str}}, metadata: map, object: str, payouts_enabled: bool, requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, settings: any?, tos_acceptance: map{date: int(unix-time)?, ip: str?, service_agreement: str, user_agent: str?}, type: str} # Successful response.

@endgroup

@group account_links
@endpoint POST /v1/account_links
@desc Create an account link
@returns(200) {created: int(unix-time), expires_at: int(unix-time), object: str, url: str} # Successful response.

@endgroup

@group account_sessions
@endpoint POST /v1/account_sessions
@desc Create an Account Session
@returns(200) {account: str, client_secret: str, components: map{account_management: map{enabled: bool, features: map}, account_onboarding: map{enabled: bool, features: map}, balances: map{enabled: bool, features: map}, disputes_list: map{enabled: bool, features: map}, documents: map{enabled: bool, features: map}, financial_account: map{enabled: bool, features: map}, financial_account_transactions: map{enabled: bool, features: map}, instant_payouts_promotion: map{enabled: bool, features: map}, issuing_card: map{enabled: bool, features: map}, issuing_cards_list: map{enabled: bool, features: map}, notification_banner: map{enabled: bool, features: map}, payment_details: map{enabled: bool, features: map}, payment_disputes: map{enabled: bool, features: map}, payments: map{enabled: bool, features: map}, payout_details: map{enabled: bool, features: map}, payouts: map{enabled: bool, features: map}, payouts_list: map{enabled: bool, features: map}, tax_registrations: map{enabled: bool, features: map}, tax_settings: map{enabled: bool, features: map}}, expires_at: int(unix-time), livemode: bool, object: str} # Successful response.

@endgroup

@group accounts
@endpoint GET /v1/accounts
@desc List all connected accounts
@optional {created: any # Only return connected accounts that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/accounts
@desc <p>With <a href="/docs/connect">Connect</a>, you can create Stripe accounts for your users.
@returns(200) {business_profile: any?, business_type: str?, capabilities: map{acss_debit_payments: str, affirm_payments: str, afterpay_clearpay_payments: str, alma_payments: str, amazon_pay_payments: str, au_becs_debit_payments: str, bacs_debit_payments: str, bancontact_payments: str, bank_transfer_payments: str, billie_payments: str, blik_payments: str, boleto_payments: str, card_issuing: str, card_payments: str, cartes_bancaires_payments: str, cashapp_payments: str, crypto_payments: str, eps_payments: str, fpx_payments: str, gb_bank_transfer_payments: str, giropay_payments: str, grabpay_payments: str, ideal_payments: str, india_international_payments: str, jcb_payments: str, jp_bank_transfer_payments: str, kakao_pay_payments: str, klarna_payments: str, konbini_payments: str, kr_card_payments: str, legacy_payments: str, link_payments: str, mb_way_payments: str, mobilepay_payments: str, multibanco_payments: str, mx_bank_transfer_payments: str, naver_pay_payments: str, nz_bank_account_becs_debit_payments: str, oxxo_payments: str, p24_payments: str, pay_by_bank_payments: str, payco_payments: str, paynow_payments: str, payto_payments: str, pix_payments: str, promptpay_payments: str, revolut_pay_payments: str, samsung_pay_payments: str, satispay_payments: str, sepa_bank_transfer_payments: str, sepa_debit_payments: str, sofort_payments: str, swish_payments: str, tax_reporting_us_1099_k: str, tax_reporting_us_1099_misc: str, transfers: str, treasury: str, twint_payments: str, us_bank_account_ach_payments: str, us_bank_transfer_payments: str, zip_payments: str}, charges_enabled: bool, company: map{address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, directors_provided: bool, directorship_declaration: any?, executives_provided: bool, export_license_id: str, export_purpose_code: str, name: str?, name_kana: str?, name_kanji: str?, owners_provided: bool, ownership_declaration: any?, ownership_exemption_reason: str, phone: str?, registration_date: map{day: int?, month: int?, year: int?}, representative_declaration: any?, structure: str, tax_id_provided: bool, tax_id_registrar: str, vat_id_provided: bool, verification: any?}, controller: map{fees: map{payer: str}, is_controller: bool, losses: map{payments: str}, requirement_collection: str, stripe_dashboard: map{type: str}, type: str}, country: str, created: int(unix-time), default_currency: str, details_submitted: bool, email: str?, external_accounts: map{data: [any], has_more: bool, object: str, url: str}, future_requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, groups: any?, id: str, individual: map{account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map, status: str}}, metadata: map, object: str, payouts_enabled: bool, requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, settings: any?, tos_acceptance: map{date: int(unix-time)?, ip: str?, service_agreement: str, user_agent: str?}, type: str} # Successful response.

@endpoint DELETE /v1/accounts/{account}
@desc Delete an account
@required {account: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/accounts/{account}
@desc Retrieve account
@required {account: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {business_profile: any?, business_type: str?, capabilities: map{acss_debit_payments: str, affirm_payments: str, afterpay_clearpay_payments: str, alma_payments: str, amazon_pay_payments: str, au_becs_debit_payments: str, bacs_debit_payments: str, bancontact_payments: str, bank_transfer_payments: str, billie_payments: str, blik_payments: str, boleto_payments: str, card_issuing: str, card_payments: str, cartes_bancaires_payments: str, cashapp_payments: str, crypto_payments: str, eps_payments: str, fpx_payments: str, gb_bank_transfer_payments: str, giropay_payments: str, grabpay_payments: str, ideal_payments: str, india_international_payments: str, jcb_payments: str, jp_bank_transfer_payments: str, kakao_pay_payments: str, klarna_payments: str, konbini_payments: str, kr_card_payments: str, legacy_payments: str, link_payments: str, mb_way_payments: str, mobilepay_payments: str, multibanco_payments: str, mx_bank_transfer_payments: str, naver_pay_payments: str, nz_bank_account_becs_debit_payments: str, oxxo_payments: str, p24_payments: str, pay_by_bank_payments: str, payco_payments: str, paynow_payments: str, payto_payments: str, pix_payments: str, promptpay_payments: str, revolut_pay_payments: str, samsung_pay_payments: str, satispay_payments: str, sepa_bank_transfer_payments: str, sepa_debit_payments: str, sofort_payments: str, swish_payments: str, tax_reporting_us_1099_k: str, tax_reporting_us_1099_misc: str, transfers: str, treasury: str, twint_payments: str, us_bank_account_ach_payments: str, us_bank_transfer_payments: str, zip_payments: str}, charges_enabled: bool, company: map{address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, directors_provided: bool, directorship_declaration: any?, executives_provided: bool, export_license_id: str, export_purpose_code: str, name: str?, name_kana: str?, name_kanji: str?, owners_provided: bool, ownership_declaration: any?, ownership_exemption_reason: str, phone: str?, registration_date: map{day: int?, month: int?, year: int?}, representative_declaration: any?, structure: str, tax_id_provided: bool, tax_id_registrar: str, vat_id_provided: bool, verification: any?}, controller: map{fees: map{payer: str}, is_controller: bool, losses: map{payments: str}, requirement_collection: str, stripe_dashboard: map{type: str}, type: str}, country: str, created: int(unix-time), default_currency: str, details_submitted: bool, email: str?, external_accounts: map{data: [any], has_more: bool, object: str, url: str}, future_requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, groups: any?, id: str, individual: map{account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map, status: str}}, metadata: map, object: str, payouts_enabled: bool, requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, settings: any?, tos_acceptance: map{date: int(unix-time)?, ip: str?, service_agreement: str, user_agent: str?}, type: str} # Successful response.

@endpoint POST /v1/accounts/{account}
@desc Update an account
@required {account: str}
@returns(200) {business_profile: any?, business_type: str?, capabilities: map{acss_debit_payments: str, affirm_payments: str, afterpay_clearpay_payments: str, alma_payments: str, amazon_pay_payments: str, au_becs_debit_payments: str, bacs_debit_payments: str, bancontact_payments: str, bank_transfer_payments: str, billie_payments: str, blik_payments: str, boleto_payments: str, card_issuing: str, card_payments: str, cartes_bancaires_payments: str, cashapp_payments: str, crypto_payments: str, eps_payments: str, fpx_payments: str, gb_bank_transfer_payments: str, giropay_payments: str, grabpay_payments: str, ideal_payments: str, india_international_payments: str, jcb_payments: str, jp_bank_transfer_payments: str, kakao_pay_payments: str, klarna_payments: str, konbini_payments: str, kr_card_payments: str, legacy_payments: str, link_payments: str, mb_way_payments: str, mobilepay_payments: str, multibanco_payments: str, mx_bank_transfer_payments: str, naver_pay_payments: str, nz_bank_account_becs_debit_payments: str, oxxo_payments: str, p24_payments: str, pay_by_bank_payments: str, payco_payments: str, paynow_payments: str, payto_payments: str, pix_payments: str, promptpay_payments: str, revolut_pay_payments: str, samsung_pay_payments: str, satispay_payments: str, sepa_bank_transfer_payments: str, sepa_debit_payments: str, sofort_payments: str, swish_payments: str, tax_reporting_us_1099_k: str, tax_reporting_us_1099_misc: str, transfers: str, treasury: str, twint_payments: str, us_bank_account_ach_payments: str, us_bank_transfer_payments: str, zip_payments: str}, charges_enabled: bool, company: map{address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, directors_provided: bool, directorship_declaration: any?, executives_provided: bool, export_license_id: str, export_purpose_code: str, name: str?, name_kana: str?, name_kanji: str?, owners_provided: bool, ownership_declaration: any?, ownership_exemption_reason: str, phone: str?, registration_date: map{day: int?, month: int?, year: int?}, representative_declaration: any?, structure: str, tax_id_provided: bool, tax_id_registrar: str, vat_id_provided: bool, verification: any?}, controller: map{fees: map{payer: str}, is_controller: bool, losses: map{payments: str}, requirement_collection: str, stripe_dashboard: map{type: str}, type: str}, country: str, created: int(unix-time), default_currency: str, details_submitted: bool, email: str?, external_accounts: map{data: [any], has_more: bool, object: str, url: str}, future_requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, groups: any?, id: str, individual: map{account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map, status: str}}, metadata: map, object: str, payouts_enabled: bool, requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, settings: any?, tos_acceptance: map{date: int(unix-time)?, ip: str?, service_agreement: str, user_agent: str?}, type: str} # Successful response.

@endpoint POST /v1/accounts/{account}/bank_accounts
@desc Create an external account
@required {account: str}
@returns(200) Successful response.

@endpoint DELETE /v1/accounts/{account}/bank_accounts/{id}
@desc Delete an external account
@required {account: str, id: str # Unique identifier for the external account to be deleted.}
@returns(200) Successful response.

@endpoint GET /v1/accounts/{account}/bank_accounts/{id}
@desc Retrieve an external account
@required {account: str, id: str # Unique identifier for the external account to be retrieved.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) Successful response.

@endpoint POST /v1/accounts/{account}/bank_accounts/{id}
@desc <p>Updates the metadata, account holder name, account holder type of a bank account belonging to
@required {account: str, id: str}
@returns(200) Successful response.

@endpoint GET /v1/accounts/{account}/capabilities
@desc List all account capabilities
@required {account: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/accounts/{account}/capabilities/{capability}
@desc Retrieve an Account Capability
@required {account: str, capability: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account: any, future_requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str], disabled_reason: str?, errors: [map], eventually_due: [str], past_due: [str], pending_verification: [str]}, id: str, object: str, requested: bool, requested_at: int(unix-time)?, requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str], disabled_reason: str?, errors: [map], eventually_due: [str], past_due: [str], pending_verification: [str]}, status: str} # Successful response.

@endpoint POST /v1/accounts/{account}/capabilities/{capability}
@desc Update an Account Capability
@required {account: str, capability: str}
@returns(200) {account: any, future_requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str], disabled_reason: str?, errors: [map], eventually_due: [str], past_due: [str], pending_verification: [str]}, id: str, object: str, requested: bool, requested_at: int(unix-time)?, requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str], disabled_reason: str?, errors: [map], eventually_due: [str], past_due: [str], pending_verification: [str]}, status: str} # Successful response.

@endpoint GET /v1/accounts/{account}/external_accounts
@desc List all external accounts
@required {account: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., object: str(bank_account/card) # Filter external accounts according to a particular object type., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [any], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/accounts/{account}/external_accounts
@desc Create an external account
@required {account: str}
@returns(200) Successful response.

@endpoint DELETE /v1/accounts/{account}/external_accounts/{id}
@desc Delete an external account
@required {account: str, id: str # Unique identifier for the external account to be deleted.}
@returns(200) Successful response.

@endpoint GET /v1/accounts/{account}/external_accounts/{id}
@desc Retrieve an external account
@required {account: str, id: str # Unique identifier for the external account to be retrieved.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) Successful response.

@endpoint POST /v1/accounts/{account}/external_accounts/{id}
@desc <p>Updates the metadata, account holder name, account holder type of a bank account belonging to
@required {account: str, id: str}
@returns(200) Successful response.

@endpoint POST /v1/accounts/{account}/login_links
@desc Create a login link
@required {account: str}
@returns(200) {created: int(unix-time), object: str, url: str} # Successful response.

@endpoint GET /v1/accounts/{account}/people
@desc List all persons
@required {account: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., relationship: map # Filters on the list of people returned based on the person's relationship to the account's company., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/accounts/{account}/people
@desc Create a person
@required {account: str}
@returns(200) {account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map{back: any?, details: str?, details_code: str?, front: any?}, status: str}} # Successful response.

@endpoint DELETE /v1/accounts/{account}/people/{person}
@desc Delete a person
@required {account: str, person: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/accounts/{account}/people/{person}
@desc Retrieve a person
@required {account: str, person: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map{back: any?, details: str?, details_code: str?, front: any?}, status: str}} # Successful response.

@endpoint POST /v1/accounts/{account}/people/{person}
@desc Update a person
@required {account: str, person: str}
@returns(200) {account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map{back: any?, details: str?, details_code: str?, front: any?}, status: str}} # Successful response.

@endpoint GET /v1/accounts/{account}/persons
@desc List all persons
@required {account: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., relationship: map # Filters on the list of people returned based on the person's relationship to the account's company., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/accounts/{account}/persons
@desc Create a person
@required {account: str}
@returns(200) {account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map{back: any?, details: str?, details_code: str?, front: any?}, status: str}} # Successful response.

@endpoint DELETE /v1/accounts/{account}/persons/{person}
@desc Delete a person
@required {account: str, person: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/accounts/{account}/persons/{person}
@desc Retrieve a person
@required {account: str, person: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map{back: any?, details: str?, details_code: str?, front: any?}, status: str}} # Successful response.

@endpoint POST /v1/accounts/{account}/persons/{person}
@desc Update a person
@required {account: str, person: str}
@returns(200) {account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map{back: any?, details: str?, details_code: str?, front: any?}, status: str}} # Successful response.

@endpoint POST /v1/accounts/{account}/reject
@desc Reject an account
@required {account: str}
@returns(200) {business_profile: any?, business_type: str?, capabilities: map{acss_debit_payments: str, affirm_payments: str, afterpay_clearpay_payments: str, alma_payments: str, amazon_pay_payments: str, au_becs_debit_payments: str, bacs_debit_payments: str, bancontact_payments: str, bank_transfer_payments: str, billie_payments: str, blik_payments: str, boleto_payments: str, card_issuing: str, card_payments: str, cartes_bancaires_payments: str, cashapp_payments: str, crypto_payments: str, eps_payments: str, fpx_payments: str, gb_bank_transfer_payments: str, giropay_payments: str, grabpay_payments: str, ideal_payments: str, india_international_payments: str, jcb_payments: str, jp_bank_transfer_payments: str, kakao_pay_payments: str, klarna_payments: str, konbini_payments: str, kr_card_payments: str, legacy_payments: str, link_payments: str, mb_way_payments: str, mobilepay_payments: str, multibanco_payments: str, mx_bank_transfer_payments: str, naver_pay_payments: str, nz_bank_account_becs_debit_payments: str, oxxo_payments: str, p24_payments: str, pay_by_bank_payments: str, payco_payments: str, paynow_payments: str, payto_payments: str, pix_payments: str, promptpay_payments: str, revolut_pay_payments: str, samsung_pay_payments: str, satispay_payments: str, sepa_bank_transfer_payments: str, sepa_debit_payments: str, sofort_payments: str, swish_payments: str, tax_reporting_us_1099_k: str, tax_reporting_us_1099_misc: str, transfers: str, treasury: str, twint_payments: str, us_bank_account_ach_payments: str, us_bank_transfer_payments: str, zip_payments: str}, charges_enabled: bool, company: map{address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, directors_provided: bool, directorship_declaration: any?, executives_provided: bool, export_license_id: str, export_purpose_code: str, name: str?, name_kana: str?, name_kanji: str?, owners_provided: bool, ownership_declaration: any?, ownership_exemption_reason: str, phone: str?, registration_date: map{day: int?, month: int?, year: int?}, representative_declaration: any?, structure: str, tax_id_provided: bool, tax_id_registrar: str, vat_id_provided: bool, verification: any?}, controller: map{fees: map{payer: str}, is_controller: bool, losses: map{payments: str}, requirement_collection: str, stripe_dashboard: map{type: str}, type: str}, country: str, created: int(unix-time), default_currency: str, details_submitted: bool, email: str?, external_accounts: map{data: [any], has_more: bool, object: str, url: str}, future_requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, groups: any?, id: str, individual: map{account: str, additional_tos_acceptances: map{account: any?}, address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: any?, address_kanji: any?, created: int(unix-time), dob: map{day: int?, month: int?, year: int?}, email: str?, first_name: str?, first_name_kana: str?, first_name_kanji: str?, full_name_aliases: [str], future_requirements: any?, gender: str?, id: str, id_number_provided: bool, id_number_secondary_provided: bool, last_name: str?, last_name_kana: str?, last_name_kanji: str?, maiden_name: str?, metadata: map, nationality: str?, object: str, phone: str?, political_exposure: str, registered_address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, relationship: map{authorizer: bool?, director: bool?, executive: bool?, legal_guardian: bool?, owner: bool?, percent_ownership: num?, representative: bool?, title: str?}, requirements: any?, ssn_last_4_provided: bool, us_cfpb_data: any?, verification: map{additional_document: any?, details: str?, details_code: str?, document: map, status: str}}, metadata: map, object: str, payouts_enabled: bool, requirements: map{alternatives: [map]?, current_deadline: int(unix-time)?, currently_due: [str]?, disabled_reason: str?, errors: [map]?, eventually_due: [str]?, past_due: [str]?, pending_verification: [str]?}, settings: any?, tos_acceptance: map{date: int(unix-time)?, ip: str?, service_agreement: str, user_agent: str?}, type: str} # Successful response.

@endgroup

@group apple_pay
@endpoint GET /v1/apple_pay/domains
@desc <p>List apple pay domains.</p>
@optional {domain_name: str, ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/apple_pay/domains
@desc <p>Create an apple pay domain.</p>
@returns(200) {created: int(unix-time), domain_name: str, id: str, livemode: bool, object: str} # Successful response.

@endpoint DELETE /v1/apple_pay/domains/{domain}
@desc <p>Delete an apple pay domain.</p>
@required {domain: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/apple_pay/domains/{domain}
@desc <p>Retrieve an apple pay domain.</p>
@required {domain: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), domain_name: str, id: str, livemode: bool, object: str} # Successful response.

@endgroup

@group application_fees
@endpoint GET /v1/application_fees
@desc List all application fees
@optional {charge: str # Only return application fees for the charge specified by this charge ID., created: any # Only return applications fees that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/application_fees/{fee}/refunds/{id}
@desc Retrieve an application fee refund
@required {fee: str, id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str(currency), fee: any, id: str, metadata: map?, object: str} # Successful response.

@endpoint POST /v1/application_fees/{fee}/refunds/{id}
@desc Update an application fee refund
@required {fee: str, id: str}
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str(currency), fee: any, id: str, metadata: map?, object: str} # Successful response.

@endpoint GET /v1/application_fees/{id}
@desc Retrieve an application fee
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account: any, amount: int, amount_refunded: int, application: any, balance_transaction: any?, charge: any, created: int(unix-time), currency: str(currency), fee_source: any?, id: str, livemode: bool, object: str, originating_transaction: any?, refunded: bool, refunds: map{data: [map], has_more: bool, object: str, url: str}} # Successful response.

@endpoint POST /v1/application_fees/{id}/refund
@required {id: str}
@returns(200) {account: any, amount: int, amount_refunded: int, application: any, balance_transaction: any?, charge: any, created: int(unix-time), currency: str(currency), fee_source: any?, id: str, livemode: bool, object: str, originating_transaction: any?, refunded: bool, refunds: map{data: [map], has_more: bool, object: str, url: str}} # Successful response.

@endpoint GET /v1/application_fees/{id}/refunds
@desc List all application fee refunds
@required {id: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/application_fees/{id}/refunds
@desc Create an application fee refund
@required {id: str}
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str(currency), fee: any, id: str, metadata: map?, object: str} # Successful response.

@endgroup

@group apps
@endpoint GET /v1/apps/secrets
@desc List secrets
@required {scope: map # Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/apps/secrets
@desc Set a Secret
@returns(200) {created: int(unix-time), deleted: bool, expires_at: int(unix-time)?, id: str, livemode: bool, name: str, object: str, payload: str?, scope: map{type: str, user: str}} # Successful response.

@endpoint POST /v1/apps/secrets/delete
@desc Delete a Secret
@returns(200) {created: int(unix-time), deleted: bool, expires_at: int(unix-time)?, id: str, livemode: bool, name: str, object: str, payload: str?, scope: map{type: str, user: str}} # Successful response.

@endpoint GET /v1/apps/secrets/find
@desc Find a Secret
@required {name: str # A name for the secret that's unique within the scope., scope: map # Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), deleted: bool, expires_at: int(unix-time)?, id: str, livemode: bool, name: str, object: str, payload: str?, scope: map{type: str, user: str}} # Successful response.

@endgroup

@group balance
@endpoint GET /v1/balance
@desc Retrieve balance
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {available: [map], connect_reserved: [map], instant_available: [map], issuing: map{available: [map]}, livemode: bool, object: str, pending: [map], refund_and_dispute_prefunding: map{available: [map], pending: [map]}} # Successful response.

@endpoint GET /v1/balance/history
@desc List all balance transactions
@optional {created: any # Only return transactions that were created during the given date interval., currency: str(currency) # Only return transactions in a certain currency. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies)., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., payout: str # For automatic Stripe payouts only, only returns transactions that were paid out on the specified payout ID., source: str # Only returns transactions associated with the given object., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., type: str # Only returns transactions of the given type. One of: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `climate_order_purchase`, `climate_order_refund`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `obligation_outbound`, `obligation_reversal_inbound`, `payment`, `payment_failure_refund`, `payment_network_reserve_hold`, `payment_network_reserve_release`, `payment_refund`, `payment_reversal`, `payment_unreconciled`, `payout`, `payout_cancel`, `payout_failure`, `payout_minimum_balance_hold`, `payout_minimum_balance_release`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `reserve_hold`, `reserve_release`, `stripe_fee`, `stripe_fx_fee`, `stripe_balance_payment_debit`, `stripe_balance_payment_debit_reversal`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/balance/history/{id}
@desc Retrieve a balance transaction
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, available_on: int(unix-time), balance_type: str, created: int(unix-time), currency: str(currency), description: str?, exchange_rate: num?, fee: int, fee_details: [map], id: str, net: int, object: str, reporting_category: str, source: any?, status: str, type: str} # Successful response.

@endgroup

@group balance_settings
@endpoint GET /v1/balance_settings
@desc Retrieve balance settings
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {object: str, payments: map{debit_negative_balances: bool?, payouts: any?, settlement_timing: map{delay_days: int, delay_days_override: int}}} # Successful response.

@endpoint POST /v1/balance_settings
@desc Update balance settings
@returns(200) {object: str, payments: map{debit_negative_balances: bool?, payouts: any?, settlement_timing: map{delay_days: int, delay_days_override: int}}} # Successful response.

@endgroup

@group balance_transactions
@endpoint GET /v1/balance_transactions
@desc List all balance transactions
@optional {created: any # Only return transactions that were created during the given date interval., currency: str(currency) # Only return transactions in a certain currency. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies)., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., payout: str # For automatic Stripe payouts only, only returns transactions that were paid out on the specified payout ID., source: str # Only returns transactions associated with the given object., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., type: str # Only returns transactions of the given type. One of: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `climate_order_purchase`, `climate_order_refund`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `obligation_outbound`, `obligation_reversal_inbound`, `payment`, `payment_failure_refund`, `payment_network_reserve_hold`, `payment_network_reserve_release`, `payment_refund`, `payment_reversal`, `payment_unreconciled`, `payout`, `payout_cancel`, `payout_failure`, `payout_minimum_balance_hold`, `payout_minimum_balance_release`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `reserve_hold`, `reserve_release`, `stripe_fee`, `stripe_fx_fee`, `stripe_balance_payment_debit`, `stripe_balance_payment_debit_reversal`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/balance_transactions/{id}
@desc Retrieve a balance transaction
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, available_on: int(unix-time), balance_type: str, created: int(unix-time), currency: str(currency), description: str?, exchange_rate: num?, fee: int, fee_details: [map], id: str, net: int, object: str, reporting_category: str, source: any?, status: str, type: str} # Successful response.

@endgroup

@group billing
@endpoint GET /v1/billing/alerts
@desc List billing alerts
@optional {alert_type: str # Filter results to only include this type of alert., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., meter: str # Filter results to only include alerts with the given meter., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/billing/alerts
@desc Create a billing alert
@returns(200) {alert_type: str, id: str, livemode: bool, object: str, status: str?, title: str, usage_threshold: any?} # Successful response.

@endpoint GET /v1/billing/alerts/{id}
@desc Retrieve a billing alert
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {alert_type: str, id: str, livemode: bool, object: str, status: str?, title: str, usage_threshold: any?} # Successful response.

@endpoint POST /v1/billing/alerts/{id}/activate
@desc Activate a billing alert
@required {id: str}
@returns(200) {alert_type: str, id: str, livemode: bool, object: str, status: str?, title: str, usage_threshold: any?} # Successful response.

@endpoint POST /v1/billing/alerts/{id}/archive
@desc Archive a billing alert
@required {id: str}
@returns(200) {alert_type: str, id: str, livemode: bool, object: str, status: str?, title: str, usage_threshold: any?} # Successful response.

@endpoint POST /v1/billing/alerts/{id}/deactivate
@desc Deactivate a billing alert
@required {id: str}
@returns(200) {alert_type: str, id: str, livemode: bool, object: str, status: str?, title: str, usage_threshold: any?} # Successful response.

@endpoint GET /v1/billing/credit_balance_summary
@desc Retrieve the credit balance summary for a customer
@required {filter: map # The filter criteria for the credit balance summary.}
@optional {customer: str # The customer whose credit balance summary you're retrieving., customer_account: str # The account representing the customer whose credit balance summary you're retrieving., expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {balances: [map], customer: any, customer_account: str?, livemode: bool, object: str} # Successful response.

@endpoint GET /v1/billing/credit_balance_transactions
@desc List credit balance transactions
@optional {credit_grant: str # The credit grant for which to fetch credit balance transactions., customer: str # The customer whose credit balance transactions you're retrieving., customer_account: str # The account representing the customer whose credit balance transactions you're retrieving., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/billing/credit_balance_transactions/{id}
@desc Retrieve a credit balance transaction
@required {id: str # Unique identifier for the object.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), credit: any?, credit_grant: any, debit: any?, effective_at: int(unix-time), id: str, livemode: bool, object: str, test_clock: any?, type: str?} # Successful response.

@endpoint GET /v1/billing/credit_grants
@desc List credit grants
@optional {customer: str # Only return credit grants for this customer., customer_account: str # Only return credit grants for this account representing the customer., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/billing/credit_grants
@desc Create a credit grant
@returns(200) {amount: map{monetary: any?, type: str}, applicability_config: map{scope: map{price_type: str, prices: [map]}}, category: str, created: int(unix-time), customer: any, customer_account: str?, effective_at: int(unix-time)?, expires_at: int(unix-time)?, id: str, livemode: bool, metadata: map, name: str?, object: str, priority: int?, test_clock: any?, updated: int(unix-time), voided_at: int(unix-time)?} # Successful response.

@endpoint GET /v1/billing/credit_grants/{id}
@desc Retrieve a credit grant
@required {id: str # Unique identifier for the object.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: map{monetary: any?, type: str}, applicability_config: map{scope: map{price_type: str, prices: [map]}}, category: str, created: int(unix-time), customer: any, customer_account: str?, effective_at: int(unix-time)?, expires_at: int(unix-time)?, id: str, livemode: bool, metadata: map, name: str?, object: str, priority: int?, test_clock: any?, updated: int(unix-time), voided_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/billing/credit_grants/{id}
@desc Update a credit grant
@required {id: str # Unique identifier for the object.}
@returns(200) {amount: map{monetary: any?, type: str}, applicability_config: map{scope: map{price_type: str, prices: [map]}}, category: str, created: int(unix-time), customer: any, customer_account: str?, effective_at: int(unix-time)?, expires_at: int(unix-time)?, id: str, livemode: bool, metadata: map, name: str?, object: str, priority: int?, test_clock: any?, updated: int(unix-time), voided_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/billing/credit_grants/{id}/expire
@desc Expire a credit grant
@required {id: str # Unique identifier for the object.}
@returns(200) {amount: map{monetary: any?, type: str}, applicability_config: map{scope: map{price_type: str, prices: [map]}}, category: str, created: int(unix-time), customer: any, customer_account: str?, effective_at: int(unix-time)?, expires_at: int(unix-time)?, id: str, livemode: bool, metadata: map, name: str?, object: str, priority: int?, test_clock: any?, updated: int(unix-time), voided_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/billing/credit_grants/{id}/void
@desc Void a credit grant
@required {id: str # Unique identifier for the object.}
@returns(200) {amount: map{monetary: any?, type: str}, applicability_config: map{scope: map{price_type: str, prices: [map]}}, category: str, created: int(unix-time), customer: any, customer_account: str?, effective_at: int(unix-time)?, expires_at: int(unix-time)?, id: str, livemode: bool, metadata: map, name: str?, object: str, priority: int?, test_clock: any?, updated: int(unix-time), voided_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/billing/meter_event_adjustments
@desc Create a billing meter event adjustment
@returns(200) {cancel: any?, event_name: str, livemode: bool, object: str, status: str, type: str} # Successful response.

@endpoint POST /v1/billing/meter_events
@desc Create a billing meter event
@returns(200) {created: int(unix-time), event_name: str, identifier: str, livemode: bool, object: str, payload: map, timestamp: int(unix-time)} # Successful response.

@endpoint GET /v1/billing/meters
@desc List billing meters
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(active/inactive) # Filter results to only include meters with the given status.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/billing/meters
@desc Create a billing meter
@returns(200) {created: int(unix-time), customer_mapping: map{event_payload_key: str, type: str}, default_aggregation: map{formula: str}, display_name: str, event_name: str, event_time_window: str?, id: str, livemode: bool, object: str, status: str, status_transitions: map{deactivated_at: int(unix-time)?}, updated: int(unix-time), value_settings: map{event_payload_key: str}} # Successful response.

@endpoint GET /v1/billing/meters/{id}
@desc Retrieve a billing meter
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), customer_mapping: map{event_payload_key: str, type: str}, default_aggregation: map{formula: str}, display_name: str, event_name: str, event_time_window: str?, id: str, livemode: bool, object: str, status: str, status_transitions: map{deactivated_at: int(unix-time)?}, updated: int(unix-time), value_settings: map{event_payload_key: str}} # Successful response.

@endpoint POST /v1/billing/meters/{id}
@desc Update a billing meter
@required {id: str}
@returns(200) {created: int(unix-time), customer_mapping: map{event_payload_key: str, type: str}, default_aggregation: map{formula: str}, display_name: str, event_name: str, event_time_window: str?, id: str, livemode: bool, object: str, status: str, status_transitions: map{deactivated_at: int(unix-time)?}, updated: int(unix-time), value_settings: map{event_payload_key: str}} # Successful response.

@endpoint POST /v1/billing/meters/{id}/deactivate
@desc Deactivate a billing meter
@required {id: str}
@returns(200) {created: int(unix-time), customer_mapping: map{event_payload_key: str, type: str}, default_aggregation: map{formula: str}, display_name: str, event_name: str, event_time_window: str?, id: str, livemode: bool, object: str, status: str, status_transitions: map{deactivated_at: int(unix-time)?}, updated: int(unix-time), value_settings: map{event_payload_key: str}} # Successful response.

@endpoint GET /v1/billing/meters/{id}/event_summaries
@desc List billing meter event summaries
@required {customer: str # The customer for which to fetch event summaries., end_time: int(unix-time) # The timestamp from when to stop aggregating meter events (exclusive). Must be aligned with minute boundaries., id: str # Unique identifier for the object., start_time: int(unix-time) # The timestamp from when to start aggregating meter events (inclusive). Must be aligned with minute boundaries.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., value_grouping_window: str(day/hour) # Specifies what granularity to use when generating event summaries. If not specified, a single event summary would be returned for the specified time range. For hourly granularity, start and end times must align with hour boundaries (e.g., 00:00, 01:00, ..., 23:00). For daily granularity, start and end times must align with UTC day boundaries (00:00 UTC).}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/billing/meters/{id}/reactivate
@desc Reactivate a billing meter
@required {id: str}
@returns(200) {created: int(unix-time), customer_mapping: map{event_payload_key: str, type: str}, default_aggregation: map{formula: str}, display_name: str, event_name: str, event_time_window: str?, id: str, livemode: bool, object: str, status: str, status_transitions: map{deactivated_at: int(unix-time)?}, updated: int(unix-time), value_settings: map{event_payload_key: str}} # Successful response.

@endgroup

@group billing_portal
@endpoint GET /v1/billing_portal/configurations
@desc List portal configurations
@optional {active: bool # Only return configurations that are active or inactive (e.g., pass `true` to only list active configurations)., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., is_default: bool # Only return the default or non-default configurations (e.g., pass `true` to only list the default configuration)., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/billing_portal/configurations
@desc Create a portal configuration
@returns(200) {active: bool, application: any?, business_profile: map{headline: str?, privacy_policy_url: str?, terms_of_service_url: str?}, created: int(unix-time), default_return_url: str?, features: map{customer_update: map{allowed_updates: [str], enabled: bool}, invoice_history: map{enabled: bool}, payment_method_update: map{enabled: bool, payment_method_configuration: str?}, subscription_cancel: map{cancellation_reason: map, enabled: bool, mode: str, proration_behavior: str}, subscription_update: map{billing_cycle_anchor: str?, default_allowed_updates: [str], enabled: bool, products: [map]?, proration_behavior: str, schedule_at_period_end: map, trial_update_behavior: str}}, id: str, is_default: bool, livemode: bool, login_page: map{enabled: bool, url: str?}, metadata: map?, name: str?, object: str, updated: int(unix-time)} # Successful response.

@endpoint GET /v1/billing_portal/configurations/{configuration}
@desc Retrieve a portal configuration
@required {configuration: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active: bool, application: any?, business_profile: map{headline: str?, privacy_policy_url: str?, terms_of_service_url: str?}, created: int(unix-time), default_return_url: str?, features: map{customer_update: map{allowed_updates: [str], enabled: bool}, invoice_history: map{enabled: bool}, payment_method_update: map{enabled: bool, payment_method_configuration: str?}, subscription_cancel: map{cancellation_reason: map, enabled: bool, mode: str, proration_behavior: str}, subscription_update: map{billing_cycle_anchor: str?, default_allowed_updates: [str], enabled: bool, products: [map]?, proration_behavior: str, schedule_at_period_end: map, trial_update_behavior: str}}, id: str, is_default: bool, livemode: bool, login_page: map{enabled: bool, url: str?}, metadata: map?, name: str?, object: str, updated: int(unix-time)} # Successful response.

@endpoint POST /v1/billing_portal/configurations/{configuration}
@desc Update a portal configuration
@required {configuration: str}
@returns(200) {active: bool, application: any?, business_profile: map{headline: str?, privacy_policy_url: str?, terms_of_service_url: str?}, created: int(unix-time), default_return_url: str?, features: map{customer_update: map{allowed_updates: [str], enabled: bool}, invoice_history: map{enabled: bool}, payment_method_update: map{enabled: bool, payment_method_configuration: str?}, subscription_cancel: map{cancellation_reason: map, enabled: bool, mode: str, proration_behavior: str}, subscription_update: map{billing_cycle_anchor: str?, default_allowed_updates: [str], enabled: bool, products: [map]?, proration_behavior: str, schedule_at_period_end: map, trial_update_behavior: str}}, id: str, is_default: bool, livemode: bool, login_page: map{enabled: bool, url: str?}, metadata: map?, name: str?, object: str, updated: int(unix-time)} # Successful response.

@endpoint POST /v1/billing_portal/sessions
@desc Create a portal session
@returns(200) {configuration: any, created: int(unix-time), customer: str, customer_account: str?, flow: any?, id: str, livemode: bool, locale: str?, object: str, on_behalf_of: str?, return_url: str?, url: str} # Successful response.

@endgroup

@group charges
@endpoint GET /v1/charges
@desc List all charges
@optional {created: any # Only return charges that were created during the given date interval., customer: str # Only return charges for the customer specified by this customer ID., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., payment_intent: str # Only return charges that were created by the PaymentIntent specified by this PaymentIntent ID., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., transfer_group: str # Only return charges for this transfer group, limited to 100.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/charges
@desc <p>This method is no longer recommendeduse the <a href="/docs/api/payment_intents">Payment Intents API</a>
@returns(200) {amount: int, amount_captured: int, amount_refunded: int, application: any?, application_fee: any?, application_fee_amount: int?, balance_transaction: any?, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, calculated_statement_descriptor: str?, captured: bool, created: int(unix-time), currency: str(currency), customer: any?, description: str?, disputed: bool, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, fraud_details: any?, id: str, livemode: bool, metadata: map, object: str, on_behalf_of: any?, outcome: any?, paid: bool, payment_intent: any?, payment_method: str?, payment_method_details: any?, presentment_details: map{presentment_amount: int, presentment_currency: str}, radar_options: map{session: str}, receipt_email: str?, receipt_number: str?, receipt_url: str?, refunded: bool, refunds: map?{data: [map], has_more: bool, object: str, url: str}, review: any?, shipping: any?, source_transfer: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer: any, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint GET /v1/charges/search
@desc Search charges
@required {query: str # The search query string. See [search query language](https://docs.stripe.com/search#search-query-language) and the list of supported [query fields for charges](https://docs.stripe.com/search#query-fields-for-charges).}
@optional {expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., page: str # A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.}
@returns(200) {data: [map], has_more: bool, next_page: str?, object: str, total_count: int, url: str} # Successful response.

@endpoint GET /v1/charges/{charge}
@desc Retrieve a charge
@required {charge: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, amount_captured: int, amount_refunded: int, application: any?, application_fee: any?, application_fee_amount: int?, balance_transaction: any?, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, calculated_statement_descriptor: str?, captured: bool, created: int(unix-time), currency: str(currency), customer: any?, description: str?, disputed: bool, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, fraud_details: any?, id: str, livemode: bool, metadata: map, object: str, on_behalf_of: any?, outcome: any?, paid: bool, payment_intent: any?, payment_method: str?, payment_method_details: any?, presentment_details: map{presentment_amount: int, presentment_currency: str}, radar_options: map{session: str}, receipt_email: str?, receipt_number: str?, receipt_url: str?, refunded: bool, refunds: map?{data: [map], has_more: bool, object: str, url: str}, review: any?, shipping: any?, source_transfer: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer: any, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint POST /v1/charges/{charge}
@desc Update a charge
@required {charge: str}
@returns(200) {amount: int, amount_captured: int, amount_refunded: int, application: any?, application_fee: any?, application_fee_amount: int?, balance_transaction: any?, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, calculated_statement_descriptor: str?, captured: bool, created: int(unix-time), currency: str(currency), customer: any?, description: str?, disputed: bool, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, fraud_details: any?, id: str, livemode: bool, metadata: map, object: str, on_behalf_of: any?, outcome: any?, paid: bool, payment_intent: any?, payment_method: str?, payment_method_details: any?, presentment_details: map{presentment_amount: int, presentment_currency: str}, radar_options: map{session: str}, receipt_email: str?, receipt_number: str?, receipt_url: str?, refunded: bool, refunds: map?{data: [map], has_more: bool, object: str, url: str}, review: any?, shipping: any?, source_transfer: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer: any, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint POST /v1/charges/{charge}/capture
@desc Capture a payment
@required {charge: str}
@returns(200) {amount: int, amount_captured: int, amount_refunded: int, application: any?, application_fee: any?, application_fee_amount: int?, balance_transaction: any?, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, calculated_statement_descriptor: str?, captured: bool, created: int(unix-time), currency: str(currency), customer: any?, description: str?, disputed: bool, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, fraud_details: any?, id: str, livemode: bool, metadata: map, object: str, on_behalf_of: any?, outcome: any?, paid: bool, payment_intent: any?, payment_method: str?, payment_method_details: any?, presentment_details: map{presentment_amount: int, presentment_currency: str}, radar_options: map{session: str}, receipt_email: str?, receipt_number: str?, receipt_url: str?, refunded: bool, refunds: map?{data: [map], has_more: bool, object: str, url: str}, review: any?, shipping: any?, source_transfer: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer: any, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint GET /v1/charges/{charge}/dispute
@desc <p>Retrieve a dispute for a specified charge.</p>
@required {charge: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, balance_transactions: [map], charge: any, created: int(unix-time), currency: str(currency), enhanced_eligibility_types: [str], evidence: map{access_activity_log: str?, billing_address: str?, cancellation_policy: any?, cancellation_policy_disclosure: str?, cancellation_rebuttal: str?, customer_communication: any?, customer_email_address: str?, customer_name: str?, customer_purchase_ip: str?, customer_signature: any?, duplicate_charge_documentation: any?, duplicate_charge_explanation: str?, duplicate_charge_id: str?, enhanced_evidence: map{visa_compelling_evidence_3: map, visa_compliance: map}, product_description: str?, receipt: any?, refund_policy: any?, refund_policy_disclosure: str?, refund_refusal_explanation: str?, service_date: str?, service_documentation: any?, shipping_address: str?, shipping_carrier: str?, shipping_date: str?, shipping_documentation: any?, shipping_tracking_number: str?, uncategorized_file: any?, uncategorized_text: str?}, evidence_details: map{due_by: int(unix-time)?, enhanced_eligibility: map{visa_compelling_evidence_3: map, visa_compliance: map}, has_evidence: bool, past_due: bool, submission_count: int}, id: str, is_charge_refundable: bool, livemode: bool, metadata: map, object: str, payment_intent: any?, payment_method_details: map{amazon_pay: map{dispute_type: str?}, card: map{brand: str, case_type: str, network_reason_code: str?}, klarna: map{chargeback_loss_reason_code: str, reason_code: str?}, paypal: map{case_id: str?, reason_code: str?}, type: str}, reason: str, status: str} # Successful response.

@endpoint POST /v1/charges/{charge}/dispute
@required {charge: str}
@returns(200) {amount: int, balance_transactions: [map], charge: any, created: int(unix-time), currency: str(currency), enhanced_eligibility_types: [str], evidence: map{access_activity_log: str?, billing_address: str?, cancellation_policy: any?, cancellation_policy_disclosure: str?, cancellation_rebuttal: str?, customer_communication: any?, customer_email_address: str?, customer_name: str?, customer_purchase_ip: str?, customer_signature: any?, duplicate_charge_documentation: any?, duplicate_charge_explanation: str?, duplicate_charge_id: str?, enhanced_evidence: map{visa_compelling_evidence_3: map, visa_compliance: map}, product_description: str?, receipt: any?, refund_policy: any?, refund_policy_disclosure: str?, refund_refusal_explanation: str?, service_date: str?, service_documentation: any?, shipping_address: str?, shipping_carrier: str?, shipping_date: str?, shipping_documentation: any?, shipping_tracking_number: str?, uncategorized_file: any?, uncategorized_text: str?}, evidence_details: map{due_by: int(unix-time)?, enhanced_eligibility: map{visa_compelling_evidence_3: map, visa_compliance: map}, has_evidence: bool, past_due: bool, submission_count: int}, id: str, is_charge_refundable: bool, livemode: bool, metadata: map, object: str, payment_intent: any?, payment_method_details: map{amazon_pay: map{dispute_type: str?}, card: map{brand: str, case_type: str, network_reason_code: str?}, klarna: map{chargeback_loss_reason_code: str, reason_code: str?}, paypal: map{case_id: str?, reason_code: str?}, type: str}, reason: str, status: str} # Successful response.

@endpoint POST /v1/charges/{charge}/dispute/close
@required {charge: str}
@returns(200) {amount: int, balance_transactions: [map], charge: any, created: int(unix-time), currency: str(currency), enhanced_eligibility_types: [str], evidence: map{access_activity_log: str?, billing_address: str?, cancellation_policy: any?, cancellation_policy_disclosure: str?, cancellation_rebuttal: str?, customer_communication: any?, customer_email_address: str?, customer_name: str?, customer_purchase_ip: str?, customer_signature: any?, duplicate_charge_documentation: any?, duplicate_charge_explanation: str?, duplicate_charge_id: str?, enhanced_evidence: map{visa_compelling_evidence_3: map, visa_compliance: map}, product_description: str?, receipt: any?, refund_policy: any?, refund_policy_disclosure: str?, refund_refusal_explanation: str?, service_date: str?, service_documentation: any?, shipping_address: str?, shipping_carrier: str?, shipping_date: str?, shipping_documentation: any?, shipping_tracking_number: str?, uncategorized_file: any?, uncategorized_text: str?}, evidence_details: map{due_by: int(unix-time)?, enhanced_eligibility: map{visa_compelling_evidence_3: map, visa_compliance: map}, has_evidence: bool, past_due: bool, submission_count: int}, id: str, is_charge_refundable: bool, livemode: bool, metadata: map, object: str, payment_intent: any?, payment_method_details: map{amazon_pay: map{dispute_type: str?}, card: map{brand: str, case_type: str, network_reason_code: str?}, klarna: map{chargeback_loss_reason_code: str, reason_code: str?}, paypal: map{case_id: str?, reason_code: str?}, type: str}, reason: str, status: str} # Successful response.

@endpoint POST /v1/charges/{charge}/refund
@desc Create a refund
@required {charge: str # The identifier of the charge to refund.}
@returns(200) {amount: int, amount_captured: int, amount_refunded: int, application: any?, application_fee: any?, application_fee_amount: int?, balance_transaction: any?, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, calculated_statement_descriptor: str?, captured: bool, created: int(unix-time), currency: str(currency), customer: any?, description: str?, disputed: bool, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, fraud_details: any?, id: str, livemode: bool, metadata: map, object: str, on_behalf_of: any?, outcome: any?, paid: bool, payment_intent: any?, payment_method: str?, payment_method_details: any?, presentment_details: map{presentment_amount: int, presentment_currency: str}, radar_options: map{session: str}, receipt_email: str?, receipt_number: str?, receipt_url: str?, refunded: bool, refunds: map?{data: [map], has_more: bool, object: str, url: str}, review: any?, shipping: any?, source_transfer: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer: any, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint GET /v1/charges/{charge}/refunds
@desc List all refunds
@required {charge: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/charges/{charge}/refunds
@desc Create customer balance refund
@required {charge: str # The identifier of the charge to refund.}
@returns(200) {amount: int, balance_transaction: any?, charge: any?, created: int(unix-time), currency: str(currency), description: str, destination_details: map{affirm: map, afterpay_clearpay: map, alipay: map, alma: map, amazon_pay: map, au_bank_transfer: map, blik: map{network_decline_code: str?, reference: str?, reference_status: str?}, br_bank_transfer: map{reference: str?, reference_status: str?}, card: map{reference: str, reference_status: str, reference_type: str, type: str}, cashapp: map, crypto: map{reference: str?}, customer_cash_balance: map, eps: map, eu_bank_transfer: map{reference: str?, reference_status: str?}, gb_bank_transfer: map{reference: str?, reference_status: str?}, giropay: map, grabpay: map, jp_bank_transfer: map{reference: str?, reference_status: str?}, klarna: map, mb_way: map{reference: str?, reference_status: str?}, multibanco: map{reference: str?, reference_status: str?}, mx_bank_transfer: map{reference: str?, reference_status: str?}, nz_bank_transfer: map, p24: map{reference: str?, reference_status: str?}, paynow: map, paypal: map{network_decline_code: str?}, pix: map, revolut: map, sofort: map, swish: map{network_decline_code: str?, reference: str?, reference_status: str?}, th_bank_transfer: map{reference: str?, reference_status: str?}, twint: map, type: str, us_bank_transfer: map{reference: str?, reference_status: str?}, wechat_pay: map, zip: map}, failure_balance_transaction: any, failure_reason: str, id: str, instructions_email: str, metadata: map?, next_action: map{display_details: map{email_sent: map, expires_at: int(unix-time)}, type: str}, object: str, payment_intent: any?, pending_reason: str, presentment_details: map{presentment_amount: int, presentment_currency: str}, reason: str?, receipt_number: str?, source_transfer_reversal: any?, status: str?, transfer_reversal: any?} # Successful response.

@endpoint GET /v1/charges/{charge}/refunds/{refund}
@desc <p>Retrieves the details of an existing refund.</p>
@required {charge: str, refund: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, balance_transaction: any?, charge: any?, created: int(unix-time), currency: str(currency), description: str, destination_details: map{affirm: map, afterpay_clearpay: map, alipay: map, alma: map, amazon_pay: map, au_bank_transfer: map, blik: map{network_decline_code: str?, reference: str?, reference_status: str?}, br_bank_transfer: map{reference: str?, reference_status: str?}, card: map{reference: str, reference_status: str, reference_type: str, type: str}, cashapp: map, crypto: map{reference: str?}, customer_cash_balance: map, eps: map, eu_bank_transfer: map{reference: str?, reference_status: str?}, gb_bank_transfer: map{reference: str?, reference_status: str?}, giropay: map, grabpay: map, jp_bank_transfer: map{reference: str?, reference_status: str?}, klarna: map, mb_way: map{reference: str?, reference_status: str?}, multibanco: map{reference: str?, reference_status: str?}, mx_bank_transfer: map{reference: str?, reference_status: str?}, nz_bank_transfer: map, p24: map{reference: str?, reference_status: str?}, paynow: map, paypal: map{network_decline_code: str?}, pix: map, revolut: map, sofort: map, swish: map{network_decline_code: str?, reference: str?, reference_status: str?}, th_bank_transfer: map{reference: str?, reference_status: str?}, twint: map, type: str, us_bank_transfer: map{reference: str?, reference_status: str?}, wechat_pay: map, zip: map}, failure_balance_transaction: any, failure_reason: str, id: str, instructions_email: str, metadata: map?, next_action: map{display_details: map{email_sent: map, expires_at: int(unix-time)}, type: str}, object: str, payment_intent: any?, pending_reason: str, presentment_details: map{presentment_amount: int, presentment_currency: str}, reason: str?, receipt_number: str?, source_transfer_reversal: any?, status: str?, transfer_reversal: any?} # Successful response.

@endpoint POST /v1/charges/{charge}/refunds/{refund}
@desc <p>Update a specified refund.</p>
@required {charge: str, refund: str}
@returns(200) {amount: int, balance_transaction: any?, charge: any?, created: int(unix-time), currency: str(currency), description: str, destination_details: map{affirm: map, afterpay_clearpay: map, alipay: map, alma: map, amazon_pay: map, au_bank_transfer: map, blik: map{network_decline_code: str?, reference: str?, reference_status: str?}, br_bank_transfer: map{reference: str?, reference_status: str?}, card: map{reference: str, reference_status: str, reference_type: str, type: str}, cashapp: map, crypto: map{reference: str?}, customer_cash_balance: map, eps: map, eu_bank_transfer: map{reference: str?, reference_status: str?}, gb_bank_transfer: map{reference: str?, reference_status: str?}, giropay: map, grabpay: map, jp_bank_transfer: map{reference: str?, reference_status: str?}, klarna: map, mb_way: map{reference: str?, reference_status: str?}, multibanco: map{reference: str?, reference_status: str?}, mx_bank_transfer: map{reference: str?, reference_status: str?}, nz_bank_transfer: map, p24: map{reference: str?, reference_status: str?}, paynow: map, paypal: map{network_decline_code: str?}, pix: map, revolut: map, sofort: map, swish: map{network_decline_code: str?, reference: str?, reference_status: str?}, th_bank_transfer: map{reference: str?, reference_status: str?}, twint: map, type: str, us_bank_transfer: map{reference: str?, reference_status: str?}, wechat_pay: map, zip: map}, failure_balance_transaction: any, failure_reason: str, id: str, instructions_email: str, metadata: map?, next_action: map{display_details: map{email_sent: map, expires_at: int(unix-time)}, type: str}, object: str, payment_intent: any?, pending_reason: str, presentment_details: map{presentment_amount: int, presentment_currency: str}, reason: str?, receipt_number: str?, source_transfer_reversal: any?, status: str?, transfer_reversal: any?} # Successful response.

@endgroup

@group checkout
@endpoint GET /v1/checkout/sessions
@desc List all Checkout Sessions
@optional {created: any # Only return Checkout Sessions that were created during the given date interval., customer: str # Only return the Checkout Sessions for the Customer specified., customer_account: str # Only return the Checkout Sessions for the Account specified., customer_details: map # Only return the Checkout Sessions for the Customer details specified., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., payment_intent: str # Only return the Checkout Session for the PaymentIntent specified., payment_link: str # Only return the Checkout Sessions for the Payment Link specified., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(complete/expired/open) # Only return the Checkout Sessions matching the given status., subscription: str # Only return the Checkout Session for the subscription specified.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/checkout/sessions
@desc Create a Checkout Session
@returns(200) {adaptive_pricing: any?, after_expiration: any?, allow_promotion_codes: bool?, amount_subtotal: int?, amount_total: int?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, billing_address_collection: str?, branding_settings: map{background_color: str, border_style: str, button_color: str, display_name: str, font_family: str, icon: any?, logo: any?}, cancel_url: str?, client_reference_id: str?, client_secret: str?, collected_information: any?, consent: any?, consent_collection: any?, created: int(unix-time), currency: str(currency)?, currency_conversion: any?, custom_fields: [map], custom_text: map{after_submit: any?, shipping_address: any?, submit: any?, terms_of_service_acceptance: any?}, customer: any?, customer_account: str?, customer_creation: str?, customer_details: any?, customer_email: str?, discounts: [map]?, excluded_payment_method_types: [str], expires_at: int(unix-time), id: str, invoice: any?, invoice_creation: any?, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, locale: str?, metadata: map?, mode: str, name_collection: map{business: map{enabled: bool, optional: bool}, individual: map{enabled: bool, optional: bool}}, object: str, optional_items: [map]?, origin_context: str?, payment_intent: any?, payment_link: any?, payment_method_collection: str?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], payment_status: str, permissions: any?, phone_number_collection: map{enabled: bool}, presentment_details: map{presentment_amount: int, presentment_currency: str}, recovered_from: str?, redirect_on_completion: str, return_url: str, saved_payment_method_options: any?, setup_intent: any?, shipping_address_collection: any?, shipping_cost: any?, shipping_options: [map], status: str?, submit_type: str?, subscription: any?, success_url: str?, tax_id_collection: map{enabled: bool, required: str}, total_details: any?, ui_mode: str?, url: str?, wallet_options: any?} # Successful response.

@endpoint GET /v1/checkout/sessions/{session}
@desc Retrieve a Checkout Session
@required {session: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {adaptive_pricing: any?, after_expiration: any?, allow_promotion_codes: bool?, amount_subtotal: int?, amount_total: int?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, billing_address_collection: str?, branding_settings: map{background_color: str, border_style: str, button_color: str, display_name: str, font_family: str, icon: any?, logo: any?}, cancel_url: str?, client_reference_id: str?, client_secret: str?, collected_information: any?, consent: any?, consent_collection: any?, created: int(unix-time), currency: str(currency)?, currency_conversion: any?, custom_fields: [map], custom_text: map{after_submit: any?, shipping_address: any?, submit: any?, terms_of_service_acceptance: any?}, customer: any?, customer_account: str?, customer_creation: str?, customer_details: any?, customer_email: str?, discounts: [map]?, excluded_payment_method_types: [str], expires_at: int(unix-time), id: str, invoice: any?, invoice_creation: any?, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, locale: str?, metadata: map?, mode: str, name_collection: map{business: map{enabled: bool, optional: bool}, individual: map{enabled: bool, optional: bool}}, object: str, optional_items: [map]?, origin_context: str?, payment_intent: any?, payment_link: any?, payment_method_collection: str?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], payment_status: str, permissions: any?, phone_number_collection: map{enabled: bool}, presentment_details: map{presentment_amount: int, presentment_currency: str}, recovered_from: str?, redirect_on_completion: str, return_url: str, saved_payment_method_options: any?, setup_intent: any?, shipping_address_collection: any?, shipping_cost: any?, shipping_options: [map], status: str?, submit_type: str?, subscription: any?, success_url: str?, tax_id_collection: map{enabled: bool, required: str}, total_details: any?, ui_mode: str?, url: str?, wallet_options: any?} # Successful response.

@endpoint POST /v1/checkout/sessions/{session}
@desc Update a Checkout Session
@required {session: str}
@returns(200) {adaptive_pricing: any?, after_expiration: any?, allow_promotion_codes: bool?, amount_subtotal: int?, amount_total: int?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, billing_address_collection: str?, branding_settings: map{background_color: str, border_style: str, button_color: str, display_name: str, font_family: str, icon: any?, logo: any?}, cancel_url: str?, client_reference_id: str?, client_secret: str?, collected_information: any?, consent: any?, consent_collection: any?, created: int(unix-time), currency: str(currency)?, currency_conversion: any?, custom_fields: [map], custom_text: map{after_submit: any?, shipping_address: any?, submit: any?, terms_of_service_acceptance: any?}, customer: any?, customer_account: str?, customer_creation: str?, customer_details: any?, customer_email: str?, discounts: [map]?, excluded_payment_method_types: [str], expires_at: int(unix-time), id: str, invoice: any?, invoice_creation: any?, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, locale: str?, metadata: map?, mode: str, name_collection: map{business: map{enabled: bool, optional: bool}, individual: map{enabled: bool, optional: bool}}, object: str, optional_items: [map]?, origin_context: str?, payment_intent: any?, payment_link: any?, payment_method_collection: str?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], payment_status: str, permissions: any?, phone_number_collection: map{enabled: bool}, presentment_details: map{presentment_amount: int, presentment_currency: str}, recovered_from: str?, redirect_on_completion: str, return_url: str, saved_payment_method_options: any?, setup_intent: any?, shipping_address_collection: any?, shipping_cost: any?, shipping_options: [map], status: str?, submit_type: str?, subscription: any?, success_url: str?, tax_id_collection: map{enabled: bool, required: str}, total_details: any?, ui_mode: str?, url: str?, wallet_options: any?} # Successful response.

@endpoint POST /v1/checkout/sessions/{session}/expire
@desc Expire a Checkout Session
@required {session: str}
@returns(200) {adaptive_pricing: any?, after_expiration: any?, allow_promotion_codes: bool?, amount_subtotal: int?, amount_total: int?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, billing_address_collection: str?, branding_settings: map{background_color: str, border_style: str, button_color: str, display_name: str, font_family: str, icon: any?, logo: any?}, cancel_url: str?, client_reference_id: str?, client_secret: str?, collected_information: any?, consent: any?, consent_collection: any?, created: int(unix-time), currency: str(currency)?, currency_conversion: any?, custom_fields: [map], custom_text: map{after_submit: any?, shipping_address: any?, submit: any?, terms_of_service_acceptance: any?}, customer: any?, customer_account: str?, customer_creation: str?, customer_details: any?, customer_email: str?, discounts: [map]?, excluded_payment_method_types: [str], expires_at: int(unix-time), id: str, invoice: any?, invoice_creation: any?, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, locale: str?, metadata: map?, mode: str, name_collection: map{business: map{enabled: bool, optional: bool}, individual: map{enabled: bool, optional: bool}}, object: str, optional_items: [map]?, origin_context: str?, payment_intent: any?, payment_link: any?, payment_method_collection: str?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], payment_status: str, permissions: any?, phone_number_collection: map{enabled: bool}, presentment_details: map{presentment_amount: int, presentment_currency: str}, recovered_from: str?, redirect_on_completion: str, return_url: str, saved_payment_method_options: any?, setup_intent: any?, shipping_address_collection: any?, shipping_cost: any?, shipping_options: [map], status: str?, submit_type: str?, subscription: any?, success_url: str?, tax_id_collection: map{enabled: bool, required: str}, total_details: any?, ui_mode: str?, url: str?, wallet_options: any?} # Successful response.

@endpoint GET /v1/checkout/sessions/{session}/line_items
@desc Retrieve a Checkout Session's line items
@required {session: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endgroup

@group climate
@endpoint GET /v1/climate/orders
@desc List orders
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/climate/orders
@desc Create an order
@returns(200) {amount_fees: int, amount_subtotal: int, amount_total: int, beneficiary: map{public_name: str}, canceled_at: int(unix-time)?, cancellation_reason: str?, certificate: str?, confirmed_at: int(unix-time)?, created: int(unix-time), currency: str, delayed_at: int(unix-time)?, delivered_at: int(unix-time)?, delivery_details: [map], expected_delivery_year: int, id: str, livemode: bool, metadata: map, metric_tons: str(decimal), object: str, product: any, product_substituted_at: int(unix-time)?, status: str} # Successful response.

@endpoint GET /v1/climate/orders/{order}
@desc Retrieve an order
@required {order: str # Unique identifier of the order.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount_fees: int, amount_subtotal: int, amount_total: int, beneficiary: map{public_name: str}, canceled_at: int(unix-time)?, cancellation_reason: str?, certificate: str?, confirmed_at: int(unix-time)?, created: int(unix-time), currency: str, delayed_at: int(unix-time)?, delivered_at: int(unix-time)?, delivery_details: [map], expected_delivery_year: int, id: str, livemode: bool, metadata: map, metric_tons: str(decimal), object: str, product: any, product_substituted_at: int(unix-time)?, status: str} # Successful response.

@endpoint POST /v1/climate/orders/{order}
@desc Update an order
@required {order: str # Unique identifier of the order.}
@returns(200) {amount_fees: int, amount_subtotal: int, amount_total: int, beneficiary: map{public_name: str}, canceled_at: int(unix-time)?, cancellation_reason: str?, certificate: str?, confirmed_at: int(unix-time)?, created: int(unix-time), currency: str, delayed_at: int(unix-time)?, delivered_at: int(unix-time)?, delivery_details: [map], expected_delivery_year: int, id: str, livemode: bool, metadata: map, metric_tons: str(decimal), object: str, product: any, product_substituted_at: int(unix-time)?, status: str} # Successful response.

@endpoint POST /v1/climate/orders/{order}/cancel
@desc Cancel an order
@required {order: str # Unique identifier of the order.}
@returns(200) {amount_fees: int, amount_subtotal: int, amount_total: int, beneficiary: map{public_name: str}, canceled_at: int(unix-time)?, cancellation_reason: str?, certificate: str?, confirmed_at: int(unix-time)?, created: int(unix-time), currency: str, delayed_at: int(unix-time)?, delivered_at: int(unix-time)?, delivery_details: [map], expected_delivery_year: int, id: str, livemode: bool, metadata: map, metric_tons: str(decimal), object: str, product: any, product_substituted_at: int(unix-time)?, status: str} # Successful response.

@endpoint GET /v1/climate/products
@desc List products
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/climate/products/{product}
@desc Retrieve a product
@required {product: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), current_prices_per_metric_ton: map, delivery_year: int?, id: str, livemode: bool, metric_tons_available: str(decimal), name: str, object: str, suppliers: [map]} # Successful response.

@endpoint GET /v1/climate/suppliers
@desc List suppliers
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/climate/suppliers/{supplier}
@desc Retrieve a supplier
@required {supplier: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {id: str, info_url: str, livemode: bool, locations: [map], name: str, object: str, removal_pathway: str} # Successful response.

@endgroup

@group confirmation_tokens
@endpoint GET /v1/confirmation_tokens/{confirmation_token}
@desc Retrieve a ConfirmationToken
@required {confirmation_token: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), expires_at: int(unix-time)?, id: str, livemode: bool, mandate_data: any?, object: str, payment_intent: str?, payment_method_options: any?, payment_method_preview: any?, return_url: str?, setup_future_usage: str?, setup_intent: str?, shipping: any?, use_stripe_sdk: bool} # Successful response.

@endgroup

@group country_specs
@endpoint GET /v1/country_specs
@desc List Country Specs
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/country_specs/{country}
@desc Retrieve a Country Spec
@required {country: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {default_currency: str, id: str, object: str, supported_bank_account_currencies: map, supported_payment_currencies: [str], supported_payment_methods: [str], supported_transfer_countries: [str], verification_fields: map{company: map{additional: [str], minimum: [str]}, individual: map{additional: [str], minimum: [str]}}} # Successful response.

@endgroup

@group coupons
@endpoint GET /v1/coupons
@desc List all coupons
@optional {created: any # A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/coupons
@desc Create a coupon
@returns(200) {amount_off: int?, applies_to: map{products: [str]}, created: int(unix-time), currency: str(currency)?, currency_options: map, duration: str, duration_in_months: int?, id: str, livemode: bool, max_redemptions: int?, metadata: map?, name: str?, object: str, percent_off: num?, redeem_by: int(unix-time)?, times_redeemed: int, valid: bool} # Successful response.

@endpoint DELETE /v1/coupons/{coupon}
@desc Delete a coupon
@required {coupon: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/coupons/{coupon}
@desc Retrieve a coupon
@required {coupon: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount_off: int?, applies_to: map{products: [str]}, created: int(unix-time), currency: str(currency)?, currency_options: map, duration: str, duration_in_months: int?, id: str, livemode: bool, max_redemptions: int?, metadata: map?, name: str?, object: str, percent_off: num?, redeem_by: int(unix-time)?, times_redeemed: int, valid: bool} # Successful response.

@endpoint POST /v1/coupons/{coupon}
@desc Update a coupon
@required {coupon: str}
@returns(200) {amount_off: int?, applies_to: map{products: [str]}, created: int(unix-time), currency: str(currency)?, currency_options: map, duration: str, duration_in_months: int?, id: str, livemode: bool, max_redemptions: int?, metadata: map?, name: str?, object: str, percent_off: num?, redeem_by: int(unix-time)?, times_redeemed: int, valid: bool} # Successful response.

@endgroup

@group credit_notes
@endpoint GET /v1/credit_notes
@desc List all credit notes
@optional {created: any # Only return credit notes that were created during the given date interval., customer: str # Only return credit notes for the customer specified by this customer ID., customer_account: str # Only return credit notes for the account representing the customer specified by this account ID., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., invoice: str # Only return credit notes for the invoice specified by this invoice ID., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/credit_notes
@desc Create a credit note
@returns(200) {amount: int, amount_shipping: int, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, customer_balance_transaction: any?, discount_amount: int, discount_amounts: [map], effective_at: int(unix-time)?, id: str, invoice: any, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, memo: str?, metadata: map?, number: str, object: str, out_of_band_amount: int?, pdf: str, post_payment_amount: int, pre_payment_amount: int, pretax_credit_amounts: [map], reason: str?, refunds: [map], shipping_cost: any?, status: str, subtotal: int, subtotal_excluding_tax: int?, total: int, total_excluding_tax: int?, total_taxes: [map]?, type: str, voided_at: int(unix-time)?} # Successful response.

@endpoint GET /v1/credit_notes/preview
@desc Preview a credit note
@required {invoice: str # ID of the invoice.}
@optional {amount: int # The integer amount in cents (or local equivalent) representing the total amount of the credit note. One of `amount`, `lines`, or `shipping_cost` must be provided., credit_amount: int # The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice., effective_at: int(unix-time) # The date when this credit note is in effect. Same as `created` unless overwritten. When defined, this value replaces the system-generated 'Date of issue' printed on the credit note PDF., email_type: str(credit_note/none) # Type of email to send to the customer, one of `credit_note` or `none` and the default is `credit_note`., expand: [str] # Specifies which fields in the response should be expanded., lines: [map] # Line items that make up the credit note. One of `amount`, `lines`, or `shipping_cost` must be provided., memo: str # The credit note's memo appears on the credit note PDF., metadata: map # Set of [key-value pairs](https://docs.stripe.com/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`., out_of_band_amount: int # The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe., reason: str(duplicate/fraudulent/order_change/product_unsatisfactory) # Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`, refund_amount: int # The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice., refunds: [map] # Refunds to link to this credit note., shipping_cost: map # When shipping_cost contains the shipping_rate from the invoice, the shipping_cost is included in the credit note. One of `amount`, `lines`, or `shipping_cost` must be provided.}
@returns(200) {amount: int, amount_shipping: int, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, customer_balance_transaction: any?, discount_amount: int, discount_amounts: [map], effective_at: int(unix-time)?, id: str, invoice: any, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, memo: str?, metadata: map?, number: str, object: str, out_of_band_amount: int?, pdf: str, post_payment_amount: int, pre_payment_amount: int, pretax_credit_amounts: [map], reason: str?, refunds: [map], shipping_cost: any?, status: str, subtotal: int, subtotal_excluding_tax: int?, total: int, total_excluding_tax: int?, total_taxes: [map]?, type: str, voided_at: int(unix-time)?} # Successful response.

@endpoint GET /v1/credit_notes/preview/lines
@desc Retrieve a credit note preview's line items
@required {invoice: str # ID of the invoice.}
@optional {amount: int # The integer amount in cents (or local equivalent) representing the total amount of the credit note. One of `amount`, `lines`, or `shipping_cost` must be provided., credit_amount: int # The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice., effective_at: int(unix-time) # The date when this credit note is in effect. Same as `created` unless overwritten. When defined, this value replaces the system-generated 'Date of issue' printed on the credit note PDF., email_type: str(credit_note/none) # Type of email to send to the customer, one of `credit_note` or `none` and the default is `credit_note`., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., lines: [map] # Line items that make up the credit note. One of `amount`, `lines`, or `shipping_cost` must be provided., memo: str # The credit note's memo appears on the credit note PDF., metadata: map # Set of [key-value pairs](https://docs.stripe.com/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`., out_of_band_amount: int # The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe., reason: str(duplicate/fraudulent/order_change/product_unsatisfactory) # Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`, refund_amount: int # The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice., refunds: [map] # Refunds to link to this credit note., shipping_cost: map # When shipping_cost contains the shipping_rate from the invoice, the shipping_cost is included in the credit note. One of `amount`, `lines`, or `shipping_cost` must be provided., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/credit_notes/{credit_note}/lines
@desc Retrieve a credit note's line items
@required {credit_note: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/credit_notes/{id}
@desc Retrieve a credit note
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, amount_shipping: int, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, customer_balance_transaction: any?, discount_amount: int, discount_amounts: [map], effective_at: int(unix-time)?, id: str, invoice: any, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, memo: str?, metadata: map?, number: str, object: str, out_of_band_amount: int?, pdf: str, post_payment_amount: int, pre_payment_amount: int, pretax_credit_amounts: [map], reason: str?, refunds: [map], shipping_cost: any?, status: str, subtotal: int, subtotal_excluding_tax: int?, total: int, total_excluding_tax: int?, total_taxes: [map]?, type: str, voided_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/credit_notes/{id}
@desc Update a credit note
@required {id: str}
@returns(200) {amount: int, amount_shipping: int, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, customer_balance_transaction: any?, discount_amount: int, discount_amounts: [map], effective_at: int(unix-time)?, id: str, invoice: any, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, memo: str?, metadata: map?, number: str, object: str, out_of_band_amount: int?, pdf: str, post_payment_amount: int, pre_payment_amount: int, pretax_credit_amounts: [map], reason: str?, refunds: [map], shipping_cost: any?, status: str, subtotal: int, subtotal_excluding_tax: int?, total: int, total_excluding_tax: int?, total_taxes: [map]?, type: str, voided_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/credit_notes/{id}/void
@desc Void a credit note
@required {id: str}
@returns(200) {amount: int, amount_shipping: int, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, customer_balance_transaction: any?, discount_amount: int, discount_amounts: [map], effective_at: int(unix-time)?, id: str, invoice: any, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, memo: str?, metadata: map?, number: str, object: str, out_of_band_amount: int?, pdf: str, post_payment_amount: int, pre_payment_amount: int, pretax_credit_amounts: [map], reason: str?, refunds: [map], shipping_cost: any?, status: str, subtotal: int, subtotal_excluding_tax: int?, total: int, total_excluding_tax: int?, total_taxes: [map]?, type: str, voided_at: int(unix-time)?} # Successful response.

@endgroup

@group customer_sessions
@endpoint POST /v1/customer_sessions
@desc Create a Customer Session
@returns(200) {client_secret: str, components: map{buy_button: map{enabled: bool}, customer_sheet: map{enabled: bool, features: any?}, mobile_payment_element: map{enabled: bool, features: any?}, payment_element: map{enabled: bool, features: any?}, pricing_table: map{enabled: bool}}, created: int(unix-time), customer: any, customer_account: str?, expires_at: int(unix-time), livemode: bool, object: str} # Successful response.

@endgroup

@group customers
@endpoint GET /v1/customers
@desc List all customers
@optional {created: any # Only return customers that were created during the given date interval., email: str # A case-sensitive filter on the list based on the customer's `email` field. The value must be a string., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., test_clock: str # Provides a list of customers that are associated with the specified test clock. The response will not include customers with test clocks if this parameter is not set.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/customers
@desc Create a customer
@returns(200) {address: any?, balance: int, business_name: str, cash_balance: any?, created: int(unix-time), currency: str?, customer_account: str?, default_source: any?, delinquent: bool?, description: str?, discount: any?, email: str?, id: str, individual_name: str, invoice_credit_balance: map, invoice_prefix: str?, invoice_settings: map{custom_fields: [map]?, default_payment_method: any?, footer: str?, rendering_options: any?}, livemode: bool, metadata: map, name: str?, next_invoice_sequence: int, object: str, phone: str?, preferred_locales: [str]?, shipping: any?, sources: map{data: [any], has_more: bool, object: str, url: str}, subscriptions: map{data: [map], has_more: bool, object: str, url: str}, tax: map{automatic_tax: str, ip_address: str?, location: any?, provider: str}, tax_exempt: str?, tax_ids: map{data: [map], has_more: bool, object: str, url: str}, test_clock: any?} # Successful response.

@endpoint GET /v1/customers/search
@desc Search customers
@required {query: str # The search query string. See [search query language](https://docs.stripe.com/search#search-query-language) and the list of supported [query fields for customers](https://docs.stripe.com/search#query-fields-for-customers).}
@optional {expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., page: str # A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.}
@returns(200) {data: [map], has_more: bool, next_page: str?, object: str, total_count: int, url: str} # Successful response.

@endpoint DELETE /v1/customers/{customer}
@desc Delete a customer
@required {customer: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/customers/{customer}
@desc Retrieve a customer
@required {customer: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) Successful response.

@endpoint POST /v1/customers/{customer}
@desc Update a customer
@required {customer: str}
@returns(200) {address: any?, balance: int, business_name: str, cash_balance: any?, created: int(unix-time), currency: str?, customer_account: str?, default_source: any?, delinquent: bool?, description: str?, discount: any?, email: str?, id: str, individual_name: str, invoice_credit_balance: map, invoice_prefix: str?, invoice_settings: map{custom_fields: [map]?, default_payment_method: any?, footer: str?, rendering_options: any?}, livemode: bool, metadata: map, name: str?, next_invoice_sequence: int, object: str, phone: str?, preferred_locales: [str]?, shipping: any?, sources: map{data: [any], has_more: bool, object: str, url: str}, subscriptions: map{data: [map], has_more: bool, object: str, url: str}, tax: map{automatic_tax: str, ip_address: str?, location: any?, provider: str}, tax_exempt: str?, tax_ids: map{data: [map], has_more: bool, object: str, url: str}, test_clock: any?} # Successful response.

@endpoint GET /v1/customers/{customer}/balance_transactions
@desc List customer balance transactions
@required {customer: str}
@optional {created: any # Only return customer balance transactions that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., invoice: str # Only return transactions that are related to the specified invoice., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/customers/{customer}/balance_transactions
@desc Create a customer balance transaction
@required {customer: str}
@returns(200) {amount: int, checkout_session: any?, created: int(unix-time), credit_note: any?, currency: str(currency), customer: any, customer_account: str?, description: str?, ending_balance: int, id: str, invoice: any?, livemode: bool, metadata: map?, object: str, type: str} # Successful response.

@endpoint GET /v1/customers/{customer}/balance_transactions/{transaction}
@desc Retrieve a customer balance transaction
@required {customer: str, transaction: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, checkout_session: any?, created: int(unix-time), credit_note: any?, currency: str(currency), customer: any, customer_account: str?, description: str?, ending_balance: int, id: str, invoice: any?, livemode: bool, metadata: map?, object: str, type: str} # Successful response.

@endpoint POST /v1/customers/{customer}/balance_transactions/{transaction}
@desc Update a customer credit balance transaction
@required {customer: str, transaction: str}
@returns(200) {amount: int, checkout_session: any?, created: int(unix-time), credit_note: any?, currency: str(currency), customer: any, customer_account: str?, description: str?, ending_balance: int, id: str, invoice: any?, livemode: bool, metadata: map?, object: str, type: str} # Successful response.

@endpoint GET /v1/customers/{customer}/bank_accounts
@desc List all bank accounts
@required {customer: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/customers/{customer}/bank_accounts
@desc Create a card
@required {customer: str}
@returns(200) Successful response.

@endpoint DELETE /v1/customers/{customer}/bank_accounts/{id}
@desc Delete a customer source
@required {customer: str, id: str}
@returns(200) Successful response.

@endpoint GET /v1/customers/{customer}/bank_accounts/{id}
@desc Retrieve a bank account
@required {customer: str, id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account: any?, account_holder_name: str?, account_holder_type: str?, account_type: str?, available_payout_methods: [str]?, bank_name: str?, country: str, currency: str(currency), customer: any?, default_for_currency: bool?, fingerprint: str?, future_requirements: any?, id: str, last4: str, metadata: map?, object: str, requirements: any?, routing_number: str?, status: str} # Successful response.

@endpoint POST /v1/customers/{customer}/bank_accounts/{id}
@desc <p>Update a specified source for a given customer.</p>
@required {customer: str, id: str}
@returns(200) Successful response.

@endpoint POST /v1/customers/{customer}/bank_accounts/{id}/verify
@desc Verify a bank account
@required {customer: str, id: str}
@returns(200) {account: any?, account_holder_name: str?, account_holder_type: str?, account_type: str?, available_payout_methods: [str]?, bank_name: str?, country: str, currency: str(currency), customer: any?, default_for_currency: bool?, fingerprint: str?, future_requirements: any?, id: str, last4: str, metadata: map?, object: str, requirements: any?, routing_number: str?, status: str} # Successful response.

@endpoint GET /v1/customers/{customer}/cards
@desc List all cards
@required {customer: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/customers/{customer}/cards
@desc Create a card
@required {customer: str}
@returns(200) Successful response.

@endpoint DELETE /v1/customers/{customer}/cards/{id}
@desc Delete a customer source
@required {customer: str, id: str}
@returns(200) Successful response.

@endpoint GET /v1/customers/{customer}/cards/{id}
@desc Retrieve a card
@required {customer: str, id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account: any?, address_city: str?, address_country: str?, address_line1: str?, address_line1_check: str?, address_line2: str?, address_state: str?, address_zip: str?, address_zip_check: str?, allow_redisplay: str?, available_payout_methods: [str]?, brand: str, country: str?, currency: str(currency)?, customer: any?, cvc_check: str?, default_for_currency: bool?, dynamic_last4: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str, id: str, iin: str, last4: str, metadata: map?, name: str?, networks: map{preferred: str?}, object: str, regulated_status: str?, status: str?, tokenization_method: str?} # Successful response.

@endpoint POST /v1/customers/{customer}/cards/{id}
@desc <p>Update a specified source for a given customer.</p>
@required {customer: str, id: str}
@returns(200) Successful response.

@endpoint GET /v1/customers/{customer}/cash_balance
@desc Retrieve a cash balance
@required {customer: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {available: map?, customer: str, customer_account: str?, livemode: bool, object: str, settings: map{reconciliation_mode: str, using_merchant_default: bool}} # Successful response.

@endpoint POST /v1/customers/{customer}/cash_balance
@desc Update a cash balance's settings
@required {customer: str}
@returns(200) {available: map?, customer: str, customer_account: str?, livemode: bool, object: str, settings: map{reconciliation_mode: str, using_merchant_default: bool}} # Successful response.

@endpoint GET /v1/customers/{customer}/cash_balance_transactions
@desc List cash balance transactions
@required {customer: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/customers/{customer}/cash_balance_transactions/{transaction}
@desc Retrieve a cash balance transaction
@required {customer: str, transaction: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {adjusted_for_overdraft: map{balance_transaction: any, linked_transaction: any}, applied_to_payment: map{payment_intent: any}, created: int(unix-time), currency: str, customer: any, customer_account: str?, ending_balance: int, funded: map{bank_transfer: map{eu_bank_transfer: map, gb_bank_transfer: map, jp_bank_transfer: map, reference: str?, type: str, us_bank_transfer: map}}, id: str, livemode: bool, net_amount: int, object: str, refunded_from_payment: map{refund: any}, transferred_to_balance: map{balance_transaction: any}, type: str, unapplied_from_payment: map{payment_intent: any}} # Successful response.

@endpoint DELETE /v1/customers/{customer}/discount
@desc Delete a customer discount
@required {customer: str}
@returns(200) {checkout_session: str?, customer: any?, customer_account: str?, deleted: bool, id: str, invoice: str?, invoice_item: str?, object: str, promotion_code: any?, source: map{coupon: any?, type: str}, start: int(unix-time), subscription: str?, subscription_item: str?} # Successful response.

@endpoint GET /v1/customers/{customer}/discount
@required {customer: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {checkout_session: str?, customer: any?, customer_account: str?, end: int(unix-time)?, id: str, invoice: str?, invoice_item: str?, object: str, promotion_code: any?, source: map{coupon: any?, type: str}, start: int(unix-time), subscription: str?, subscription_item: str?} # Successful response.

@endpoint POST /v1/customers/{customer}/funding_instructions
@desc Create or retrieve funding instructions for a customer cash balance
@required {customer: str}
@returns(200) {bank_transfer: map{country: str, financial_addresses: [map], type: str}, currency: str, funding_type: str, livemode: bool, object: str} # Successful response.

@endpoint GET /v1/customers/{customer}/payment_methods
@desc List a Customer's PaymentMethods
@required {customer: str}
@optional {allow_redisplay: str(always/limited/unspecified) # This field indicates whether this payment method can be shown again to its customer in a checkout flow. Stripe products such as Checkout and Elements use this field to determine whether a payment method can be shown as a saved payment method in a checkout flow., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., type: str(acss_debit/affirm/afterpay_clearpay/alipay/alma/amazon_pay/au_becs_debit/bacs_debit/bancontact/billie/blik/boleto/card/cashapp/crypto/custom/customer_balance/eps/fpx/giropay/grabpay/ideal/kakao_pay/klarna/konbini/kr_card/link/mb_way/mobilepay/multibanco/naver_pay/nz_bank_account/oxxo/p24/pay_by_bank/payco/paynow/paypal/payto/pix/promptpay/revolut_pay/samsung_pay/satispay/sepa_debit/sofort/swish/twint/us_bank_account/wechat_pay/zip) # An optional filter on the list, based on the object `type` field. Without the filter, the list includes all current and future payment method types. If your integration expects only one type of payment method in the response, make sure to provide a type value in the request.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/customers/{customer}/payment_methods/{payment_method}
@desc Retrieve a Customer's PaymentMethod
@required {customer: str, payment_method: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {acss_debit: map{bank_name: str?, fingerprint: str?, institution_number: str?, last4: str?, transit_number: str?}, affirm: map, afterpay_clearpay: map, alipay: map, allow_redisplay: str, alma: map, amazon_pay: map, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bacs_debit: map{fingerprint: str?, last4: str?, sort_code: str?}, bancontact: map, billie: map, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, blik: map, boleto: map{tax_id: str}, card: map{brand: str, checks: any?, country: str?, display_brand: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str, generated_from: any?, last4: str, networks: any?, regulated_status: str?, three_d_secure_usage: any?, wallet: any?}, card_present: map{brand: str?, brand_product: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, offline: any?, preferred_locales: [str]?, read_method: str?, wallet: map{type: str}}, cashapp: map{buyer_id: str?, cashtag: str?}, created: int(unix-time), crypto: map, custom: map{display_name: str?, logo: any?, type: str}, customer: any?, customer_account: str?, customer_balance: map, eps: map{bank: str?}, fpx: map{bank: str}, giropay: map, grabpay: map, id: str, ideal: map{bank: str?, bic: str?}, interac_present: map{brand: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, preferred_locales: [str]?, read_method: str?}, kakao_pay: map, klarna: map{dob: any?}, konbini: map, kr_card: map{brand: str?, last4: str?}, link: map{email: str?}, livemode: bool, mb_way: map, metadata: map?, mobilepay: map, multibanco: map, naver_pay: map{buyer_id: str?, funding: str}, nz_bank_account: map{account_holder_name: str?, bank_code: str, bank_name: str, branch_code: str, last4: str, suffix: str?}, object: str, oxxo: map, p24: map{bank: str?}, pay_by_bank: map, payco: map, paynow: map, paypal: map{country: str?, payer_email: str?, payer_id: str?}, payto: map{bsb_number: str?, last4: str?, pay_id: str?}, pix: map, promptpay: map, radar_options: map{session: str}, revolut_pay: map, samsung_pay: map, satispay: map, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, generated_from: any?, last4: str?}, sofort: map{country: str?}, swish: map, twint: map, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, financial_connections_account: str?, fingerprint: str?, last4: str?, networks: any?, routing_number: str?, status_details: any?}, wechat_pay: map, zip: map} # Successful response.

@endpoint GET /v1/customers/{customer}/sources
@desc <p>List sources for a specified customer.</p>
@required {customer: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., object: str # Filter sources according to a particular object type., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [any], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/customers/{customer}/sources
@desc Create a card
@required {customer: str}
@returns(200) Successful response.

@endpoint DELETE /v1/customers/{customer}/sources/{id}
@desc Delete a customer source
@required {customer: str, id: str}
@returns(200) Successful response.

@endpoint GET /v1/customers/{customer}/sources/{id}
@desc <p>Retrieve a specified source for a given customer.</p>
@required {customer: str, id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) Successful response.

@endpoint POST /v1/customers/{customer}/sources/{id}
@desc <p>Update a specified source for a given customer.</p>
@required {customer: str, id: str}
@returns(200) Successful response.

@endpoint POST /v1/customers/{customer}/sources/{id}/verify
@desc Verify a bank account
@required {customer: str, id: str}
@returns(200) {account: any?, account_holder_name: str?, account_holder_type: str?, account_type: str?, available_payout_methods: [str]?, bank_name: str?, country: str, currency: str(currency), customer: any?, default_for_currency: bool?, fingerprint: str?, future_requirements: any?, id: str, last4: str, metadata: map?, object: str, requirements: any?, routing_number: str?, status: str} # Successful response.

@endpoint GET /v1/customers/{customer}/subscriptions
@desc List active subscriptions
@required {customer: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/customers/{customer}/subscriptions
@desc Create a subscription
@required {customer: str}
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endpoint DELETE /v1/customers/{customer}/subscriptions/{subscription_exposed_id}
@desc Cancel a subscription
@required {customer: str, subscription_exposed_id: str}
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endpoint GET /v1/customers/{customer}/subscriptions/{subscription_exposed_id}
@desc Retrieve a subscription
@required {customer: str, subscription_exposed_id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endpoint POST /v1/customers/{customer}/subscriptions/{subscription_exposed_id}
@desc Update a subscription on a customer
@required {customer: str, subscription_exposed_id: str}
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endpoint DELETE /v1/customers/{customer}/subscriptions/{subscription_exposed_id}/discount
@desc Delete a customer discount
@required {customer: str, subscription_exposed_id: str}
@returns(200) {checkout_session: str?, customer: any?, customer_account: str?, deleted: bool, id: str, invoice: str?, invoice_item: str?, object: str, promotion_code: any?, source: map{coupon: any?, type: str}, start: int(unix-time), subscription: str?, subscription_item: str?} # Successful response.

@endpoint GET /v1/customers/{customer}/subscriptions/{subscription_exposed_id}/discount
@required {customer: str, subscription_exposed_id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {checkout_session: str?, customer: any?, customer_account: str?, end: int(unix-time)?, id: str, invoice: str?, invoice_item: str?, object: str, promotion_code: any?, source: map{coupon: any?, type: str}, start: int(unix-time), subscription: str?, subscription_item: str?} # Successful response.

@endpoint GET /v1/customers/{customer}/tax_ids
@desc List all Customer tax IDs
@required {customer: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/customers/{customer}/tax_ids
@desc Create a Customer tax ID
@required {customer: str}
@returns(200) {country: str?, created: int(unix-time), customer: any?, customer_account: str?, id: str, livemode: bool, object: str, owner: any?, type: str, value: str, verification: any?} # Successful response.

@endpoint DELETE /v1/customers/{customer}/tax_ids/{id}
@desc Delete a Customer tax ID
@required {customer: str, id: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/customers/{customer}/tax_ids/{id}
@desc Retrieve a Customer tax ID
@required {customer: str, id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {country: str?, created: int(unix-time), customer: any?, customer_account: str?, id: str, livemode: bool, object: str, owner: any?, type: str, value: str, verification: any?} # Successful response.

@endgroup

@group disputes
@endpoint GET /v1/disputes
@desc List all disputes
@optional {charge: str # Only return disputes associated to the charge specified by this charge ID., created: any # Only return disputes that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., payment_intent: str # Only return disputes associated to the PaymentIntent specified by this PaymentIntent ID., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/disputes/{dispute}
@desc Retrieve a dispute
@required {dispute: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, balance_transactions: [map], charge: any, created: int(unix-time), currency: str(currency), enhanced_eligibility_types: [str], evidence: map{access_activity_log: str?, billing_address: str?, cancellation_policy: any?, cancellation_policy_disclosure: str?, cancellation_rebuttal: str?, customer_communication: any?, customer_email_address: str?, customer_name: str?, customer_purchase_ip: str?, customer_signature: any?, duplicate_charge_documentation: any?, duplicate_charge_explanation: str?, duplicate_charge_id: str?, enhanced_evidence: map{visa_compelling_evidence_3: map, visa_compliance: map}, product_description: str?, receipt: any?, refund_policy: any?, refund_policy_disclosure: str?, refund_refusal_explanation: str?, service_date: str?, service_documentation: any?, shipping_address: str?, shipping_carrier: str?, shipping_date: str?, shipping_documentation: any?, shipping_tracking_number: str?, uncategorized_file: any?, uncategorized_text: str?}, evidence_details: map{due_by: int(unix-time)?, enhanced_eligibility: map{visa_compelling_evidence_3: map, visa_compliance: map}, has_evidence: bool, past_due: bool, submission_count: int}, id: str, is_charge_refundable: bool, livemode: bool, metadata: map, object: str, payment_intent: any?, payment_method_details: map{amazon_pay: map{dispute_type: str?}, card: map{brand: str, case_type: str, network_reason_code: str?}, klarna: map{chargeback_loss_reason_code: str, reason_code: str?}, paypal: map{case_id: str?, reason_code: str?}, type: str}, reason: str, status: str} # Successful response.

@endpoint POST /v1/disputes/{dispute}
@desc Update a dispute
@required {dispute: str}
@returns(200) {amount: int, balance_transactions: [map], charge: any, created: int(unix-time), currency: str(currency), enhanced_eligibility_types: [str], evidence: map{access_activity_log: str?, billing_address: str?, cancellation_policy: any?, cancellation_policy_disclosure: str?, cancellation_rebuttal: str?, customer_communication: any?, customer_email_address: str?, customer_name: str?, customer_purchase_ip: str?, customer_signature: any?, duplicate_charge_documentation: any?, duplicate_charge_explanation: str?, duplicate_charge_id: str?, enhanced_evidence: map{visa_compelling_evidence_3: map, visa_compliance: map}, product_description: str?, receipt: any?, refund_policy: any?, refund_policy_disclosure: str?, refund_refusal_explanation: str?, service_date: str?, service_documentation: any?, shipping_address: str?, shipping_carrier: str?, shipping_date: str?, shipping_documentation: any?, shipping_tracking_number: str?, uncategorized_file: any?, uncategorized_text: str?}, evidence_details: map{due_by: int(unix-time)?, enhanced_eligibility: map{visa_compelling_evidence_3: map, visa_compliance: map}, has_evidence: bool, past_due: bool, submission_count: int}, id: str, is_charge_refundable: bool, livemode: bool, metadata: map, object: str, payment_intent: any?, payment_method_details: map{amazon_pay: map{dispute_type: str?}, card: map{brand: str, case_type: str, network_reason_code: str?}, klarna: map{chargeback_loss_reason_code: str, reason_code: str?}, paypal: map{case_id: str?, reason_code: str?}, type: str}, reason: str, status: str} # Successful response.

@endpoint POST /v1/disputes/{dispute}/close
@desc Close a dispute
@required {dispute: str}
@returns(200) {amount: int, balance_transactions: [map], charge: any, created: int(unix-time), currency: str(currency), enhanced_eligibility_types: [str], evidence: map{access_activity_log: str?, billing_address: str?, cancellation_policy: any?, cancellation_policy_disclosure: str?, cancellation_rebuttal: str?, customer_communication: any?, customer_email_address: str?, customer_name: str?, customer_purchase_ip: str?, customer_signature: any?, duplicate_charge_documentation: any?, duplicate_charge_explanation: str?, duplicate_charge_id: str?, enhanced_evidence: map{visa_compelling_evidence_3: map, visa_compliance: map}, product_description: str?, receipt: any?, refund_policy: any?, refund_policy_disclosure: str?, refund_refusal_explanation: str?, service_date: str?, service_documentation: any?, shipping_address: str?, shipping_carrier: str?, shipping_date: str?, shipping_documentation: any?, shipping_tracking_number: str?, uncategorized_file: any?, uncategorized_text: str?}, evidence_details: map{due_by: int(unix-time)?, enhanced_eligibility: map{visa_compelling_evidence_3: map, visa_compliance: map}, has_evidence: bool, past_due: bool, submission_count: int}, id: str, is_charge_refundable: bool, livemode: bool, metadata: map, object: str, payment_intent: any?, payment_method_details: map{amazon_pay: map{dispute_type: str?}, card: map{brand: str, case_type: str, network_reason_code: str?}, klarna: map{chargeback_loss_reason_code: str, reason_code: str?}, paypal: map{case_id: str?, reason_code: str?}, type: str}, reason: str, status: str} # Successful response.

@endgroup

@group entitlements
@endpoint GET /v1/entitlements/active_entitlements
@desc List all active entitlements
@required {customer: str # The ID of the customer.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/entitlements/active_entitlements/{id}
@desc Retrieve an active entitlement
@required {id: str # The ID of the entitlement.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {feature: any, id: str, livemode: bool, lookup_key: str, object: str} # Successful response.

@endpoint GET /v1/entitlements/features
@desc List all features
@optional {archived: bool # If set, filter results to only include features with the given archive status., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., lookup_key: str # If set, filter results to only include features with the given lookup_key., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/entitlements/features
@desc Create a feature
@returns(200) {active: bool, id: str, livemode: bool, lookup_key: str, metadata: map, name: str, object: str} # Successful response.

@endpoint GET /v1/entitlements/features/{id}
@desc Retrieve a feature
@required {id: str # The ID of the feature.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active: bool, id: str, livemode: bool, lookup_key: str, metadata: map, name: str, object: str} # Successful response.

@endpoint POST /v1/entitlements/features/{id}
@desc Updates a feature
@required {id: str}
@returns(200) {active: bool, id: str, livemode: bool, lookup_key: str, metadata: map, name: str, object: str} # Successful response.

@endgroup

@group ephemeral_keys
@endpoint POST /v1/ephemeral_keys
@desc Create an ephemeral key
@returns(200) {created: int(unix-time), expires: int(unix-time), id: str, livemode: bool, object: str, secret: str} # Successful response.

@endpoint DELETE /v1/ephemeral_keys/{key}
@desc Immediately invalidate an ephemeral key
@required {key: str}
@returns(200) {created: int(unix-time), expires: int(unix-time), id: str, livemode: bool, object: str, secret: str} # Successful response.

@endgroup

@group events
@endpoint GET /v1/events
@desc List all events
@optional {created: any # Only return events that were created during the given date interval., delivery_success: bool # Filter events by whether all webhooks were successfully delivered. If false, events which are still pending or have failed all delivery attempts to a webhook endpoint will be returned., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., type: str # A string containing a specific event name, or group of events using * as a wildcard. The list will be filtered to include only events with a matching event property., types: [str] # An array of up to 20 strings containing specific event names. The list will be filtered to include only events with a matching event property. You may pass either `type` or `types`, but not both.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/events/{id}
@desc Retrieve an event
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account: str, api_version: str?, context: str, created: int(unix-time), data: map{object: map, previous_attributes: map}, id: str, livemode: bool, object: str, pending_webhooks: int, request: any?, type: str} # Successful response.

@endgroup

@group exchange_rates
@endpoint GET /v1/exchange_rates
@desc List all exchange rates
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with the exchange rate for currency X your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and total number of supported payout currencies, and the default is the max., starting_after: str # A cursor for use in pagination. `starting_after` is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with the exchange rate for currency X, your subsequent call can include `starting_after=X` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/exchange_rates/{rate_id}
@desc Retrieve an exchange rate
@required {rate_id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {id: str, object: str, rates: map} # Successful response.

@endgroup

@group external_accounts
@endpoint POST /v1/external_accounts/{id}
@desc <p>Updates the metadata, account holder name, account holder type of a bank account belonging to
@required {id: str}
@returns(200) Successful response.

@endgroup

@group fabric
@endpoint GET /v1/fabric/service/integration_config
@required {service_name: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {object: str} # Successful response.

@endpoint POST /v1/fabric/service/subscribe
@returns(200) {object: str} # Successful response.

@endgroup

@group file_links
@endpoint GET /v1/file_links
@desc List all file links
@optional {created: any # Only return links that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., expired: bool # Filter links by their expiration status. By default, Stripe returns all links., file: str # Only return links for the given file., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/file_links
@desc Create a file link
@returns(200) {created: int(unix-time), expired: bool, expires_at: int(unix-time)?, file: any, id: str, livemode: bool, metadata: map, object: str, url: str?} # Successful response.

@endpoint GET /v1/file_links/{link}
@desc Retrieve a file link
@required {link: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), expired: bool, expires_at: int(unix-time)?, file: any, id: str, livemode: bool, metadata: map, object: str, url: str?} # Successful response.

@endpoint POST /v1/file_links/{link}
@desc Update a file link
@required {link: str}
@returns(200) {created: int(unix-time), expired: bool, expires_at: int(unix-time)?, file: any, id: str, livemode: bool, metadata: map, object: str, url: str?} # Successful response.

@endgroup

@group files
@endpoint GET /v1/files
@desc List all files
@optional {created: any # Only return files that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., purpose: str(account_requirement/additional_verification/business_icon/business_logo/customer_signature/dispute_evidence/document_provider_identity_document/finance_report_run/financial_account_statement/identity_document/identity_document_downloadable/issuing_regulatory_reporting/pci_document/platform_terms_of_service/selfie/sigma_scheduled_query/tax_document_user_upload/terminal_android_apk/terminal_reader_splashscreen) # Filter queries by the file purpose. If you don't provide a purpose, the queries return unfiltered files., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/files
@desc Create a file
@returns(200) {created: int(unix-time), expires_at: int(unix-time)?, filename: str?, id: str, links: map?{data: [map], has_more: bool, object: str, url: str}, object: str, purpose: str, size: int, title: str?, type: str?, url: str?} # Successful response.

@endpoint GET /v1/files/{file}
@desc Retrieve a file
@required {file: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), expires_at: int(unix-time)?, filename: str?, id: str, links: map?{data: [map], has_more: bool, object: str, url: str}, object: str, purpose: str, size: int, title: str?, type: str?, url: str?} # Successful response.

@endgroup

@group financial_connections
@endpoint GET /v1/financial_connections/accounts
@desc List Accounts
@optional {account_holder: map # If present, only return accounts that belong to the specified account holder. `account_holder[customer]` and `account_holder[account]` are mutually exclusive., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., session: str # If present, only return accounts that were collected as part of the given session., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/financial_connections/accounts/{account}
@desc Retrieve an Account
@required {account: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account_holder: any?, account_numbers: [map]?, balance: any?, balance_refresh: any?, category: str, created: int(unix-time), display_name: str?, id: str, institution_name: str, last4: str?, livemode: bool, object: str, ownership: any?, ownership_refresh: any?, permissions: [str]?, status: str, subcategory: str, subscriptions: [str]?, supported_payment_method_types: [str], transaction_refresh: any?} # Successful response.

@endpoint POST /v1/financial_connections/accounts/{account}/disconnect
@desc Disconnect an Account
@required {account: str}
@returns(200) {account_holder: any?, account_numbers: [map]?, balance: any?, balance_refresh: any?, category: str, created: int(unix-time), display_name: str?, id: str, institution_name: str, last4: str?, livemode: bool, object: str, ownership: any?, ownership_refresh: any?, permissions: [str]?, status: str, subcategory: str, subscriptions: [str]?, supported_payment_method_types: [str], transaction_refresh: any?} # Successful response.

@endpoint GET /v1/financial_connections/accounts/{account}/owners
@desc List Account Owners
@required {account: str, ownership: str # The ID of the ownership object to fetch owners from.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/financial_connections/accounts/{account}/refresh
@desc Refresh Account data
@required {account: str}
@returns(200) {account_holder: any?, account_numbers: [map]?, balance: any?, balance_refresh: any?, category: str, created: int(unix-time), display_name: str?, id: str, institution_name: str, last4: str?, livemode: bool, object: str, ownership: any?, ownership_refresh: any?, permissions: [str]?, status: str, subcategory: str, subscriptions: [str]?, supported_payment_method_types: [str], transaction_refresh: any?} # Successful response.

@endpoint POST /v1/financial_connections/accounts/{account}/subscribe
@desc Subscribe to data refreshes for an Account
@required {account: str}
@returns(200) {account_holder: any?, account_numbers: [map]?, balance: any?, balance_refresh: any?, category: str, created: int(unix-time), display_name: str?, id: str, institution_name: str, last4: str?, livemode: bool, object: str, ownership: any?, ownership_refresh: any?, permissions: [str]?, status: str, subcategory: str, subscriptions: [str]?, supported_payment_method_types: [str], transaction_refresh: any?} # Successful response.

@endpoint POST /v1/financial_connections/accounts/{account}/unsubscribe
@desc Unsubscribe from data refreshes for an Account
@required {account: str}
@returns(200) {account_holder: any?, account_numbers: [map]?, balance: any?, balance_refresh: any?, category: str, created: int(unix-time), display_name: str?, id: str, institution_name: str, last4: str?, livemode: bool, object: str, ownership: any?, ownership_refresh: any?, permissions: [str]?, status: str, subcategory: str, subscriptions: [str]?, supported_payment_method_types: [str], transaction_refresh: any?} # Successful response.

@endpoint POST /v1/financial_connections/sessions
@desc Create a Session
@returns(200) {account_holder: any?, accounts: map{data: [map], has_more: bool, object: str, url: str}, client_secret: str?, filters: map{account_subcategories: [str]?, countries: [str]?}, id: str, livemode: bool, object: str, permissions: [str], prefetch: [str]?, return_url: str} # Successful response.

@endpoint GET /v1/financial_connections/sessions/{session}
@desc Retrieve a Session
@required {session: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account_holder: any?, accounts: map{data: [map], has_more: bool, object: str, url: str}, client_secret: str?, filters: map{account_subcategories: [str]?, countries: [str]?}, id: str, livemode: bool, object: str, permissions: [str], prefetch: [str]?, return_url: str} # Successful response.

@endpoint GET /v1/financial_connections/transactions
@desc List Transactions
@required {account: str # The ID of the Financial Connections Account whose transactions will be retrieved.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., transacted_at: any # A filter on the list based on the object `transacted_at` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with the following options:, transaction_refresh: map # A filter on the list based on the object `transaction_refresh` field. The value can be a dictionary with the following options:}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/financial_connections/transactions/{transaction}
@desc Retrieve a Transaction
@required {transaction: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account: str, amount: int, currency: str, description: str, id: str, livemode: bool, object: str, status: str, status_transitions: map{posted_at: int(unix-time)?, void_at: int(unix-time)?}, transacted_at: int(unix-time), transaction_refresh: str, updated: int(unix-time)} # Successful response.

@endgroup

@group forwarding
@endpoint GET /v1/forwarding/requests
@desc List all ForwardingRequests
@optional {created: map # Similar to other List endpoints, filters results based on created timestamp. You can pass gt, gte, lt, and lte timestamp values., ending_before: str # A pagination cursor to fetch the previous page of the list. The value must be a ForwardingRequest ID., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A pagination cursor to fetch the next page of the list. The value must be a ForwardingRequest ID.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/forwarding/requests
@desc Create a ForwardingRequest
@returns(200) {created: int(unix-time), id: str, livemode: bool, metadata: map?, object: str, payment_method: str, replacements: [str], request_context: any?, request_details: any?, response_details: any?, url: str?} # Successful response.

@endpoint GET /v1/forwarding/requests/{id}
@desc Retrieve a ForwardingRequest
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), id: str, livemode: bool, metadata: map?, object: str, payment_method: str, replacements: [str], request_context: any?, request_details: any?, response_details: any?, url: str?} # Successful response.

@endgroup

@group identity
@endpoint GET /v1/identity/verification_reports
@desc List VerificationReports
@optional {client_reference_id: str # A string to reference this user. This can be a customer ID, a session ID, or similar, and can be used to reconcile this verification with your internal systems., created: any # Only return VerificationReports that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., type: str(document/id_number) # Only return VerificationReports of this type, verification_session: str # Only return VerificationReports created by this VerificationSession ID. It is allowed to provide a VerificationIntent ID.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/identity/verification_reports/{report}
@desc Retrieve a VerificationReport
@required {report: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {client_reference_id: str?, created: int(unix-time), document: map{address: any?, dob: any?, error: any?, expiration_date: any?, files: [str]?, first_name: str?, issued_date: any?, issuing_country: str?, last_name: str?, number: str?, sex: str?, status: str, type: str?, unparsed_place_of_birth: str?, unparsed_sex: str?}, email: map{email: str?, error: any?, status: str}, id: str, id_number: map{dob: any?, error: any?, first_name: str?, id_number: str?, id_number_type: str?, last_name: str?, status: str}, livemode: bool, object: str, options: map{document: map{allowed_types: [str], require_id_number: bool, require_live_capture: bool, require_matching_selfie: bool}, id_number: map}, phone: map{error: any?, phone: str?, status: str}, selfie: map{document: str?, error: any?, selfie: str?, status: str}, type: str, verification_flow: str, verification_session: str?} # Successful response.

@endpoint GET /v1/identity/verification_sessions
@desc List VerificationSessions
@optional {client_reference_id: str # A string to reference this user. This can be a customer ID, a session ID, or similar, and can be used to reconcile this verification with your internal systems., created: any # Only return VerificationSessions that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., related_customer: str # Customer ID, related_customer_account: str # The ID of the Account representing a customer., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(canceled/processing/requires_input/verified) # Only return VerificationSessions with this status. [Learn more about the lifecycle of sessions](https://docs.stripe.com/identity/how-sessions-work).}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/identity/verification_sessions
@desc Create a VerificationSession
@returns(200) {client_reference_id: str?, client_secret: str?, created: int(unix-time), id: str, last_error: any?, last_verification_report: any?, livemode: bool, metadata: map, object: str, options: any?, provided_details: any?, redaction: any?, related_customer: str?, related_customer_account: str?, related_person: map{account: str, person: str}, status: str, type: str, url: str?, verification_flow: str, verified_outputs: any?} # Successful response.

@endpoint GET /v1/identity/verification_sessions/{session}
@desc Retrieve a VerificationSession
@required {session: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {client_reference_id: str?, client_secret: str?, created: int(unix-time), id: str, last_error: any?, last_verification_report: any?, livemode: bool, metadata: map, object: str, options: any?, provided_details: any?, redaction: any?, related_customer: str?, related_customer_account: str?, related_person: map{account: str, person: str}, status: str, type: str, url: str?, verification_flow: str, verified_outputs: any?} # Successful response.

@endpoint POST /v1/identity/verification_sessions/{session}
@desc Update a VerificationSession
@required {session: str}
@returns(200) {client_reference_id: str?, client_secret: str?, created: int(unix-time), id: str, last_error: any?, last_verification_report: any?, livemode: bool, metadata: map, object: str, options: any?, provided_details: any?, redaction: any?, related_customer: str?, related_customer_account: str?, related_person: map{account: str, person: str}, status: str, type: str, url: str?, verification_flow: str, verified_outputs: any?} # Successful response.

@endpoint POST /v1/identity/verification_sessions/{session}/cancel
@desc Cancel a VerificationSession
@required {session: str}
@returns(200) {client_reference_id: str?, client_secret: str?, created: int(unix-time), id: str, last_error: any?, last_verification_report: any?, livemode: bool, metadata: map, object: str, options: any?, provided_details: any?, redaction: any?, related_customer: str?, related_customer_account: str?, related_person: map{account: str, person: str}, status: str, type: str, url: str?, verification_flow: str, verified_outputs: any?} # Successful response.

@endpoint POST /v1/identity/verification_sessions/{session}/redact
@desc Redact a VerificationSession
@required {session: str}
@returns(200) {client_reference_id: str?, client_secret: str?, created: int(unix-time), id: str, last_error: any?, last_verification_report: any?, livemode: bool, metadata: map, object: str, options: any?, provided_details: any?, redaction: any?, related_customer: str?, related_customer_account: str?, related_person: map{account: str, person: str}, status: str, type: str, url: str?, verification_flow: str, verified_outputs: any?} # Successful response.

@endgroup

@group invoice_payments
@endpoint GET /v1/invoice_payments
@desc List all payments for an invoice
@optional {created: any # Only return invoice payments that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., invoice: str # The identifier of the invoice whose payments to return., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., payment: map # The payment details of the invoice payments to return., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(canceled/open/paid) # The status of the invoice payments to return.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/invoice_payments/{invoice_payment}
@desc Retrieve an InvoicePayment
@required {invoice_payment: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount_paid: int?, amount_requested: int, created: int(unix-time), currency: str, id: str, invoice: any, is_default: bool, livemode: bool, object: str, payment: map{charge: any, payment_intent: any, payment_record: any, type: str}, status: str, status_transitions: map{canceled_at: int(unix-time)?, paid_at: int(unix-time)?}} # Successful response.

@endgroup

@group invoice_rendering_templates
@endpoint GET /v1/invoice_rendering_templates
@desc List all invoice rendering templates
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(active/archived)}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/invoice_rendering_templates/{template}
@desc Retrieve an invoice rendering template
@required {template: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded., version: int}
@returns(200) {created: int(unix-time), id: str, livemode: bool, metadata: map?, nickname: str?, object: str, status: str, version: int} # Successful response.

@endpoint POST /v1/invoice_rendering_templates/{template}/archive
@desc Archive an invoice rendering template
@required {template: str}
@returns(200) {created: int(unix-time), id: str, livemode: bool, metadata: map?, nickname: str?, object: str, status: str, version: int} # Successful response.

@endpoint POST /v1/invoice_rendering_templates/{template}/unarchive
@desc Unarchive an invoice rendering template
@required {template: str}
@returns(200) {created: int(unix-time), id: str, livemode: bool, metadata: map?, nickname: str?, object: str, status: str, version: int} # Successful response.

@endgroup

@group invoiceitems
@endpoint GET /v1/invoiceitems
@desc List all invoice items
@optional {created: any # Only return invoice items that were created during the given date interval., customer: str # The identifier of the customer whose invoice items to return. If none is provided, returns all invoice items., customer_account: str # The identifier of the account representing the customer whose invoice items to return. If none is provided, returns all invoice items., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., invoice: str # Only return invoice items belonging to this invoice. If none is provided, all invoice items will be returned. If specifying an invoice, no customer identifier is needed., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., pending: bool # Set to `true` to only show pending invoice items, which are not yet attached to any invoices. Set to `false` to only show invoice items already attached to invoices. If unspecified, no filter is applied., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/invoiceitems
@desc Create an invoice item
@returns(200) {amount: int, currency: str(currency), customer: any, customer_account: str?, date: int(unix-time), description: str?, discountable: bool, discounts: [any]?, id: str, invoice: any?, livemode: bool, metadata: map?, net_amount: int, object: str, parent: any?, period: map{end: int(unix-time), start: int(unix-time)}, pricing: any?, proration: bool, proration_details: map{discount_amounts: [map]}, quantity: int, tax_rates: [map]?, test_clock: any?} # Successful response.

@endpoint DELETE /v1/invoiceitems/{invoiceitem}
@desc Delete an invoice item
@required {invoiceitem: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/invoiceitems/{invoiceitem}
@desc Retrieve an invoice item
@required {invoiceitem: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, currency: str(currency), customer: any, customer_account: str?, date: int(unix-time), description: str?, discountable: bool, discounts: [any]?, id: str, invoice: any?, livemode: bool, metadata: map?, net_amount: int, object: str, parent: any?, period: map{end: int(unix-time), start: int(unix-time)}, pricing: any?, proration: bool, proration_details: map{discount_amounts: [map]}, quantity: int, tax_rates: [map]?, test_clock: any?} # Successful response.

@endpoint POST /v1/invoiceitems/{invoiceitem}
@desc Update an invoice item
@required {invoiceitem: str}
@returns(200) {amount: int, currency: str(currency), customer: any, customer_account: str?, date: int(unix-time), description: str?, discountable: bool, discounts: [any]?, id: str, invoice: any?, livemode: bool, metadata: map?, net_amount: int, object: str, parent: any?, period: map{end: int(unix-time), start: int(unix-time)}, pricing: any?, proration: bool, proration_details: map{discount_amounts: [map]}, quantity: int, tax_rates: [map]?, test_clock: any?} # Successful response.

@endgroup

@group invoices
@endpoint GET /v1/invoices
@desc List all invoices
@optional {collection_method: str(charge_automatically/send_invoice) # The collection method of the invoice to retrieve. Either `charge_automatically` or `send_invoice`., created: any # Only return invoices that were created during the given date interval., customer: str # Only return invoices for the customer specified by this customer ID., customer_account: str # Only return invoices for the account representing the customer specified by this account ID., due_date: any, ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(draft/open/paid/uncollectible/void) # The status of the invoice, one of `draft`, `open`, `paid`, `uncollectible`, or `void`. [Learn more](https://docs.stripe.com/billing/invoices/workflow#workflow-overview), subscription: str # Only return invoices for the subscription specified by this subscription ID.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/invoices
@desc Create an invoice
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/create_preview
@desc Create a preview invoice
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint GET /v1/invoices/search
@desc Search invoices
@required {query: str # The search query string. See [search query language](https://docs.stripe.com/search#search-query-language) and the list of supported [query fields for invoices](https://docs.stripe.com/search#query-fields-for-invoices).}
@optional {expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., page: str # A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.}
@returns(200) {data: [map], has_more: bool, next_page: str?, object: str, total_count: int, url: str} # Successful response.

@endpoint DELETE /v1/invoices/{invoice}
@desc Delete a draft invoice
@required {invoice: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/invoices/{invoice}
@desc Retrieve an invoice
@required {invoice: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/{invoice}
@desc Update an invoice
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/{invoice}/add_lines
@desc Bulk add invoice line items
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/{invoice}/attach_payment
@desc Attach a payment to an Invoice
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/{invoice}/finalize
@desc Finalize an invoice
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint GET /v1/invoices/{invoice}/lines
@desc Retrieve an invoice's line items
@required {invoice: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/invoices/{invoice}/lines/{line_item_id}
@desc Update an invoice's line item
@required {invoice: str # Invoice ID of line item, line_item_id: str # Invoice line item ID}
@returns(200) {amount: int, currency: str(currency), description: str?, discount_amounts: [map]?, discountable: bool, discounts: [any], id: str, invoice: str?, livemode: bool, metadata: map, object: str, parent: any?, period: map{end: int(unix-time), start: int(unix-time)}, pretax_credit_amounts: [map]?, pricing: any?, quantity: int?, subscription: any?, subtotal: int, taxes: [map]?} # Successful response.

@endpoint POST /v1/invoices/{invoice}/mark_uncollectible
@desc Mark an invoice as uncollectible
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/{invoice}/pay
@desc Pay an invoice
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/{invoice}/remove_lines
@desc Bulk remove invoice line items
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/{invoice}/send
@desc Send an invoice for manual payment
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/{invoice}/update_lines
@desc Bulk update invoice line items
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endpoint POST /v1/invoices/{invoice}/void
@desc Void an invoice
@required {invoice: str}
@returns(200) {account_country: str?, account_name: str?, account_tax_ids: [any]?, amount_due: int, amount_overpaid: int, amount_paid: int, amount_remaining: int, amount_shipping: int, application: any?, attempt_count: int, attempted: bool, auto_advance: bool, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?, provider: str?, status: str?}, automatically_finalizes_at: int(unix-time)?, billing_reason: str?, collection_method: str, confirmation_secret: any?, created: int(unix-time), currency: str(currency), custom_fields: [map]?, customer: any, customer_account: str?, customer_address: any?, customer_email: str?, customer_name: str?, customer_phone: str?, customer_shipping: any?, customer_tax_exempt: str?, customer_tax_ids: [map]?, default_payment_method: any?, default_source: any?, default_tax_rates: [map], description: str?, discounts: [any], due_date: int(unix-time)?, effective_at: int(unix-time)?, ending_balance: int?, footer: str?, from_invoice: any?, hosted_invoice_url: str?, id: str, invoice_pdf: str?, issuer: map{account: any, type: str}, last_finalization_error: any?, latest_revision: any?, lines: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, next_payment_attempt: int(unix-time)?, number: str?, object: str, on_behalf_of: any?, parent: any?, payment_settings: map{default_mandate: str?, payment_method_options: any?, payment_method_types: [str]?}, payments: map{data: [map], has_more: bool, object: str, url: str}, period_end: int(unix-time), period_start: int(unix-time), post_payment_credit_notes_amount: int, pre_payment_credit_notes_amount: int, receipt_number: str?, rendering: any?, shipping_cost: any?, shipping_details: any?, starting_balance: int, statement_descriptor: str?, status: str?, status_transitions: map{finalized_at: int(unix-time)?, marked_uncollectible_at: int(unix-time)?, paid_at: int(unix-time)?, voided_at: int(unix-time)?}, subtotal: int, subtotal_excluding_tax: int?, test_clock: any?, threshold_reason: map{amount_gte: int?, item_reasons: [map]}, total: int, total_discount_amounts: [map]?, total_excluding_tax: int?, total_pretax_credit_amounts: [map]?, total_taxes: [map]?, webhooks_delivered_at: int(unix-time)?} # Successful response.

@endgroup

@group issuing
@endpoint GET /v1/issuing/authorizations
@desc List all authorizations
@optional {card: str # Only return authorizations that belong to the given card., cardholder: str # Only return authorizations that belong to the given cardholder., created: any # Only return authorizations that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(closed/expired/pending/reversed) # Only return authorizations with the given status. One of `pending`, `closed`, or `reversed`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/issuing/authorizations/{authorization}
@desc Retrieve an authorization
@required {authorization: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/issuing/authorizations/{authorization}
@desc Update an authorization
@required {authorization: str}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/issuing/authorizations/{authorization}/approve
@desc Approve an authorization
@required {authorization: str}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/issuing/authorizations/{authorization}/decline
@desc Decline an authorization
@required {authorization: str}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint GET /v1/issuing/cardholders
@desc List all cardholders
@optional {created: any # Only return cardholders that were created during the given date interval., email: str # Only return cardholders that have the given email address., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., phone_number: str # Only return cardholders that have the given phone number., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(active/blocked/inactive) # Only return cardholders that have the given status. One of `active`, `inactive`, or `blocked`., type: str(company/individual) # Only return cardholders that have the given type. One of `individual` or `company`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/issuing/cardholders
@desc Create a cardholder
@returns(200) {billing: map{address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str} # Successful response.

@endpoint GET /v1/issuing/cardholders/{cardholder}
@desc Retrieve a cardholder
@required {cardholder: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {billing: map{address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str} # Successful response.

@endpoint POST /v1/issuing/cardholders/{cardholder}
@desc Update a cardholder
@required {cardholder: str}
@returns(200) {billing: map{address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str} # Successful response.

@endpoint GET /v1/issuing/cards
@desc List all cards
@optional {cardholder: str # Only return cards belonging to the Cardholder with the provided ID., created: any # Only return cards that were issued during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., exp_month: int # Only return cards that have the given expiration month., exp_year: int # Only return cards that have the given expiration year., expand: [str] # Specifies which fields in the response should be expanded., last4: str # Only return cards that have the given last four digits., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., personalization_design: str, starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(active/canceled/inactive) # Only return cards that have the given status. One of `active`, `inactive`, or `canceled`., type: str(physical/virtual) # Only return cards that have the given type. One of `virtual` or `physical`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/issuing/cards
@desc Create a card
@returns(200) {brand: str, cancellation_reason: str?, cardholder: map{billing: map{address: map}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?} # Successful response.

@endpoint GET /v1/issuing/cards/{card}
@desc Retrieve a card
@required {card: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {brand: str, cancellation_reason: str?, cardholder: map{billing: map{address: map}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?} # Successful response.

@endpoint POST /v1/issuing/cards/{card}
@desc Update a card
@required {card: str}
@returns(200) {brand: str, cancellation_reason: str?, cardholder: map{billing: map{address: map}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?} # Successful response.

@endpoint GET /v1/issuing/disputes
@desc List all disputes
@optional {created: any # Only return Issuing disputes that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(expired/lost/submitted/unsubmitted/won) # Select Issuing disputes with the given status., transaction: str # Select the Issuing dispute for the given transaction.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/issuing/disputes
@desc Create a dispute
@returns(200) {amount: int, balance_transactions: [map]?, created: int(unix-time), currency: str(currency), evidence: map{canceled: map{additional_documentation: any?, canceled_at: int(unix-time)?, cancellation_policy_provided: bool?, cancellation_reason: str?, expected_at: int(unix-time)?, explanation: str?, product_description: str?, product_type: str?, return_status: str?, returned_at: int(unix-time)?}, duplicate: map{additional_documentation: any?, card_statement: any?, cash_receipt: any?, check_image: any?, explanation: str?, original_transaction: str?}, fraudulent: map{additional_documentation: any?, explanation: str?}, merchandise_not_as_described: map{additional_documentation: any?, explanation: str?, received_at: int(unix-time)?, return_description: str?, return_status: str?, returned_at: int(unix-time)?}, no_valid_authorization: map{additional_documentation: any?, explanation: str?}, not_received: map{additional_documentation: any?, expected_at: int(unix-time)?, explanation: str?, product_description: str?, product_type: str?}, other: map{additional_documentation: any?, explanation: str?, product_description: str?, product_type: str?}, reason: str, service_not_as_described: map{additional_documentation: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, explanation: str?, received_at: int(unix-time)?}}, id: str, livemode: bool, loss_reason: str, metadata: map, object: str, status: str, transaction: any, treasury: any?} # Successful response.

@endpoint GET /v1/issuing/disputes/{dispute}
@desc Retrieve a dispute
@required {dispute: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, balance_transactions: [map]?, created: int(unix-time), currency: str(currency), evidence: map{canceled: map{additional_documentation: any?, canceled_at: int(unix-time)?, cancellation_policy_provided: bool?, cancellation_reason: str?, expected_at: int(unix-time)?, explanation: str?, product_description: str?, product_type: str?, return_status: str?, returned_at: int(unix-time)?}, duplicate: map{additional_documentation: any?, card_statement: any?, cash_receipt: any?, check_image: any?, explanation: str?, original_transaction: str?}, fraudulent: map{additional_documentation: any?, explanation: str?}, merchandise_not_as_described: map{additional_documentation: any?, explanation: str?, received_at: int(unix-time)?, return_description: str?, return_status: str?, returned_at: int(unix-time)?}, no_valid_authorization: map{additional_documentation: any?, explanation: str?}, not_received: map{additional_documentation: any?, expected_at: int(unix-time)?, explanation: str?, product_description: str?, product_type: str?}, other: map{additional_documentation: any?, explanation: str?, product_description: str?, product_type: str?}, reason: str, service_not_as_described: map{additional_documentation: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, explanation: str?, received_at: int(unix-time)?}}, id: str, livemode: bool, loss_reason: str, metadata: map, object: str, status: str, transaction: any, treasury: any?} # Successful response.

@endpoint POST /v1/issuing/disputes/{dispute}
@desc Update a dispute
@required {dispute: str}
@returns(200) {amount: int, balance_transactions: [map]?, created: int(unix-time), currency: str(currency), evidence: map{canceled: map{additional_documentation: any?, canceled_at: int(unix-time)?, cancellation_policy_provided: bool?, cancellation_reason: str?, expected_at: int(unix-time)?, explanation: str?, product_description: str?, product_type: str?, return_status: str?, returned_at: int(unix-time)?}, duplicate: map{additional_documentation: any?, card_statement: any?, cash_receipt: any?, check_image: any?, explanation: str?, original_transaction: str?}, fraudulent: map{additional_documentation: any?, explanation: str?}, merchandise_not_as_described: map{additional_documentation: any?, explanation: str?, received_at: int(unix-time)?, return_description: str?, return_status: str?, returned_at: int(unix-time)?}, no_valid_authorization: map{additional_documentation: any?, explanation: str?}, not_received: map{additional_documentation: any?, expected_at: int(unix-time)?, explanation: str?, product_description: str?, product_type: str?}, other: map{additional_documentation: any?, explanation: str?, product_description: str?, product_type: str?}, reason: str, service_not_as_described: map{additional_documentation: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, explanation: str?, received_at: int(unix-time)?}}, id: str, livemode: bool, loss_reason: str, metadata: map, object: str, status: str, transaction: any, treasury: any?} # Successful response.

@endpoint POST /v1/issuing/disputes/{dispute}/submit
@desc Submit a dispute
@required {dispute: str}
@returns(200) {amount: int, balance_transactions: [map]?, created: int(unix-time), currency: str(currency), evidence: map{canceled: map{additional_documentation: any?, canceled_at: int(unix-time)?, cancellation_policy_provided: bool?, cancellation_reason: str?, expected_at: int(unix-time)?, explanation: str?, product_description: str?, product_type: str?, return_status: str?, returned_at: int(unix-time)?}, duplicate: map{additional_documentation: any?, card_statement: any?, cash_receipt: any?, check_image: any?, explanation: str?, original_transaction: str?}, fraudulent: map{additional_documentation: any?, explanation: str?}, merchandise_not_as_described: map{additional_documentation: any?, explanation: str?, received_at: int(unix-time)?, return_description: str?, return_status: str?, returned_at: int(unix-time)?}, no_valid_authorization: map{additional_documentation: any?, explanation: str?}, not_received: map{additional_documentation: any?, expected_at: int(unix-time)?, explanation: str?, product_description: str?, product_type: str?}, other: map{additional_documentation: any?, explanation: str?, product_description: str?, product_type: str?}, reason: str, service_not_as_described: map{additional_documentation: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, explanation: str?, received_at: int(unix-time)?}}, id: str, livemode: bool, loss_reason: str, metadata: map, object: str, status: str, transaction: any, treasury: any?} # Successful response.

@endpoint GET /v1/issuing/personalization_designs
@desc List all personalization designs
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., lookup_keys: [str] # Only return personalization designs with the given lookup keys., preferences: map # Only return personalization designs with the given preferences., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(active/inactive/rejected/review) # Only return personalization designs with the given status.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/issuing/personalization_designs
@desc Create a personalization design
@returns(200) {card_logo: any?, carrier_text: any?, created: int(unix-time), id: str, livemode: bool, lookup_key: str?, metadata: map, name: str?, object: str, physical_bundle: any, preferences: map{is_default: bool, is_platform_default: bool?}, rejection_reasons: map{card_logo: [str]?, carrier_text: [str]?}, status: str} # Successful response.

@endpoint GET /v1/issuing/personalization_designs/{personalization_design}
@desc Retrieve a personalization design
@required {personalization_design: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {card_logo: any?, carrier_text: any?, created: int(unix-time), id: str, livemode: bool, lookup_key: str?, metadata: map, name: str?, object: str, physical_bundle: any, preferences: map{is_default: bool, is_platform_default: bool?}, rejection_reasons: map{card_logo: [str]?, carrier_text: [str]?}, status: str} # Successful response.

@endpoint POST /v1/issuing/personalization_designs/{personalization_design}
@desc Update a personalization design
@required {personalization_design: str}
@returns(200) {card_logo: any?, carrier_text: any?, created: int(unix-time), id: str, livemode: bool, lookup_key: str?, metadata: map, name: str?, object: str, physical_bundle: any, preferences: map{is_default: bool, is_platform_default: bool?}, rejection_reasons: map{card_logo: [str]?, carrier_text: [str]?}, status: str} # Successful response.

@endpoint GET /v1/issuing/physical_bundles
@desc List all physical bundles
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(active/inactive/review) # Only return physical bundles with the given status., type: str(custom/standard) # Only return physical bundles with the given type.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/issuing/physical_bundles/{physical_bundle}
@desc Retrieve a physical bundle
@required {physical_bundle: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {features: map{card_logo: str, carrier_text: str, second_line: str}, id: str, livemode: bool, name: str, object: str, status: str, type: str} # Successful response.

@endpoint GET /v1/issuing/settlements/{settlement}
@desc Retrieve a settlement
@required {settlement: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {bin: str, clearing_date: int(unix-time), created: int(unix-time), currency: str(currency), id: str, interchange_fees_amount: int, livemode: bool, metadata: map, net_total_amount: int, network: str, network_fees_amount: int, network_settlement_identifier: str, object: str, settlement_service: str, status: str, transaction_amount: int, transaction_count: int} # Successful response.

@endpoint POST /v1/issuing/settlements/{settlement}
@desc Update a settlement
@required {settlement: str}
@returns(200) {bin: str, clearing_date: int(unix-time), created: int(unix-time), currency: str(currency), id: str, interchange_fees_amount: int, livemode: bool, metadata: map, net_total_amount: int, network: str, network_fees_amount: int, network_settlement_identifier: str, object: str, settlement_service: str, status: str, transaction_amount: int, transaction_count: int} # Successful response.

@endpoint GET /v1/issuing/tokens
@desc List all issuing tokens for card
@required {card: str # The Issuing card identifier to list tokens for.}
@optional {created: any # Only return Issuing tokens that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(active/deleted/requested/suspended) # Select Issuing tokens with the given status.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/issuing/tokens/{token}
@desc Retrieve an issuing token
@required {token: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {card: any, created: int(unix-time), device_fingerprint: str?, id: str, last4: str, livemode: bool, network: str, network_data: map{device: map{device_fingerprint: str, ip_address: str, location: str, name: str, phone_number: str, type: str}, mastercard: map{card_reference_id: str, token_reference_id: str, token_requestor_id: str, token_requestor_name: str}, type: str, visa: map{card_reference_id: str, token_reference_id: str, token_requestor_id: str, token_risk_score: str}, wallet_provider: map{account_id: str, account_trust_score: int, card_number_source: str, cardholder_address: map, cardholder_name: str, device_trust_score: int, hashed_account_email_address: str, reason_codes: [str], suggested_decision: str, suggested_decision_version: str}}, network_updated_at: int(unix-time), object: str, status: str, wallet_provider: str} # Successful response.

@endpoint POST /v1/issuing/tokens/{token}
@desc Update a token status
@required {token: str}
@returns(200) {card: any, created: int(unix-time), device_fingerprint: str?, id: str, last4: str, livemode: bool, network: str, network_data: map{device: map{device_fingerprint: str, ip_address: str, location: str, name: str, phone_number: str, type: str}, mastercard: map{card_reference_id: str, token_reference_id: str, token_requestor_id: str, token_requestor_name: str}, type: str, visa: map{card_reference_id: str, token_reference_id: str, token_requestor_id: str, token_risk_score: str}, wallet_provider: map{account_id: str, account_trust_score: int, card_number_source: str, cardholder_address: map, cardholder_name: str, device_trust_score: int, hashed_account_email_address: str, reason_codes: [str], suggested_decision: str, suggested_decision_version: str}}, network_updated_at: int(unix-time), object: str, status: str, wallet_provider: str} # Successful response.

@endpoint GET /v1/issuing/transactions
@desc List all transactions
@optional {card: str # Only return transactions that belong to the given card., cardholder: str # Only return transactions that belong to the given cardholder., created: any # Only return transactions that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., type: str(capture/refund) # Only return transactions that have the given type. One of `capture` or `refund`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/issuing/transactions/{transaction}
@desc Retrieve a transaction
@required {transaction: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, amount_details: any?, authorization: any?, balance_transaction: any?, card: any, cardholder: any?, created: int(unix-time), currency: str(currency), dispute: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, purchase_details: any?, token: any?, treasury: any?, type: str, wallet: str?} # Successful response.

@endpoint POST /v1/issuing/transactions/{transaction}
@desc Update a transaction
@required {transaction: str}
@returns(200) {amount: int, amount_details: any?, authorization: any?, balance_transaction: any?, card: any, cardholder: any?, created: int(unix-time), currency: str(currency), dispute: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, purchase_details: any?, token: any?, treasury: any?, type: str, wallet: str?} # Successful response.

@endgroup

@group link_account_sessions
@endpoint POST /v1/link_account_sessions
@desc Create a Session
@returns(200) {account_holder: any?, accounts: map{data: [map], has_more: bool, object: str, url: str}, client_secret: str?, filters: map{account_subcategories: [str]?, countries: [str]?}, id: str, livemode: bool, object: str, permissions: [str], prefetch: [str]?, return_url: str} # Successful response.

@endpoint GET /v1/link_account_sessions/{session}
@desc Retrieve a Session
@required {session: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account_holder: any?, accounts: map{data: [map], has_more: bool, object: str, url: str}, client_secret: str?, filters: map{account_subcategories: [str]?, countries: [str]?}, id: str, livemode: bool, object: str, permissions: [str], prefetch: [str]?, return_url: str} # Successful response.

@endgroup

@group linked_accounts
@endpoint GET /v1/linked_accounts
@desc List Accounts
@optional {account_holder: map # If present, only return accounts that belong to the specified account holder. `account_holder[customer]` and `account_holder[account]` are mutually exclusive., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., session: str # If present, only return accounts that were collected as part of the given session., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/linked_accounts/{account}
@desc Retrieve an Account
@required {account: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {account_holder: any?, account_numbers: [map]?, balance: any?, balance_refresh: any?, category: str, created: int(unix-time), display_name: str?, id: str, institution_name: str, last4: str?, livemode: bool, object: str, ownership: any?, ownership_refresh: any?, permissions: [str]?, status: str, subcategory: str, subscriptions: [str]?, supported_payment_method_types: [str], transaction_refresh: any?} # Successful response.

@endpoint POST /v1/linked_accounts/{account}/disconnect
@desc Disconnect an Account
@required {account: str}
@returns(200) {account_holder: any?, account_numbers: [map]?, balance: any?, balance_refresh: any?, category: str, created: int(unix-time), display_name: str?, id: str, institution_name: str, last4: str?, livemode: bool, object: str, ownership: any?, ownership_refresh: any?, permissions: [str]?, status: str, subcategory: str, subscriptions: [str]?, supported_payment_method_types: [str], transaction_refresh: any?} # Successful response.

@endpoint GET /v1/linked_accounts/{account}/owners
@desc List Account Owners
@required {account: str, ownership: str # The ID of the ownership object to fetch owners from.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/linked_accounts/{account}/refresh
@desc Refresh Account data
@required {account: str}
@returns(200) {account_holder: any?, account_numbers: [map]?, balance: any?, balance_refresh: any?, category: str, created: int(unix-time), display_name: str?, id: str, institution_name: str, last4: str?, livemode: bool, object: str, ownership: any?, ownership_refresh: any?, permissions: [str]?, status: str, subcategory: str, subscriptions: [str]?, supported_payment_method_types: [str], transaction_refresh: any?} # Successful response.

@endgroup

@group mandates
@endpoint GET /v1/mandates/{mandate}
@desc Retrieve a Mandate
@required {mandate: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {customer_acceptance: map{accepted_at: int(unix-time)?, offline: map, online: map{ip_address: str?, user_agent: str?}, type: str}, id: str, livemode: bool, multi_use: map, object: str, on_behalf_of: str, payment_method: any, payment_method_details: map{acss_debit: map{default_for: [str], interval_description: str?, payment_schedule: str, transaction_type: str}, amazon_pay: map, au_becs_debit: map{url: str}, bacs_debit: map{network_status: str, reference: str, revocation_reason: str?, url: str}, card: map, cashapp: map, kakao_pay: map, klarna: map, kr_card: map, link: map, naver_pay: map, nz_bank_account: map, paypal: map{billing_agreement_id: str?, payer_id: str?}, payto: map{amount: int?, amount_type: str, end_date: str?, payment_schedule: str, payments_per_period: int?, purpose: str?, start_date: str?}, revolut_pay: map, sepa_debit: map{reference: str, url: str}, type: str, us_bank_account: map{collection_method: str}}, single_use: map{amount: int, currency: str(currency)}, status: str, type: str} # Successful response.

@endgroup

@group payment_attempt_records
@endpoint GET /v1/payment_attempt_records
@desc List Payment Attempt Records
@required {payment_record: str # The ID of the Payment Record.}
@optional {expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/payment_attempt_records/{id}
@desc Retrieve a Payment Attempt Record
@required {id: str # The ID of the Payment Attempt Record.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: map{currency: str(currency), value: int}, amount_authorized: map{currency: str(currency), value: int}, amount_canceled: map{currency: str(currency), value: int}, amount_failed: map{currency: str(currency), value: int}, amount_guaranteed: map{currency: str(currency), value: int}, amount_refunded: map{currency: str(currency), value: int}, amount_requested: map{currency: str(currency), value: int}, application: str?, created: int(unix-time), customer_details: any?, customer_presence: str?, description: str?, id: str, livemode: bool, metadata: map, object: str, payment_method_details: any?, payment_record: str?, processor_details: map{custom: map{payment_reference: str?}, type: str}, reported_by: str, shipping_details: any?} # Successful response.

@endgroup

@group payment_intents
@endpoint GET /v1/payment_intents
@desc List all PaymentIntents
@optional {created: any # A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp or a dictionary with a number of different query options., customer: str # Only return PaymentIntents for the customer that this customer ID specifies., customer_account: str # Only return PaymentIntents for the account representing the customer that this ID specifies., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/payment_intents
@desc Create a PaymentIntent
@returns(200) {amount: int, amount_capturable: int, amount_details: any, amount_received: int, application: any?, application_fee_amount: int?, automatic_payment_methods: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, capture_method: str, client_secret: str?, confirmation_method: str, created: int(unix-time), currency: str(currency), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, hooks: map{inputs: map{tax: map}}, id: str, last_payment_error: any?, latest_charge: any?, livemode: bool, metadata: map, next_action: any?, object: str, on_behalf_of: any?, payment_details: map{customer_reference: str?, order_reference: str?}, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], presentment_details: map{presentment_amount: int, presentment_currency: str}, processing: any?, receipt_email: str?, review: any?, setup_future_usage: str?, shipping: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint GET /v1/payment_intents/search
@desc Search PaymentIntents
@required {query: str # The search query string. See [search query language](https://docs.stripe.com/search#search-query-language) and the list of supported [query fields for payment intents](https://docs.stripe.com/search#query-fields-for-payment-intents).}
@optional {expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., page: str # A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.}
@returns(200) {data: [map], has_more: bool, next_page: str?, object: str, total_count: int, url: str} # Successful response.

@endpoint GET /v1/payment_intents/{intent}
@desc Retrieve a PaymentIntent
@required {intent: str}
@optional {client_secret: str # The client secret of the PaymentIntent. We require it if you use a publishable key to retrieve the source., expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, amount_capturable: int, amount_details: any, amount_received: int, application: any?, application_fee_amount: int?, automatic_payment_methods: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, capture_method: str, client_secret: str?, confirmation_method: str, created: int(unix-time), currency: str(currency), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, hooks: map{inputs: map{tax: map}}, id: str, last_payment_error: any?, latest_charge: any?, livemode: bool, metadata: map, next_action: any?, object: str, on_behalf_of: any?, payment_details: map{customer_reference: str?, order_reference: str?}, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], presentment_details: map{presentment_amount: int, presentment_currency: str}, processing: any?, receipt_email: str?, review: any?, setup_future_usage: str?, shipping: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint POST /v1/payment_intents/{intent}
@desc Update a PaymentIntent
@required {intent: str}
@returns(200) {amount: int, amount_capturable: int, amount_details: any, amount_received: int, application: any?, application_fee_amount: int?, automatic_payment_methods: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, capture_method: str, client_secret: str?, confirmation_method: str, created: int(unix-time), currency: str(currency), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, hooks: map{inputs: map{tax: map}}, id: str, last_payment_error: any?, latest_charge: any?, livemode: bool, metadata: map, next_action: any?, object: str, on_behalf_of: any?, payment_details: map{customer_reference: str?, order_reference: str?}, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], presentment_details: map{presentment_amount: int, presentment_currency: str}, processing: any?, receipt_email: str?, review: any?, setup_future_usage: str?, shipping: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint GET /v1/payment_intents/{intent}/amount_details_line_items
@desc List all PaymentIntent LineItems
@required {intent: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/payment_intents/{intent}/apply_customer_balance
@desc Reconcile a customer_balance PaymentIntent
@required {intent: str}
@returns(200) {amount: int, amount_capturable: int, amount_details: any, amount_received: int, application: any?, application_fee_amount: int?, automatic_payment_methods: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, capture_method: str, client_secret: str?, confirmation_method: str, created: int(unix-time), currency: str(currency), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, hooks: map{inputs: map{tax: map}}, id: str, last_payment_error: any?, latest_charge: any?, livemode: bool, metadata: map, next_action: any?, object: str, on_behalf_of: any?, payment_details: map{customer_reference: str?, order_reference: str?}, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], presentment_details: map{presentment_amount: int, presentment_currency: str}, processing: any?, receipt_email: str?, review: any?, setup_future_usage: str?, shipping: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint POST /v1/payment_intents/{intent}/cancel
@desc Cancel a PaymentIntent
@required {intent: str}
@returns(200) {amount: int, amount_capturable: int, amount_details: any, amount_received: int, application: any?, application_fee_amount: int?, automatic_payment_methods: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, capture_method: str, client_secret: str?, confirmation_method: str, created: int(unix-time), currency: str(currency), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, hooks: map{inputs: map{tax: map}}, id: str, last_payment_error: any?, latest_charge: any?, livemode: bool, metadata: map, next_action: any?, object: str, on_behalf_of: any?, payment_details: map{customer_reference: str?, order_reference: str?}, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], presentment_details: map{presentment_amount: int, presentment_currency: str}, processing: any?, receipt_email: str?, review: any?, setup_future_usage: str?, shipping: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint POST /v1/payment_intents/{intent}/capture
@desc Capture a PaymentIntent
@required {intent: str}
@returns(200) {amount: int, amount_capturable: int, amount_details: any, amount_received: int, application: any?, application_fee_amount: int?, automatic_payment_methods: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, capture_method: str, client_secret: str?, confirmation_method: str, created: int(unix-time), currency: str(currency), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, hooks: map{inputs: map{tax: map}}, id: str, last_payment_error: any?, latest_charge: any?, livemode: bool, metadata: map, next_action: any?, object: str, on_behalf_of: any?, payment_details: map{customer_reference: str?, order_reference: str?}, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], presentment_details: map{presentment_amount: int, presentment_currency: str}, processing: any?, receipt_email: str?, review: any?, setup_future_usage: str?, shipping: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint POST /v1/payment_intents/{intent}/confirm
@desc Confirm a PaymentIntent
@required {intent: str}
@returns(200) {amount: int, amount_capturable: int, amount_details: any, amount_received: int, application: any?, application_fee_amount: int?, automatic_payment_methods: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, capture_method: str, client_secret: str?, confirmation_method: str, created: int(unix-time), currency: str(currency), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, hooks: map{inputs: map{tax: map}}, id: str, last_payment_error: any?, latest_charge: any?, livemode: bool, metadata: map, next_action: any?, object: str, on_behalf_of: any?, payment_details: map{customer_reference: str?, order_reference: str?}, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], presentment_details: map{presentment_amount: int, presentment_currency: str}, processing: any?, receipt_email: str?, review: any?, setup_future_usage: str?, shipping: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint POST /v1/payment_intents/{intent}/increment_authorization
@desc Increment an authorization
@required {intent: str}
@returns(200) {amount: int, amount_capturable: int, amount_details: any, amount_received: int, application: any?, application_fee_amount: int?, automatic_payment_methods: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, capture_method: str, client_secret: str?, confirmation_method: str, created: int(unix-time), currency: str(currency), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, hooks: map{inputs: map{tax: map}}, id: str, last_payment_error: any?, latest_charge: any?, livemode: bool, metadata: map, next_action: any?, object: str, on_behalf_of: any?, payment_details: map{customer_reference: str?, order_reference: str?}, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], presentment_details: map{presentment_amount: int, presentment_currency: str}, processing: any?, receipt_email: str?, review: any?, setup_future_usage: str?, shipping: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer_data: any?, transfer_group: str?} # Successful response.

@endpoint POST /v1/payment_intents/{intent}/verify_microdeposits
@desc Verify microdeposits on a PaymentIntent
@required {intent: str}
@returns(200) {amount: int, amount_capturable: int, amount_details: any, amount_received: int, application: any?, application_fee_amount: int?, automatic_payment_methods: any?, canceled_at: int(unix-time)?, cancellation_reason: str?, capture_method: str, client_secret: str?, confirmation_method: str, created: int(unix-time), currency: str(currency), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, hooks: map{inputs: map{tax: map}}, id: str, last_payment_error: any?, latest_charge: any?, livemode: bool, metadata: map, next_action: any?, object: str, on_behalf_of: any?, payment_details: map{customer_reference: str?, order_reference: str?}, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], presentment_details: map{presentment_amount: int, presentment_currency: str}, processing: any?, receipt_email: str?, review: any?, setup_future_usage: str?, shipping: any?, statement_descriptor: str?, statement_descriptor_suffix: str?, status: str, transfer_data: any?, transfer_group: str?} # Successful response.

@endgroup

@group payment_links
@endpoint GET /v1/payment_links
@desc List all payment links
@optional {active: bool # Only return payment links that are active or inactive (e.g., pass `false` to list all inactive payment links)., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/payment_links
@desc Create a payment link
@returns(200) {active: bool, after_completion: map{hosted_confirmation: map{custom_message: str?}, redirect: map{url: str}, type: str}, allow_promotion_codes: bool, application: any?, application_fee_amount: int?, application_fee_percent: num?, automatic_tax: map{enabled: bool, liability: any?}, billing_address_collection: str, consent_collection: any?, currency: str(currency), custom_fields: [map], custom_text: map{after_submit: any?, shipping_address: any?, submit: any?, terms_of_service_acceptance: any?}, customer_creation: str, id: str, inactive_message: str?, invoice_creation: any?, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, name_collection: map{business: map{enabled: bool, optional: bool}, individual: map{enabled: bool, optional: bool}}, object: str, on_behalf_of: any?, optional_items: [map]?, payment_intent_data: any?, payment_method_collection: str, payment_method_types: [str]?, phone_number_collection: map{enabled: bool}, restrictions: any?, shipping_address_collection: any?, shipping_options: [map], submit_type: str, subscription_data: any?, tax_id_collection: map{enabled: bool, required: str}, transfer_data: any?, url: str} # Successful response.

@endpoint GET /v1/payment_links/{payment_link}
@desc Retrieve payment link
@required {payment_link: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active: bool, after_completion: map{hosted_confirmation: map{custom_message: str?}, redirect: map{url: str}, type: str}, allow_promotion_codes: bool, application: any?, application_fee_amount: int?, application_fee_percent: num?, automatic_tax: map{enabled: bool, liability: any?}, billing_address_collection: str, consent_collection: any?, currency: str(currency), custom_fields: [map], custom_text: map{after_submit: any?, shipping_address: any?, submit: any?, terms_of_service_acceptance: any?}, customer_creation: str, id: str, inactive_message: str?, invoice_creation: any?, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, name_collection: map{business: map{enabled: bool, optional: bool}, individual: map{enabled: bool, optional: bool}}, object: str, on_behalf_of: any?, optional_items: [map]?, payment_intent_data: any?, payment_method_collection: str, payment_method_types: [str]?, phone_number_collection: map{enabled: bool}, restrictions: any?, shipping_address_collection: any?, shipping_options: [map], submit_type: str, subscription_data: any?, tax_id_collection: map{enabled: bool, required: str}, transfer_data: any?, url: str} # Successful response.

@endpoint POST /v1/payment_links/{payment_link}
@desc Update a payment link
@required {payment_link: str}
@returns(200) {active: bool, after_completion: map{hosted_confirmation: map{custom_message: str?}, redirect: map{url: str}, type: str}, allow_promotion_codes: bool, application: any?, application_fee_amount: int?, application_fee_percent: num?, automatic_tax: map{enabled: bool, liability: any?}, billing_address_collection: str, consent_collection: any?, currency: str(currency), custom_fields: [map], custom_text: map{after_submit: any?, shipping_address: any?, submit: any?, terms_of_service_acceptance: any?}, customer_creation: str, id: str, inactive_message: str?, invoice_creation: any?, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, name_collection: map{business: map{enabled: bool, optional: bool}, individual: map{enabled: bool, optional: bool}}, object: str, on_behalf_of: any?, optional_items: [map]?, payment_intent_data: any?, payment_method_collection: str, payment_method_types: [str]?, phone_number_collection: map{enabled: bool}, restrictions: any?, shipping_address_collection: any?, shipping_options: [map], submit_type: str, subscription_data: any?, tax_id_collection: map{enabled: bool, required: str}, transfer_data: any?, url: str} # Successful response.

@endpoint GET /v1/payment_links/{payment_link}/line_items
@desc Retrieve a payment link's line items
@required {payment_link: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endgroup

@group payment_method_configurations
@endpoint GET /v1/payment_method_configurations
@desc List payment method configurations
@optional {application: any # The Connect application to filter by., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/payment_method_configurations
@desc Create a payment method configuration
@returns(200) {acss_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, active: bool, affirm: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, afterpay_clearpay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, alipay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, alma: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, amazon_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, apple_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, application: str?, au_becs_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, bacs_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, bancontact: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, billie: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, blik: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, boleto: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, card: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, cartes_bancaires: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, cashapp: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, crypto: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, customer_balance: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, eps: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, fpx: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, giropay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, google_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, grabpay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, id: str, ideal: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, is_default: bool, jcb: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, kakao_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, klarna: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, konbini: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, kr_card: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, link: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, livemode: bool, mb_way: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, mobilepay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, multibanco: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, name: str, naver_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, nz_bank_account: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, object: str, oxxo: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, p24: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, parent: str?, pay_by_bank: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, payco: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, paynow: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, paypal: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, payto: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, pix: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, promptpay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, revolut_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, samsung_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, satispay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, sepa_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, sofort: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, swish: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, twint: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, us_bank_account: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, wechat_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, zip: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}} # Successful response.

@endpoint GET /v1/payment_method_configurations/{configuration}
@desc Retrieve payment method configuration
@required {configuration: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {acss_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, active: bool, affirm: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, afterpay_clearpay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, alipay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, alma: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, amazon_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, apple_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, application: str?, au_becs_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, bacs_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, bancontact: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, billie: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, blik: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, boleto: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, card: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, cartes_bancaires: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, cashapp: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, crypto: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, customer_balance: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, eps: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, fpx: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, giropay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, google_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, grabpay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, id: str, ideal: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, is_default: bool, jcb: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, kakao_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, klarna: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, konbini: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, kr_card: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, link: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, livemode: bool, mb_way: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, mobilepay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, multibanco: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, name: str, naver_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, nz_bank_account: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, object: str, oxxo: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, p24: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, parent: str?, pay_by_bank: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, payco: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, paynow: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, paypal: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, payto: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, pix: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, promptpay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, revolut_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, samsung_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, satispay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, sepa_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, sofort: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, swish: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, twint: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, us_bank_account: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, wechat_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, zip: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}} # Successful response.

@endpoint POST /v1/payment_method_configurations/{configuration}
@desc Update payment method configuration
@required {configuration: str}
@returns(200) {acss_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, active: bool, affirm: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, afterpay_clearpay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, alipay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, alma: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, amazon_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, apple_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, application: str?, au_becs_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, bacs_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, bancontact: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, billie: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, blik: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, boleto: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, card: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, cartes_bancaires: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, cashapp: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, crypto: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, customer_balance: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, eps: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, fpx: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, giropay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, google_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, grabpay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, id: str, ideal: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, is_default: bool, jcb: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, kakao_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, klarna: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, konbini: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, kr_card: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, link: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, livemode: bool, mb_way: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, mobilepay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, multibanco: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, name: str, naver_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, nz_bank_account: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, object: str, oxxo: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, p24: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, parent: str?, pay_by_bank: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, payco: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, paynow: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, paypal: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, payto: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, pix: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, promptpay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, revolut_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, samsung_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, satispay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, sepa_debit: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, sofort: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, swish: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, twint: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, us_bank_account: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, wechat_pay: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}, zip: map{available: bool, display_preference: map{overridable: bool?, preference: str, value: str}}} # Successful response.

@endgroup

@group payment_method_domains
@endpoint GET /v1/payment_method_domains
@desc List payment method domains
@optional {domain_name: str # The domain name that this payment method domain object represents., enabled: bool # Whether this payment method domain is enabled. If the domain is not enabled, payment methods will not appear in Elements or Embedded Checkout, ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/payment_method_domains
@desc Create a payment method domain
@returns(200) {amazon_pay: map{status: str, status_details: map{error_message: str}}, apple_pay: map{status: str, status_details: map{error_message: str}}, created: int(unix-time), domain_name: str, enabled: bool, google_pay: map{status: str, status_details: map{error_message: str}}, id: str, klarna: map{status: str, status_details: map{error_message: str}}, link: map{status: str, status_details: map{error_message: str}}, livemode: bool, object: str, paypal: map{status: str, status_details: map{error_message: str}}} # Successful response.

@endpoint GET /v1/payment_method_domains/{payment_method_domain}
@desc Retrieve a payment method domain
@required {payment_method_domain: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amazon_pay: map{status: str, status_details: map{error_message: str}}, apple_pay: map{status: str, status_details: map{error_message: str}}, created: int(unix-time), domain_name: str, enabled: bool, google_pay: map{status: str, status_details: map{error_message: str}}, id: str, klarna: map{status: str, status_details: map{error_message: str}}, link: map{status: str, status_details: map{error_message: str}}, livemode: bool, object: str, paypal: map{status: str, status_details: map{error_message: str}}} # Successful response.

@endpoint POST /v1/payment_method_domains/{payment_method_domain}
@desc Update a payment method domain
@required {payment_method_domain: str}
@returns(200) {amazon_pay: map{status: str, status_details: map{error_message: str}}, apple_pay: map{status: str, status_details: map{error_message: str}}, created: int(unix-time), domain_name: str, enabled: bool, google_pay: map{status: str, status_details: map{error_message: str}}, id: str, klarna: map{status: str, status_details: map{error_message: str}}, link: map{status: str, status_details: map{error_message: str}}, livemode: bool, object: str, paypal: map{status: str, status_details: map{error_message: str}}} # Successful response.

@endpoint POST /v1/payment_method_domains/{payment_method_domain}/validate
@desc Validate an existing payment method domain
@required {payment_method_domain: str}
@returns(200) {amazon_pay: map{status: str, status_details: map{error_message: str}}, apple_pay: map{status: str, status_details: map{error_message: str}}, created: int(unix-time), domain_name: str, enabled: bool, google_pay: map{status: str, status_details: map{error_message: str}}, id: str, klarna: map{status: str, status_details: map{error_message: str}}, link: map{status: str, status_details: map{error_message: str}}, livemode: bool, object: str, paypal: map{status: str, status_details: map{error_message: str}}} # Successful response.

@endgroup

@group payment_methods
@endpoint GET /v1/payment_methods
@desc List PaymentMethods
@optional {allow_redisplay: str(always/limited/unspecified) # This field indicates whether this payment method can be shown again to its customer in a checkout flow. Stripe products such as Checkout and Elements use this field to determine whether a payment method can be shown as a saved payment method in a checkout flow., customer: str # The ID of the customer whose PaymentMethods will be retrieved., customer_account: str # The ID of the Account whose PaymentMethods will be retrieved., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., type: str(acss_debit/affirm/afterpay_clearpay/alipay/alma/amazon_pay/au_becs_debit/bacs_debit/bancontact/billie/blik/boleto/card/cashapp/crypto/custom/customer_balance/eps/fpx/giropay/grabpay/ideal/kakao_pay/klarna/konbini/kr_card/link/mb_way/mobilepay/multibanco/naver_pay/nz_bank_account/oxxo/p24/pay_by_bank/payco/paynow/paypal/payto/pix/promptpay/revolut_pay/samsung_pay/satispay/sepa_debit/sofort/swish/twint/us_bank_account/wechat_pay/zip) # Filters the list by the object `type` field. Unfiltered, the list returns all payment method types except `custom`. If your integration expects only one type of payment method in the response, specify that type value in the request to reduce your payload.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/payment_methods
@desc Shares a PaymentMethod
@returns(200) {acss_debit: map{bank_name: str?, fingerprint: str?, institution_number: str?, last4: str?, transit_number: str?}, affirm: map, afterpay_clearpay: map, alipay: map, allow_redisplay: str, alma: map, amazon_pay: map, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bacs_debit: map{fingerprint: str?, last4: str?, sort_code: str?}, bancontact: map, billie: map, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, blik: map, boleto: map{tax_id: str}, card: map{brand: str, checks: any?, country: str?, display_brand: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str, generated_from: any?, last4: str, networks: any?, regulated_status: str?, three_d_secure_usage: any?, wallet: any?}, card_present: map{brand: str?, brand_product: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, offline: any?, preferred_locales: [str]?, read_method: str?, wallet: map{type: str}}, cashapp: map{buyer_id: str?, cashtag: str?}, created: int(unix-time), crypto: map, custom: map{display_name: str?, logo: any?, type: str}, customer: any?, customer_account: str?, customer_balance: map, eps: map{bank: str?}, fpx: map{bank: str}, giropay: map, grabpay: map, id: str, ideal: map{bank: str?, bic: str?}, interac_present: map{brand: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, preferred_locales: [str]?, read_method: str?}, kakao_pay: map, klarna: map{dob: any?}, konbini: map, kr_card: map{brand: str?, last4: str?}, link: map{email: str?}, livemode: bool, mb_way: map, metadata: map?, mobilepay: map, multibanco: map, naver_pay: map{buyer_id: str?, funding: str}, nz_bank_account: map{account_holder_name: str?, bank_code: str, bank_name: str, branch_code: str, last4: str, suffix: str?}, object: str, oxxo: map, p24: map{bank: str?}, pay_by_bank: map, payco: map, paynow: map, paypal: map{country: str?, payer_email: str?, payer_id: str?}, payto: map{bsb_number: str?, last4: str?, pay_id: str?}, pix: map, promptpay: map, radar_options: map{session: str}, revolut_pay: map, samsung_pay: map, satispay: map, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, generated_from: any?, last4: str?}, sofort: map{country: str?}, swish: map, twint: map, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, financial_connections_account: str?, fingerprint: str?, last4: str?, networks: any?, routing_number: str?, status_details: any?}, wechat_pay: map, zip: map} # Successful response.

@endpoint GET /v1/payment_methods/{payment_method}
@desc Retrieve a PaymentMethod
@required {payment_method: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {acss_debit: map{bank_name: str?, fingerprint: str?, institution_number: str?, last4: str?, transit_number: str?}, affirm: map, afterpay_clearpay: map, alipay: map, allow_redisplay: str, alma: map, amazon_pay: map, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bacs_debit: map{fingerprint: str?, last4: str?, sort_code: str?}, bancontact: map, billie: map, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, blik: map, boleto: map{tax_id: str}, card: map{brand: str, checks: any?, country: str?, display_brand: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str, generated_from: any?, last4: str, networks: any?, regulated_status: str?, three_d_secure_usage: any?, wallet: any?}, card_present: map{brand: str?, brand_product: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, offline: any?, preferred_locales: [str]?, read_method: str?, wallet: map{type: str}}, cashapp: map{buyer_id: str?, cashtag: str?}, created: int(unix-time), crypto: map, custom: map{display_name: str?, logo: any?, type: str}, customer: any?, customer_account: str?, customer_balance: map, eps: map{bank: str?}, fpx: map{bank: str}, giropay: map, grabpay: map, id: str, ideal: map{bank: str?, bic: str?}, interac_present: map{brand: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, preferred_locales: [str]?, read_method: str?}, kakao_pay: map, klarna: map{dob: any?}, konbini: map, kr_card: map{brand: str?, last4: str?}, link: map{email: str?}, livemode: bool, mb_way: map, metadata: map?, mobilepay: map, multibanco: map, naver_pay: map{buyer_id: str?, funding: str}, nz_bank_account: map{account_holder_name: str?, bank_code: str, bank_name: str, branch_code: str, last4: str, suffix: str?}, object: str, oxxo: map, p24: map{bank: str?}, pay_by_bank: map, payco: map, paynow: map, paypal: map{country: str?, payer_email: str?, payer_id: str?}, payto: map{bsb_number: str?, last4: str?, pay_id: str?}, pix: map, promptpay: map, radar_options: map{session: str}, revolut_pay: map, samsung_pay: map, satispay: map, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, generated_from: any?, last4: str?}, sofort: map{country: str?}, swish: map, twint: map, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, financial_connections_account: str?, fingerprint: str?, last4: str?, networks: any?, routing_number: str?, status_details: any?}, wechat_pay: map, zip: map} # Successful response.

@endpoint POST /v1/payment_methods/{payment_method}
@desc Update a PaymentMethod
@required {payment_method: str}
@returns(200) {acss_debit: map{bank_name: str?, fingerprint: str?, institution_number: str?, last4: str?, transit_number: str?}, affirm: map, afterpay_clearpay: map, alipay: map, allow_redisplay: str, alma: map, amazon_pay: map, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bacs_debit: map{fingerprint: str?, last4: str?, sort_code: str?}, bancontact: map, billie: map, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, blik: map, boleto: map{tax_id: str}, card: map{brand: str, checks: any?, country: str?, display_brand: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str, generated_from: any?, last4: str, networks: any?, regulated_status: str?, three_d_secure_usage: any?, wallet: any?}, card_present: map{brand: str?, brand_product: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, offline: any?, preferred_locales: [str]?, read_method: str?, wallet: map{type: str}}, cashapp: map{buyer_id: str?, cashtag: str?}, created: int(unix-time), crypto: map, custom: map{display_name: str?, logo: any?, type: str}, customer: any?, customer_account: str?, customer_balance: map, eps: map{bank: str?}, fpx: map{bank: str}, giropay: map, grabpay: map, id: str, ideal: map{bank: str?, bic: str?}, interac_present: map{brand: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, preferred_locales: [str]?, read_method: str?}, kakao_pay: map, klarna: map{dob: any?}, konbini: map, kr_card: map{brand: str?, last4: str?}, link: map{email: str?}, livemode: bool, mb_way: map, metadata: map?, mobilepay: map, multibanco: map, naver_pay: map{buyer_id: str?, funding: str}, nz_bank_account: map{account_holder_name: str?, bank_code: str, bank_name: str, branch_code: str, last4: str, suffix: str?}, object: str, oxxo: map, p24: map{bank: str?}, pay_by_bank: map, payco: map, paynow: map, paypal: map{country: str?, payer_email: str?, payer_id: str?}, payto: map{bsb_number: str?, last4: str?, pay_id: str?}, pix: map, promptpay: map, radar_options: map{session: str}, revolut_pay: map, samsung_pay: map, satispay: map, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, generated_from: any?, last4: str?}, sofort: map{country: str?}, swish: map, twint: map, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, financial_connections_account: str?, fingerprint: str?, last4: str?, networks: any?, routing_number: str?, status_details: any?}, wechat_pay: map, zip: map} # Successful response.

@endpoint POST /v1/payment_methods/{payment_method}/attach
@desc Attach a PaymentMethod to a Customer
@required {payment_method: str}
@returns(200) {acss_debit: map{bank_name: str?, fingerprint: str?, institution_number: str?, last4: str?, transit_number: str?}, affirm: map, afterpay_clearpay: map, alipay: map, allow_redisplay: str, alma: map, amazon_pay: map, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bacs_debit: map{fingerprint: str?, last4: str?, sort_code: str?}, bancontact: map, billie: map, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, blik: map, boleto: map{tax_id: str}, card: map{brand: str, checks: any?, country: str?, display_brand: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str, generated_from: any?, last4: str, networks: any?, regulated_status: str?, three_d_secure_usage: any?, wallet: any?}, card_present: map{brand: str?, brand_product: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, offline: any?, preferred_locales: [str]?, read_method: str?, wallet: map{type: str}}, cashapp: map{buyer_id: str?, cashtag: str?}, created: int(unix-time), crypto: map, custom: map{display_name: str?, logo: any?, type: str}, customer: any?, customer_account: str?, customer_balance: map, eps: map{bank: str?}, fpx: map{bank: str}, giropay: map, grabpay: map, id: str, ideal: map{bank: str?, bic: str?}, interac_present: map{brand: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, preferred_locales: [str]?, read_method: str?}, kakao_pay: map, klarna: map{dob: any?}, konbini: map, kr_card: map{brand: str?, last4: str?}, link: map{email: str?}, livemode: bool, mb_way: map, metadata: map?, mobilepay: map, multibanco: map, naver_pay: map{buyer_id: str?, funding: str}, nz_bank_account: map{account_holder_name: str?, bank_code: str, bank_name: str, branch_code: str, last4: str, suffix: str?}, object: str, oxxo: map, p24: map{bank: str?}, pay_by_bank: map, payco: map, paynow: map, paypal: map{country: str?, payer_email: str?, payer_id: str?}, payto: map{bsb_number: str?, last4: str?, pay_id: str?}, pix: map, promptpay: map, radar_options: map{session: str}, revolut_pay: map, samsung_pay: map, satispay: map, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, generated_from: any?, last4: str?}, sofort: map{country: str?}, swish: map, twint: map, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, financial_connections_account: str?, fingerprint: str?, last4: str?, networks: any?, routing_number: str?, status_details: any?}, wechat_pay: map, zip: map} # Successful response.

@endpoint POST /v1/payment_methods/{payment_method}/detach
@desc Detach a PaymentMethod from a Customer
@required {payment_method: str}
@returns(200) {acss_debit: map{bank_name: str?, fingerprint: str?, institution_number: str?, last4: str?, transit_number: str?}, affirm: map, afterpay_clearpay: map, alipay: map, allow_redisplay: str, alma: map, amazon_pay: map, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bacs_debit: map{fingerprint: str?, last4: str?, sort_code: str?}, bancontact: map, billie: map, billing_details: map{address: any?, email: str?, name: str?, phone: str?, tax_id: str?}, blik: map, boleto: map{tax_id: str}, card: map{brand: str, checks: any?, country: str?, display_brand: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str, generated_from: any?, last4: str, networks: any?, regulated_status: str?, three_d_secure_usage: any?, wallet: any?}, card_present: map{brand: str?, brand_product: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, offline: any?, preferred_locales: [str]?, read_method: str?, wallet: map{type: str}}, cashapp: map{buyer_id: str?, cashtag: str?}, created: int(unix-time), crypto: map, custom: map{display_name: str?, logo: any?, type: str}, customer: any?, customer_account: str?, customer_balance: map, eps: map{bank: str?}, fpx: map{bank: str}, giropay: map, grabpay: map, id: str, ideal: map{bank: str?, bic: str?}, interac_present: map{brand: str?, cardholder_name: str?, country: str?, description: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str?, issuer: str?, last4: str?, networks: any?, preferred_locales: [str]?, read_method: str?}, kakao_pay: map, klarna: map{dob: any?}, konbini: map, kr_card: map{brand: str?, last4: str?}, link: map{email: str?}, livemode: bool, mb_way: map, metadata: map?, mobilepay: map, multibanco: map, naver_pay: map{buyer_id: str?, funding: str}, nz_bank_account: map{account_holder_name: str?, bank_code: str, bank_name: str, branch_code: str, last4: str, suffix: str?}, object: str, oxxo: map, p24: map{bank: str?}, pay_by_bank: map, payco: map, paynow: map, paypal: map{country: str?, payer_email: str?, payer_id: str?}, payto: map{bsb_number: str?, last4: str?, pay_id: str?}, pix: map, promptpay: map, radar_options: map{session: str}, revolut_pay: map, samsung_pay: map, satispay: map, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, generated_from: any?, last4: str?}, sofort: map{country: str?}, swish: map, twint: map, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, financial_connections_account: str?, fingerprint: str?, last4: str?, networks: any?, routing_number: str?, status_details: any?}, wechat_pay: map, zip: map} # Successful response.

@endgroup

@group payment_records
@endpoint POST /v1/payment_records/report_payment
@desc Report a payment
@returns(200) {amount: map{currency: str(currency), value: int}, amount_authorized: map{currency: str(currency), value: int}, amount_canceled: map{currency: str(currency), value: int}, amount_failed: map{currency: str(currency), value: int}, amount_guaranteed: map{currency: str(currency), value: int}, amount_refunded: map{currency: str(currency), value: int}, amount_requested: map{currency: str(currency), value: int}, application: str?, created: int(unix-time), customer_details: any?, customer_presence: str?, description: str?, id: str, latest_payment_attempt_record: str?, livemode: bool, metadata: map, object: str, payment_method_details: any?, processor_details: map{custom: map{payment_reference: str?}, type: str}, reported_by: str, shipping_details: any?} # Successful response.

@endpoint GET /v1/payment_records/{id}
@desc Retrieve a Payment Record
@required {id: str # The ID of the Payment Record.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: map{currency: str(currency), value: int}, amount_authorized: map{currency: str(currency), value: int}, amount_canceled: map{currency: str(currency), value: int}, amount_failed: map{currency: str(currency), value: int}, amount_guaranteed: map{currency: str(currency), value: int}, amount_refunded: map{currency: str(currency), value: int}, amount_requested: map{currency: str(currency), value: int}, application: str?, created: int(unix-time), customer_details: any?, customer_presence: str?, description: str?, id: str, latest_payment_attempt_record: str?, livemode: bool, metadata: map, object: str, payment_method_details: any?, processor_details: map{custom: map{payment_reference: str?}, type: str}, reported_by: str, shipping_details: any?} # Successful response.

@endpoint POST /v1/payment_records/{id}/report_payment_attempt
@desc Report a payment attempt
@required {id: str # The ID of the Payment Record.}
@returns(200) {amount: map{currency: str(currency), value: int}, amount_authorized: map{currency: str(currency), value: int}, amount_canceled: map{currency: str(currency), value: int}, amount_failed: map{currency: str(currency), value: int}, amount_guaranteed: map{currency: str(currency), value: int}, amount_refunded: map{currency: str(currency), value: int}, amount_requested: map{currency: str(currency), value: int}, application: str?, created: int(unix-time), customer_details: any?, customer_presence: str?, description: str?, id: str, latest_payment_attempt_record: str?, livemode: bool, metadata: map, object: str, payment_method_details: any?, processor_details: map{custom: map{payment_reference: str?}, type: str}, reported_by: str, shipping_details: any?} # Successful response.

@endpoint POST /v1/payment_records/{id}/report_payment_attempt_canceled
@desc Report payment attempt canceled
@required {id: str # The ID of the Payment Record.}
@returns(200) {amount: map{currency: str(currency), value: int}, amount_authorized: map{currency: str(currency), value: int}, amount_canceled: map{currency: str(currency), value: int}, amount_failed: map{currency: str(currency), value: int}, amount_guaranteed: map{currency: str(currency), value: int}, amount_refunded: map{currency: str(currency), value: int}, amount_requested: map{currency: str(currency), value: int}, application: str?, created: int(unix-time), customer_details: any?, customer_presence: str?, description: str?, id: str, latest_payment_attempt_record: str?, livemode: bool, metadata: map, object: str, payment_method_details: any?, processor_details: map{custom: map{payment_reference: str?}, type: str}, reported_by: str, shipping_details: any?} # Successful response.

@endpoint POST /v1/payment_records/{id}/report_payment_attempt_failed
@desc Report payment attempt failed
@required {id: str # The ID of the Payment Record.}
@returns(200) {amount: map{currency: str(currency), value: int}, amount_authorized: map{currency: str(currency), value: int}, amount_canceled: map{currency: str(currency), value: int}, amount_failed: map{currency: str(currency), value: int}, amount_guaranteed: map{currency: str(currency), value: int}, amount_refunded: map{currency: str(currency), value: int}, amount_requested: map{currency: str(currency), value: int}, application: str?, created: int(unix-time), customer_details: any?, customer_presence: str?, description: str?, id: str, latest_payment_attempt_record: str?, livemode: bool, metadata: map, object: str, payment_method_details: any?, processor_details: map{custom: map{payment_reference: str?}, type: str}, reported_by: str, shipping_details: any?} # Successful response.

@endpoint POST /v1/payment_records/{id}/report_payment_attempt_guaranteed
@desc Report payment attempt guaranteed
@required {id: str # The ID of the Payment Record.}
@returns(200) {amount: map{currency: str(currency), value: int}, amount_authorized: map{currency: str(currency), value: int}, amount_canceled: map{currency: str(currency), value: int}, amount_failed: map{currency: str(currency), value: int}, amount_guaranteed: map{currency: str(currency), value: int}, amount_refunded: map{currency: str(currency), value: int}, amount_requested: map{currency: str(currency), value: int}, application: str?, created: int(unix-time), customer_details: any?, customer_presence: str?, description: str?, id: str, latest_payment_attempt_record: str?, livemode: bool, metadata: map, object: str, payment_method_details: any?, processor_details: map{custom: map{payment_reference: str?}, type: str}, reported_by: str, shipping_details: any?} # Successful response.

@endpoint POST /v1/payment_records/{id}/report_payment_attempt_informational
@desc Report payment attempt informational
@required {id: str # The ID of the Payment Record.}
@returns(200) {amount: map{currency: str(currency), value: int}, amount_authorized: map{currency: str(currency), value: int}, amount_canceled: map{currency: str(currency), value: int}, amount_failed: map{currency: str(currency), value: int}, amount_guaranteed: map{currency: str(currency), value: int}, amount_refunded: map{currency: str(currency), value: int}, amount_requested: map{currency: str(currency), value: int}, application: str?, created: int(unix-time), customer_details: any?, customer_presence: str?, description: str?, id: str, latest_payment_attempt_record: str?, livemode: bool, metadata: map, object: str, payment_method_details: any?, processor_details: map{custom: map{payment_reference: str?}, type: str}, reported_by: str, shipping_details: any?} # Successful response.

@endpoint POST /v1/payment_records/{id}/report_refund
@desc Report a refund
@required {id: str # The ID of the Payment Record.}
@returns(200) {amount: map{currency: str(currency), value: int}, amount_authorized: map{currency: str(currency), value: int}, amount_canceled: map{currency: str(currency), value: int}, amount_failed: map{currency: str(currency), value: int}, amount_guaranteed: map{currency: str(currency), value: int}, amount_refunded: map{currency: str(currency), value: int}, amount_requested: map{currency: str(currency), value: int}, application: str?, created: int(unix-time), customer_details: any?, customer_presence: str?, description: str?, id: str, latest_payment_attempt_record: str?, livemode: bool, metadata: map, object: str, payment_method_details: any?, processor_details: map{custom: map{payment_reference: str?}, type: str}, reported_by: str, shipping_details: any?} # Successful response.

@endgroup

@group payouts
@endpoint GET /v1/payouts
@desc List all payouts
@optional {arrival_date: any # Only return payouts that are expected to arrive during the given date interval., created: any # Only return payouts that were created during the given date interval., destination: str # The ID of an external account - only return payouts sent to this external account., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str # Only return payouts that have the given status: `pending`, `paid`, `failed`, or `canceled`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/payouts
@desc Create a payout
@returns(200) {amount: int, application_fee: any?, application_fee_amount: int?, arrival_date: int(unix-time), automatic: bool, balance_transaction: any?, created: int(unix-time), currency: str(currency), description: str?, destination: any?, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, id: str, livemode: bool, metadata: map?, method: str, object: str, original_payout: any?, payout_method: str?, reconciliation_status: str, reversed_by: any?, source_type: str, statement_descriptor: str?, status: str, trace_id: any?, type: str} # Successful response.

@endpoint GET /v1/payouts/{payout}
@desc Retrieve a payout
@required {payout: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, application_fee: any?, application_fee_amount: int?, arrival_date: int(unix-time), automatic: bool, balance_transaction: any?, created: int(unix-time), currency: str(currency), description: str?, destination: any?, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, id: str, livemode: bool, metadata: map?, method: str, object: str, original_payout: any?, payout_method: str?, reconciliation_status: str, reversed_by: any?, source_type: str, statement_descriptor: str?, status: str, trace_id: any?, type: str} # Successful response.

@endpoint POST /v1/payouts/{payout}
@desc Update a payout
@required {payout: str}
@returns(200) {amount: int, application_fee: any?, application_fee_amount: int?, arrival_date: int(unix-time), automatic: bool, balance_transaction: any?, created: int(unix-time), currency: str(currency), description: str?, destination: any?, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, id: str, livemode: bool, metadata: map?, method: str, object: str, original_payout: any?, payout_method: str?, reconciliation_status: str, reversed_by: any?, source_type: str, statement_descriptor: str?, status: str, trace_id: any?, type: str} # Successful response.

@endpoint POST /v1/payouts/{payout}/cancel
@desc Cancel a payout
@required {payout: str}
@returns(200) {amount: int, application_fee: any?, application_fee_amount: int?, arrival_date: int(unix-time), automatic: bool, balance_transaction: any?, created: int(unix-time), currency: str(currency), description: str?, destination: any?, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, id: str, livemode: bool, metadata: map?, method: str, object: str, original_payout: any?, payout_method: str?, reconciliation_status: str, reversed_by: any?, source_type: str, statement_descriptor: str?, status: str, trace_id: any?, type: str} # Successful response.

@endpoint POST /v1/payouts/{payout}/reverse
@desc Reverse a payout
@required {payout: str}
@returns(200) {amount: int, application_fee: any?, application_fee_amount: int?, arrival_date: int(unix-time), automatic: bool, balance_transaction: any?, created: int(unix-time), currency: str(currency), description: str?, destination: any?, failure_balance_transaction: any?, failure_code: str?, failure_message: str?, id: str, livemode: bool, metadata: map?, method: str, object: str, original_payout: any?, payout_method: str?, reconciliation_status: str, reversed_by: any?, source_type: str, statement_descriptor: str?, status: str, trace_id: any?, type: str} # Successful response.

@endgroup

@group plans
@endpoint GET /v1/plans
@desc List all plans
@optional {active: bool # Only return plans that are active or inactive (e.g., pass `false` to list all inactive plans)., created: any # A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., product: str # Only return plans for the given product., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/plans
@desc Create a plan
@returns(200) {active: bool, amount: int?, amount_decimal: str(decimal)?, billing_scheme: str, created: int(unix-time), currency: str(currency), id: str, interval: str, interval_count: int, livemode: bool, metadata: map?, meter: str?, nickname: str?, object: str, product: any?, tiers: [map], tiers_mode: str?, transform_usage: any?, trial_period_days: int?, usage_type: str} # Successful response.

@endpoint DELETE /v1/plans/{plan}
@desc Delete a plan
@required {plan: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/plans/{plan}
@desc Retrieve a plan
@required {plan: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active: bool, amount: int?, amount_decimal: str(decimal)?, billing_scheme: str, created: int(unix-time), currency: str(currency), id: str, interval: str, interval_count: int, livemode: bool, metadata: map?, meter: str?, nickname: str?, object: str, product: any?, tiers: [map], tiers_mode: str?, transform_usage: any?, trial_period_days: int?, usage_type: str} # Successful response.

@endpoint POST /v1/plans/{plan}
@desc Update a plan
@required {plan: str}
@returns(200) {active: bool, amount: int?, amount_decimal: str(decimal)?, billing_scheme: str, created: int(unix-time), currency: str(currency), id: str, interval: str, interval_count: int, livemode: bool, metadata: map?, meter: str?, nickname: str?, object: str, product: any?, tiers: [map], tiers_mode: str?, transform_usage: any?, trial_period_days: int?, usage_type: str} # Successful response.

@endgroup

@group prices
@endpoint GET /v1/prices
@desc List all prices
@optional {active: bool # Only return prices that are active or inactive (e.g., pass `false` to list all inactive prices)., created: any # A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options., currency: str(currency) # Only return prices for the given currency., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., lookup_keys: [str] # Only return the price with these lookup_keys, if any exist. You can specify up to 10 lookup_keys., product: str # Only return prices for the given product., recurring: map # Only return prices with these recurring fields., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., type: str(one_time/recurring) # Only return prices of type `recurring` or `one_time`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/prices
@desc Create a price
@returns(200) {active: bool, billing_scheme: str, created: int(unix-time), currency: str(currency), currency_options: map, custom_unit_amount: any?, id: str, livemode: bool, lookup_key: str?, metadata: map, nickname: str?, object: str, product: any, recurring: any?, tax_behavior: str?, tiers: [map], tiers_mode: str?, transform_quantity: any?, type: str, unit_amount: int?, unit_amount_decimal: str(decimal)?} # Successful response.

@endpoint GET /v1/prices/search
@desc Search prices
@required {query: str # The search query string. See [search query language](https://docs.stripe.com/search#search-query-language) and the list of supported [query fields for prices](https://docs.stripe.com/search#query-fields-for-prices).}
@optional {expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., page: str # A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.}
@returns(200) {data: [map], has_more: bool, next_page: str?, object: str, total_count: int, url: str} # Successful response.

@endpoint GET /v1/prices/{price}
@desc Retrieve a price
@required {price: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active: bool, billing_scheme: str, created: int(unix-time), currency: str(currency), currency_options: map, custom_unit_amount: any?, id: str, livemode: bool, lookup_key: str?, metadata: map, nickname: str?, object: str, product: any, recurring: any?, tax_behavior: str?, tiers: [map], tiers_mode: str?, transform_quantity: any?, type: str, unit_amount: int?, unit_amount_decimal: str(decimal)?} # Successful response.

@endpoint POST /v1/prices/{price}
@desc Update a price
@required {price: str}
@returns(200) {active: bool, billing_scheme: str, created: int(unix-time), currency: str(currency), currency_options: map, custom_unit_amount: any?, id: str, livemode: bool, lookup_key: str?, metadata: map, nickname: str?, object: str, product: any, recurring: any?, tax_behavior: str?, tiers: [map], tiers_mode: str?, transform_quantity: any?, type: str, unit_amount: int?, unit_amount_decimal: str(decimal)?} # Successful response.

@endgroup

@group products
@endpoint GET /v1/products
@desc List all products
@optional {active: bool # Only return products that are active or inactive (e.g., pass `false` to list all inactive products)., created: any # Only return products that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., ids: [str] # Only return products with the given IDs. Cannot be used with [starting_after](https://api.stripe.com#list_products-starting_after) or [ending_before](https://api.stripe.com#list_products-ending_before)., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., shippable: bool # Only return products that can be shipped (i.e., physical, not digital products)., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., url: str # Only return products with the given url.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/products
@desc Create a product
@returns(200) {active: bool, created: int(unix-time), default_price: any?, description: str?, id: str, images: [str], livemode: bool, marketing_features: [map], metadata: map, name: str, object: str, package_dimensions: any?, shippable: bool?, statement_descriptor: str?, tax_code: any?, unit_label: str?, updated: int(unix-time), url: str?} # Successful response.

@endpoint GET /v1/products/search
@desc Search products
@required {query: str # The search query string. See [search query language](https://docs.stripe.com/search#search-query-language) and the list of supported [query fields for products](https://docs.stripe.com/search#query-fields-for-products).}
@optional {expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., page: str # A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.}
@returns(200) {data: [map], has_more: bool, next_page: str?, object: str, total_count: int, url: str} # Successful response.

@endpoint DELETE /v1/products/{id}
@desc Delete a product
@required {id: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/products/{id}
@desc Retrieve a product
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active: bool, created: int(unix-time), default_price: any?, description: str?, id: str, images: [str], livemode: bool, marketing_features: [map], metadata: map, name: str, object: str, package_dimensions: any?, shippable: bool?, statement_descriptor: str?, tax_code: any?, unit_label: str?, updated: int(unix-time), url: str?} # Successful response.

@endpoint POST /v1/products/{id}
@desc Update a product
@required {id: str}
@returns(200) {active: bool, created: int(unix-time), default_price: any?, description: str?, id: str, images: [str], livemode: bool, marketing_features: [map], metadata: map, name: str, object: str, package_dimensions: any?, shippable: bool?, statement_descriptor: str?, tax_code: any?, unit_label: str?, updated: int(unix-time), url: str?} # Successful response.

@endpoint GET /v1/products/{product}/features
@desc List all features attached to a product
@required {product: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/products/{product}/features
@desc Attach a feature to a product
@required {product: str}
@returns(200) {entitlement_feature: map{active: bool, id: str, livemode: bool, lookup_key: str, metadata: map, name: str, object: str}, id: str, livemode: bool, object: str} # Successful response.

@endpoint DELETE /v1/products/{product}/features/{id}
@desc Remove a feature from a product
@required {id: str, product: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/products/{product}/features/{id}
@desc Retrieve a product_feature
@required {id: str # The ID of the product_feature., product: str # The ID of the product.}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {entitlement_feature: map{active: bool, id: str, livemode: bool, lookup_key: str, metadata: map, name: str, object: str}, id: str, livemode: bool, object: str} # Successful response.

@endgroup

@group promotion_codes
@endpoint GET /v1/promotion_codes
@desc List all promotion codes
@optional {active: bool # Filter promotion codes by whether they are active., code: str # Only return promotion codes that have this case-insensitive code., coupon: str # Only return promotion codes for this coupon., created: any # A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options., customer: str # Only return promotion codes that are restricted to this customer., customer_account: str # Only return promotion codes that are restricted to this account representing the customer., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/promotion_codes
@desc Create a promotion code
@returns(200) {active: bool, code: str, created: int(unix-time), customer: any?, customer_account: str?, expires_at: int(unix-time)?, id: str, livemode: bool, max_redemptions: int?, metadata: map?, object: str, promotion: map{coupon: any?, type: str}, restrictions: map{currency_options: map, first_time_transaction: bool, minimum_amount: int?, minimum_amount_currency: str?}, times_redeemed: int} # Successful response.

@endpoint GET /v1/promotion_codes/{promotion_code}
@desc Retrieve a promotion code
@required {promotion_code: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active: bool, code: str, created: int(unix-time), customer: any?, customer_account: str?, expires_at: int(unix-time)?, id: str, livemode: bool, max_redemptions: int?, metadata: map?, object: str, promotion: map{coupon: any?, type: str}, restrictions: map{currency_options: map, first_time_transaction: bool, minimum_amount: int?, minimum_amount_currency: str?}, times_redeemed: int} # Successful response.

@endpoint POST /v1/promotion_codes/{promotion_code}
@desc Update a promotion code
@required {promotion_code: str}
@returns(200) {active: bool, code: str, created: int(unix-time), customer: any?, customer_account: str?, expires_at: int(unix-time)?, id: str, livemode: bool, max_redemptions: int?, metadata: map?, object: str, promotion: map{coupon: any?, type: str}, restrictions: map{currency_options: map, first_time_transaction: bool, minimum_amount: int?, minimum_amount_currency: str?}, times_redeemed: int} # Successful response.

@endgroup

@group quotes
@endpoint GET /v1/quotes
@desc List all quotes
@optional {customer: str # The ID of the customer whose quotes you're retrieving., customer_account: str # The ID of the account representing the customer whose quotes you're retrieving., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(accepted/canceled/draft/open) # The status of the quote., test_clock: str # Provides a list of quotes that are associated with the specified test clock. The response will not include quotes with test clocks if this and the customer parameter is not set.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/quotes
@desc Create a quote
@returns(200) {amount_subtotal: int, amount_total: int, application: any?, application_fee_amount: int?, application_fee_percent: num?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, collection_method: str, computed: map{recurring: any?, upfront: map{amount_subtotal: int, amount_total: int, line_items: map, total_details: map}}, created: int(unix-time), currency: str?, customer: any?, customer_account: str?, default_tax_rates: [any], description: str?, discounts: [any], expires_at: int(unix-time), footer: str?, from_quote: any?, header: str?, id: str, invoice: any?, invoice_settings: map{days_until_due: int?, issuer: map{account: any, type: str}}, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, number: str?, object: str, on_behalf_of: any?, status: str, status_transitions: map{accepted_at: int(unix-time)?, canceled_at: int(unix-time)?, finalized_at: int(unix-time)?}, subscription: any?, subscription_data: map{billing_mode: map{flexible: map, type: str}, description: str?, effective_date: int(unix-time)?, metadata: map?, trial_period_days: int?}, subscription_schedule: any?, test_clock: any?, total_details: map{amount_discount: int, amount_shipping: int?, amount_tax: int, breakdown: map{discounts: [map], taxes: [map]}}, transfer_data: any?} # Successful response.

@endpoint GET /v1/quotes/{quote}
@desc Retrieve a quote
@required {quote: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount_subtotal: int, amount_total: int, application: any?, application_fee_amount: int?, application_fee_percent: num?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, collection_method: str, computed: map{recurring: any?, upfront: map{amount_subtotal: int, amount_total: int, line_items: map, total_details: map}}, created: int(unix-time), currency: str?, customer: any?, customer_account: str?, default_tax_rates: [any], description: str?, discounts: [any], expires_at: int(unix-time), footer: str?, from_quote: any?, header: str?, id: str, invoice: any?, invoice_settings: map{days_until_due: int?, issuer: map{account: any, type: str}}, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, number: str?, object: str, on_behalf_of: any?, status: str, status_transitions: map{accepted_at: int(unix-time)?, canceled_at: int(unix-time)?, finalized_at: int(unix-time)?}, subscription: any?, subscription_data: map{billing_mode: map{flexible: map, type: str}, description: str?, effective_date: int(unix-time)?, metadata: map?, trial_period_days: int?}, subscription_schedule: any?, test_clock: any?, total_details: map{amount_discount: int, amount_shipping: int?, amount_tax: int, breakdown: map{discounts: [map], taxes: [map]}}, transfer_data: any?} # Successful response.

@endpoint POST /v1/quotes/{quote}
@desc Update a quote
@required {quote: str}
@returns(200) {amount_subtotal: int, amount_total: int, application: any?, application_fee_amount: int?, application_fee_percent: num?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, collection_method: str, computed: map{recurring: any?, upfront: map{amount_subtotal: int, amount_total: int, line_items: map, total_details: map}}, created: int(unix-time), currency: str?, customer: any?, customer_account: str?, default_tax_rates: [any], description: str?, discounts: [any], expires_at: int(unix-time), footer: str?, from_quote: any?, header: str?, id: str, invoice: any?, invoice_settings: map{days_until_due: int?, issuer: map{account: any, type: str}}, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, number: str?, object: str, on_behalf_of: any?, status: str, status_transitions: map{accepted_at: int(unix-time)?, canceled_at: int(unix-time)?, finalized_at: int(unix-time)?}, subscription: any?, subscription_data: map{billing_mode: map{flexible: map, type: str}, description: str?, effective_date: int(unix-time)?, metadata: map?, trial_period_days: int?}, subscription_schedule: any?, test_clock: any?, total_details: map{amount_discount: int, amount_shipping: int?, amount_tax: int, breakdown: map{discounts: [map], taxes: [map]}}, transfer_data: any?} # Successful response.

@endpoint POST /v1/quotes/{quote}/accept
@desc Accept a quote
@required {quote: str}
@returns(200) {amount_subtotal: int, amount_total: int, application: any?, application_fee_amount: int?, application_fee_percent: num?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, collection_method: str, computed: map{recurring: any?, upfront: map{amount_subtotal: int, amount_total: int, line_items: map, total_details: map}}, created: int(unix-time), currency: str?, customer: any?, customer_account: str?, default_tax_rates: [any], description: str?, discounts: [any], expires_at: int(unix-time), footer: str?, from_quote: any?, header: str?, id: str, invoice: any?, invoice_settings: map{days_until_due: int?, issuer: map{account: any, type: str}}, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, number: str?, object: str, on_behalf_of: any?, status: str, status_transitions: map{accepted_at: int(unix-time)?, canceled_at: int(unix-time)?, finalized_at: int(unix-time)?}, subscription: any?, subscription_data: map{billing_mode: map{flexible: map, type: str}, description: str?, effective_date: int(unix-time)?, metadata: map?, trial_period_days: int?}, subscription_schedule: any?, test_clock: any?, total_details: map{amount_discount: int, amount_shipping: int?, amount_tax: int, breakdown: map{discounts: [map], taxes: [map]}}, transfer_data: any?} # Successful response.

@endpoint POST /v1/quotes/{quote}/cancel
@desc Cancel a quote
@required {quote: str}
@returns(200) {amount_subtotal: int, amount_total: int, application: any?, application_fee_amount: int?, application_fee_percent: num?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, collection_method: str, computed: map{recurring: any?, upfront: map{amount_subtotal: int, amount_total: int, line_items: map, total_details: map}}, created: int(unix-time), currency: str?, customer: any?, customer_account: str?, default_tax_rates: [any], description: str?, discounts: [any], expires_at: int(unix-time), footer: str?, from_quote: any?, header: str?, id: str, invoice: any?, invoice_settings: map{days_until_due: int?, issuer: map{account: any, type: str}}, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, number: str?, object: str, on_behalf_of: any?, status: str, status_transitions: map{accepted_at: int(unix-time)?, canceled_at: int(unix-time)?, finalized_at: int(unix-time)?}, subscription: any?, subscription_data: map{billing_mode: map{flexible: map, type: str}, description: str?, effective_date: int(unix-time)?, metadata: map?, trial_period_days: int?}, subscription_schedule: any?, test_clock: any?, total_details: map{amount_discount: int, amount_shipping: int?, amount_tax: int, breakdown: map{discounts: [map], taxes: [map]}}, transfer_data: any?} # Successful response.

@endpoint GET /v1/quotes/{quote}/computed_upfront_line_items
@desc Retrieve a quote's upfront line items
@required {quote: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/quotes/{quote}/finalize
@desc Finalize a quote
@required {quote: str}
@returns(200) {amount_subtotal: int, amount_total: int, application: any?, application_fee_amount: int?, application_fee_percent: num?, automatic_tax: map{enabled: bool, liability: any?, provider: str?, status: str?}, collection_method: str, computed: map{recurring: any?, upfront: map{amount_subtotal: int, amount_total: int, line_items: map, total_details: map}}, created: int(unix-time), currency: str?, customer: any?, customer_account: str?, default_tax_rates: [any], description: str?, discounts: [any], expires_at: int(unix-time), footer: str?, from_quote: any?, header: str?, id: str, invoice: any?, invoice_settings: map{days_until_due: int?, issuer: map{account: any, type: str}}, line_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, number: str?, object: str, on_behalf_of: any?, status: str, status_transitions: map{accepted_at: int(unix-time)?, canceled_at: int(unix-time)?, finalized_at: int(unix-time)?}, subscription: any?, subscription_data: map{billing_mode: map{flexible: map, type: str}, description: str?, effective_date: int(unix-time)?, metadata: map?, trial_period_days: int?}, subscription_schedule: any?, test_clock: any?, total_details: map{amount_discount: int, amount_shipping: int?, amount_tax: int, breakdown: map{discounts: [map], taxes: [map]}}, transfer_data: any?} # Successful response.

@endpoint GET /v1/quotes/{quote}/line_items
@desc Retrieve a quote's line items
@required {quote: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/quotes/{quote}/pdf
@desc Download quote PDF
@required {quote: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) Successful response.

@endgroup

@group radar
@endpoint GET /v1/radar/early_fraud_warnings
@desc List all early fraud warnings
@optional {charge: str # Only return early fraud warnings for the charge specified by this charge ID., created: any # Only return early fraud warnings that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., payment_intent: str # Only return early fraud warnings for charges that were created by the PaymentIntent specified by this PaymentIntent ID., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/radar/early_fraud_warnings/{early_fraud_warning}
@desc Retrieve an early fraud warning
@required {early_fraud_warning: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {actionable: bool, charge: any, created: int(unix-time), fraud_type: str, id: str, livemode: bool, object: str, payment_intent: any} # Successful response.

@endpoint POST /v1/radar/payment_evaluations
@desc Create a Payment Evaluation
@returns(200) {client_device_metadata_details: map{radar_session: str}, created_at: int(unix-time), customer_details: map{customer: str?, customer_account: str?, email: str?, name: str?, phone: str?}, events: [map], id: str, insights: map{card_issuer_decline: any?, evaluated_at: int(unix-time), fraudulent_dispute: map{recommended_action: str, risk_score: int}}, livemode: bool, metadata: map?, object: str, outcome: any?, payment_details: map{amount: int, currency: str(currency), description: str?, money_movement_details: any?, payment_method_details: any?, shipping_details: any?, statement_descriptor: str?}} # Successful response.

@endpoint GET /v1/radar/value_list_items
@desc List all value list items
@required {value_list: str # Identifier for the parent value list this item belongs to.}
@optional {created: any # Only return items that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., value: str # Return items belonging to the parent list whose value matches the specified value (using an "is like" match).}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/radar/value_list_items
@desc Create a value list item
@returns(200) {created: int(unix-time), created_by: str, id: str, livemode: bool, object: str, value: str, value_list: str} # Successful response.

@endpoint DELETE /v1/radar/value_list_items/{item}
@desc Delete a value list item
@required {item: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/radar/value_list_items/{item}
@desc Retrieve a value list item
@required {item: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), created_by: str, id: str, livemode: bool, object: str, value: str, value_list: str} # Successful response.

@endpoint GET /v1/radar/value_lists
@desc List all value lists
@optional {alias: str # The alias used to reference the value list when writing rules., contains: str # A value contained within a value list - returns all value lists containing this value., created: any # Only return value lists that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/radar/value_lists
@desc Create a value list
@returns(200) {alias: str, created: int(unix-time), created_by: str, id: str, item_type: str, list_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, name: str, object: str} # Successful response.

@endpoint DELETE /v1/radar/value_lists/{value_list}
@desc Delete a value list
@required {value_list: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/radar/value_lists/{value_list}
@desc Retrieve a value list
@required {value_list: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {alias: str, created: int(unix-time), created_by: str, id: str, item_type: str, list_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, name: str, object: str} # Successful response.

@endpoint POST /v1/radar/value_lists/{value_list}
@desc Update a value list
@required {value_list: str}
@returns(200) {alias: str, created: int(unix-time), created_by: str, id: str, item_type: str, list_items: map{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map, name: str, object: str} # Successful response.

@endgroup

@group refunds
@endpoint GET /v1/refunds
@desc List all refunds
@optional {charge: str # Only return refunds for the charge specified by this charge ID., created: any # Only return refunds that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., payment_intent: str # Only return refunds for the PaymentIntent specified by this ID., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/refunds
@desc Create customer balance refund
@returns(200) {amount: int, balance_transaction: any?, charge: any?, created: int(unix-time), currency: str(currency), description: str, destination_details: map{affirm: map, afterpay_clearpay: map, alipay: map, alma: map, amazon_pay: map, au_bank_transfer: map, blik: map{network_decline_code: str?, reference: str?, reference_status: str?}, br_bank_transfer: map{reference: str?, reference_status: str?}, card: map{reference: str, reference_status: str, reference_type: str, type: str}, cashapp: map, crypto: map{reference: str?}, customer_cash_balance: map, eps: map, eu_bank_transfer: map{reference: str?, reference_status: str?}, gb_bank_transfer: map{reference: str?, reference_status: str?}, giropay: map, grabpay: map, jp_bank_transfer: map{reference: str?, reference_status: str?}, klarna: map, mb_way: map{reference: str?, reference_status: str?}, multibanco: map{reference: str?, reference_status: str?}, mx_bank_transfer: map{reference: str?, reference_status: str?}, nz_bank_transfer: map, p24: map{reference: str?, reference_status: str?}, paynow: map, paypal: map{network_decline_code: str?}, pix: map, revolut: map, sofort: map, swish: map{network_decline_code: str?, reference: str?, reference_status: str?}, th_bank_transfer: map{reference: str?, reference_status: str?}, twint: map, type: str, us_bank_transfer: map{reference: str?, reference_status: str?}, wechat_pay: map, zip: map}, failure_balance_transaction: any, failure_reason: str, id: str, instructions_email: str, metadata: map?, next_action: map{display_details: map{email_sent: map, expires_at: int(unix-time)}, type: str}, object: str, payment_intent: any?, pending_reason: str, presentment_details: map{presentment_amount: int, presentment_currency: str}, reason: str?, receipt_number: str?, source_transfer_reversal: any?, status: str?, transfer_reversal: any?} # Successful response.

@endpoint GET /v1/refunds/{refund}
@desc Retrieve a refund
@required {refund: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, balance_transaction: any?, charge: any?, created: int(unix-time), currency: str(currency), description: str, destination_details: map{affirm: map, afterpay_clearpay: map, alipay: map, alma: map, amazon_pay: map, au_bank_transfer: map, blik: map{network_decline_code: str?, reference: str?, reference_status: str?}, br_bank_transfer: map{reference: str?, reference_status: str?}, card: map{reference: str, reference_status: str, reference_type: str, type: str}, cashapp: map, crypto: map{reference: str?}, customer_cash_balance: map, eps: map, eu_bank_transfer: map{reference: str?, reference_status: str?}, gb_bank_transfer: map{reference: str?, reference_status: str?}, giropay: map, grabpay: map, jp_bank_transfer: map{reference: str?, reference_status: str?}, klarna: map, mb_way: map{reference: str?, reference_status: str?}, multibanco: map{reference: str?, reference_status: str?}, mx_bank_transfer: map{reference: str?, reference_status: str?}, nz_bank_transfer: map, p24: map{reference: str?, reference_status: str?}, paynow: map, paypal: map{network_decline_code: str?}, pix: map, revolut: map, sofort: map, swish: map{network_decline_code: str?, reference: str?, reference_status: str?}, th_bank_transfer: map{reference: str?, reference_status: str?}, twint: map, type: str, us_bank_transfer: map{reference: str?, reference_status: str?}, wechat_pay: map, zip: map}, failure_balance_transaction: any, failure_reason: str, id: str, instructions_email: str, metadata: map?, next_action: map{display_details: map{email_sent: map, expires_at: int(unix-time)}, type: str}, object: str, payment_intent: any?, pending_reason: str, presentment_details: map{presentment_amount: int, presentment_currency: str}, reason: str?, receipt_number: str?, source_transfer_reversal: any?, status: str?, transfer_reversal: any?} # Successful response.

@endpoint POST /v1/refunds/{refund}
@desc Update a refund
@required {refund: str}
@returns(200) {amount: int, balance_transaction: any?, charge: any?, created: int(unix-time), currency: str(currency), description: str, destination_details: map{affirm: map, afterpay_clearpay: map, alipay: map, alma: map, amazon_pay: map, au_bank_transfer: map, blik: map{network_decline_code: str?, reference: str?, reference_status: str?}, br_bank_transfer: map{reference: str?, reference_status: str?}, card: map{reference: str, reference_status: str, reference_type: str, type: str}, cashapp: map, crypto: map{reference: str?}, customer_cash_balance: map, eps: map, eu_bank_transfer: map{reference: str?, reference_status: str?}, gb_bank_transfer: map{reference: str?, reference_status: str?}, giropay: map, grabpay: map, jp_bank_transfer: map{reference: str?, reference_status: str?}, klarna: map, mb_way: map{reference: str?, reference_status: str?}, multibanco: map{reference: str?, reference_status: str?}, mx_bank_transfer: map{reference: str?, reference_status: str?}, nz_bank_transfer: map, p24: map{reference: str?, reference_status: str?}, paynow: map, paypal: map{network_decline_code: str?}, pix: map, revolut: map, sofort: map, swish: map{network_decline_code: str?, reference: str?, reference_status: str?}, th_bank_transfer: map{reference: str?, reference_status: str?}, twint: map, type: str, us_bank_transfer: map{reference: str?, reference_status: str?}, wechat_pay: map, zip: map}, failure_balance_transaction: any, failure_reason: str, id: str, instructions_email: str, metadata: map?, next_action: map{display_details: map{email_sent: map, expires_at: int(unix-time)}, type: str}, object: str, payment_intent: any?, pending_reason: str, presentment_details: map{presentment_amount: int, presentment_currency: str}, reason: str?, receipt_number: str?, source_transfer_reversal: any?, status: str?, transfer_reversal: any?} # Successful response.

@endpoint POST /v1/refunds/{refund}/cancel
@desc Cancel a refund
@required {refund: str}
@returns(200) {amount: int, balance_transaction: any?, charge: any?, created: int(unix-time), currency: str(currency), description: str, destination_details: map{affirm: map, afterpay_clearpay: map, alipay: map, alma: map, amazon_pay: map, au_bank_transfer: map, blik: map{network_decline_code: str?, reference: str?, reference_status: str?}, br_bank_transfer: map{reference: str?, reference_status: str?}, card: map{reference: str, reference_status: str, reference_type: str, type: str}, cashapp: map, crypto: map{reference: str?}, customer_cash_balance: map, eps: map, eu_bank_transfer: map{reference: str?, reference_status: str?}, gb_bank_transfer: map{reference: str?, reference_status: str?}, giropay: map, grabpay: map, jp_bank_transfer: map{reference: str?, reference_status: str?}, klarna: map, mb_way: map{reference: str?, reference_status: str?}, multibanco: map{reference: str?, reference_status: str?}, mx_bank_transfer: map{reference: str?, reference_status: str?}, nz_bank_transfer: map, p24: map{reference: str?, reference_status: str?}, paynow: map, paypal: map{network_decline_code: str?}, pix: map, revolut: map, sofort: map, swish: map{network_decline_code: str?, reference: str?, reference_status: str?}, th_bank_transfer: map{reference: str?, reference_status: str?}, twint: map, type: str, us_bank_transfer: map{reference: str?, reference_status: str?}, wechat_pay: map, zip: map}, failure_balance_transaction: any, failure_reason: str, id: str, instructions_email: str, metadata: map?, next_action: map{display_details: map{email_sent: map, expires_at: int(unix-time)}, type: str}, object: str, payment_intent: any?, pending_reason: str, presentment_details: map{presentment_amount: int, presentment_currency: str}, reason: str?, receipt_number: str?, source_transfer_reversal: any?, status: str?, transfer_reversal: any?} # Successful response.

@endgroup

@group reporting
@endpoint GET /v1/reporting/report_runs
@desc List all Report Runs
@optional {created: any # Only return Report Runs that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/reporting/report_runs
@desc Create a Report Run
@returns(200) {created: int(unix-time), error: str?, id: str, livemode: bool, object: str, parameters: map{columns: [str], connected_account: str, currency: str(currency), interval_end: int(unix-time), interval_start: int(unix-time), payout: str, reporting_category: str, timezone: str}, report_type: str, result: any?, status: str, succeeded_at: int(unix-time)?} # Successful response.

@endpoint GET /v1/reporting/report_runs/{report_run}
@desc Retrieve a Report Run
@required {report_run: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), error: str?, id: str, livemode: bool, object: str, parameters: map{columns: [str], connected_account: str, currency: str(currency), interval_end: int(unix-time), interval_start: int(unix-time), payout: str, reporting_category: str, timezone: str}, report_type: str, result: any?, status: str, succeeded_at: int(unix-time)?} # Successful response.

@endpoint GET /v1/reporting/report_types
@desc List all Report Types
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/reporting/report_types/{report_type}
@desc Retrieve a Report Type
@required {report_type: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {data_available_end: int(unix-time), data_available_start: int(unix-time), default_columns: [str]?, id: str, livemode: bool, name: str, object: str, updated: int(unix-time), version: int} # Successful response.

@endgroup

@group reviews
@endpoint GET /v1/reviews
@desc List all open reviews
@optional {created: any # Only return reviews that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/reviews/{review}
@desc Retrieve a review
@required {review: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {billing_zip: str?, charge: any?, closed_reason: str?, created: int(unix-time), id: str, ip_address: str?, ip_address_location: any?, livemode: bool, object: str, open: bool, opened_reason: str, payment_intent: any, reason: str, session: any?} # Successful response.

@endpoint POST /v1/reviews/{review}/approve
@desc Approve a review
@required {review: str}
@returns(200) {billing_zip: str?, charge: any?, closed_reason: str?, created: int(unix-time), id: str, ip_address: str?, ip_address_location: any?, livemode: bool, object: str, open: bool, opened_reason: str, payment_intent: any, reason: str, session: any?} # Successful response.

@endgroup

@group setup_attempts
@endpoint GET /v1/setup_attempts
@desc List all SetupAttempts
@required {setup_intent: str # Only return SetupAttempts created by the SetupIntent specified by this ID.}
@optional {created: any # A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp or a dictionary with a number of different query options., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endgroup

@group setup_intents
@endpoint GET /v1/setup_intents
@desc List all SetupIntents
@optional {attach_to_self: bool # If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Accounts own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer., created: any # A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options., customer: str # Only return SetupIntents for the customer specified by this customer ID., customer_account: str # Only return SetupIntents for the account specified by this customer ID., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., payment_method: str # Only return SetupIntents that associate with the specified payment method., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/setup_intents
@desc Create a SetupIntent
@returns(200) {application: any?, attach_to_self: bool, automatic_payment_methods: any?, cancellation_reason: str?, client_secret: str?, created: int(unix-time), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, flow_directions: [str]?, id: str, last_setup_error: any?, latest_attempt: any?, livemode: bool, mandate: any?, metadata: map?, next_action: any?, object: str, on_behalf_of: any?, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], single_use_mandate: any?, status: str, usage: str} # Successful response.

@endpoint GET /v1/setup_intents/{intent}
@desc Retrieve a SetupIntent
@required {intent: str}
@optional {client_secret: str # The client secret of the SetupIntent. We require this string if you use a publishable key to retrieve the SetupIntent., expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {application: any?, attach_to_self: bool, automatic_payment_methods: any?, cancellation_reason: str?, client_secret: str?, created: int(unix-time), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, flow_directions: [str]?, id: str, last_setup_error: any?, latest_attempt: any?, livemode: bool, mandate: any?, metadata: map?, next_action: any?, object: str, on_behalf_of: any?, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], single_use_mandate: any?, status: str, usage: str} # Successful response.

@endpoint POST /v1/setup_intents/{intent}
@desc Update a SetupIntent
@required {intent: str}
@returns(200) {application: any?, attach_to_self: bool, automatic_payment_methods: any?, cancellation_reason: str?, client_secret: str?, created: int(unix-time), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, flow_directions: [str]?, id: str, last_setup_error: any?, latest_attempt: any?, livemode: bool, mandate: any?, metadata: map?, next_action: any?, object: str, on_behalf_of: any?, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], single_use_mandate: any?, status: str, usage: str} # Successful response.

@endpoint POST /v1/setup_intents/{intent}/cancel
@desc Cancel a SetupIntent
@required {intent: str}
@returns(200) {application: any?, attach_to_self: bool, automatic_payment_methods: any?, cancellation_reason: str?, client_secret: str?, created: int(unix-time), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, flow_directions: [str]?, id: str, last_setup_error: any?, latest_attempt: any?, livemode: bool, mandate: any?, metadata: map?, next_action: any?, object: str, on_behalf_of: any?, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], single_use_mandate: any?, status: str, usage: str} # Successful response.

@endpoint POST /v1/setup_intents/{intent}/confirm
@desc Confirm a SetupIntent
@required {intent: str}
@returns(200) {application: any?, attach_to_self: bool, automatic_payment_methods: any?, cancellation_reason: str?, client_secret: str?, created: int(unix-time), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, flow_directions: [str]?, id: str, last_setup_error: any?, latest_attempt: any?, livemode: bool, mandate: any?, metadata: map?, next_action: any?, object: str, on_behalf_of: any?, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], single_use_mandate: any?, status: str, usage: str} # Successful response.

@endpoint POST /v1/setup_intents/{intent}/verify_microdeposits
@desc Verify microdeposits on a SetupIntent
@required {intent: str}
@returns(200) {application: any?, attach_to_self: bool, automatic_payment_methods: any?, cancellation_reason: str?, client_secret: str?, created: int(unix-time), customer: any?, customer_account: str?, description: str?, excluded_payment_method_types: [str]?, flow_directions: [str]?, id: str, last_setup_error: any?, latest_attempt: any?, livemode: bool, mandate: any?, metadata: map?, next_action: any?, object: str, on_behalf_of: any?, payment_method: any?, payment_method_configuration_details: any?, payment_method_options: any?, payment_method_types: [str], single_use_mandate: any?, status: str, usage: str} # Successful response.

@endgroup

@group shipping_rates
@endpoint GET /v1/shipping_rates
@desc List all shipping rates
@optional {active: bool # Only return shipping rates that are active or inactive., created: any # A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options., currency: str(currency) # Only return shipping rates for the given currency., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/shipping_rates
@desc Create a shipping rate
@returns(200) {active: bool, created: int(unix-time), delivery_estimate: any?, display_name: str?, fixed_amount: map{amount: int, currency: str(currency), currency_options: map}, id: str, livemode: bool, metadata: map, object: str, tax_behavior: str?, tax_code: any?, type: str} # Successful response.

@endpoint GET /v1/shipping_rates/{shipping_rate_token}
@desc Retrieve a shipping rate
@required {shipping_rate_token: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active: bool, created: int(unix-time), delivery_estimate: any?, display_name: str?, fixed_amount: map{amount: int, currency: str(currency), currency_options: map}, id: str, livemode: bool, metadata: map, object: str, tax_behavior: str?, tax_code: any?, type: str} # Successful response.

@endpoint POST /v1/shipping_rates/{shipping_rate_token}
@desc Update a shipping rate
@required {shipping_rate_token: str}
@returns(200) {active: bool, created: int(unix-time), delivery_estimate: any?, display_name: str?, fixed_amount: map{amount: int, currency: str(currency), currency_options: map}, id: str, livemode: bool, metadata: map, object: str, tax_behavior: str?, tax_code: any?, type: str} # Successful response.

@endgroup

@group sigma
@endpoint POST /v1/sigma/saved_queries/{id}
@desc Update an existing Sigma Query
@required {id: str # The `id` of the saved query to update. This should be a valid `id` that was previously created.}
@returns(200) {created: int, id: str, livemode: bool, name: str, object: str, sql: str} # Successful response.

@endpoint GET /v1/sigma/scheduled_query_runs
@desc List all scheduled query runs
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/sigma/scheduled_query_runs/{scheduled_query_run}
@desc Retrieve a scheduled query run
@required {scheduled_query_run: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), data_load_time: int(unix-time), error: map{message: str}, file: any?, id: str, livemode: bool, object: str, result_available_until: int(unix-time), sql: str, status: str, title: str} # Successful response.

@endgroup

@group sources
@endpoint POST /v1/sources
@desc Shares a source
@returns(200) {ach_credit_transfer: map{account_number: str?, bank_name: str?, fingerprint: str?, refund_account_holder_name: str?, refund_account_holder_type: str?, refund_routing_number: str?, routing_number: str?, swift_code: str?}, ach_debit: map{bank_name: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?, type: str?}, acss_debit: map{bank_address_city: str?, bank_address_line_1: str?, bank_address_line_2: str?, bank_address_postal_code: str?, bank_name: str?, category: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?}, alipay: map{data_string: str?, native_url: str?, statement_descriptor: str?}, allow_redisplay: str?, amount: int?, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bancontact: map{bank_code: str?, bank_name: str?, bic: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, card: map{address_line1_check: str?, address_zip_check: str?, brand: str?, country: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, card_present: map{application_cryptogram: str, application_preferred_name: str, authorization_code: str?, authorization_response_code: str, brand: str?, country: str?, cvm_type: str, data_type: str?, dedicated_file_name: str, emv_auth_data: str, evidence_customer_signature: str?, evidence_transaction_certificate: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, pos_device_id: str?, pos_entry_mode: str, read_method: str?, reader: str?, terminal_verification_results: str, transaction_status_information: str}, client_secret: str, code_verification: map{attempts_remaining: int, status: str}, created: int(unix-time), currency: str(currency)?, customer: str, eps: map{reference: str?, statement_descriptor: str?}, flow: str, giropay: map{bank_code: str?, bank_name: str?, bic: str?, statement_descriptor: str?}, id: str, ideal: map{bank: str?, bic: str?, iban_last4: str?, statement_descriptor: str?}, klarna: map{background_image_url: str, client_token: str?, first_name: str, last_name: str, locale: str, logo_url: str, page_title: str, pay_later_asset_urls_descriptive: str, pay_later_asset_urls_standard: str, pay_later_name: str, pay_later_redirect_url: str, pay_now_asset_urls_descriptive: str, pay_now_asset_urls_standard: str, pay_now_name: str, pay_now_redirect_url: str, pay_over_time_asset_urls_descriptive: str, pay_over_time_asset_urls_standard: str, pay_over_time_name: str, pay_over_time_redirect_url: str, payment_method_categories: str, purchase_country: str, purchase_type: str, redirect_url: str, shipping_delay: int, shipping_first_name: str, shipping_last_name: str}, livemode: bool, metadata: map?, multibanco: map{entity: str?, reference: str?, refund_account_holder_address_city: str?, refund_account_holder_address_country: str?, refund_account_holder_address_line1: str?, refund_account_holder_address_line2: str?, refund_account_holder_address_postal_code: str?, refund_account_holder_address_state: str?, refund_account_holder_name: str?, refund_iban: str?}, object: str, owner: any?, p24: map{reference: str?}, receiver: map{address: str?, amount_charged: int, amount_received: int, amount_returned: int, refund_attributes_method: str, refund_attributes_status: str}, redirect: map{failure_reason: str?, return_url: str, status: str, url: str}, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, last4: str?, mandate_reference: str?, mandate_url: str?}, sofort: map{bank_code: str?, bank_name: str?, bic: str?, country: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, source_order: map{amount: int, currency: str(currency), email: str, items: [map]?, shipping: map{address: map, carrier: str?, name: str, phone: str?, tracking_number: str?}}, statement_descriptor: str?, status: str, three_d_secure: map{address_line1_check: str?, address_zip_check: str?, authenticated: bool?, brand: str?, card: str?, country: str?, customer: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, type: str, usage: str?, wechat: map{prepay_id: str, qr_code_url: str?, statement_descriptor: str}} # Successful response.

@endpoint GET /v1/sources/{source}
@desc Retrieve a source
@required {source: str}
@optional {client_secret: str # The client secret of the source. Required if a publishable key is used to retrieve the source., expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {ach_credit_transfer: map{account_number: str?, bank_name: str?, fingerprint: str?, refund_account_holder_name: str?, refund_account_holder_type: str?, refund_routing_number: str?, routing_number: str?, swift_code: str?}, ach_debit: map{bank_name: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?, type: str?}, acss_debit: map{bank_address_city: str?, bank_address_line_1: str?, bank_address_line_2: str?, bank_address_postal_code: str?, bank_name: str?, category: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?}, alipay: map{data_string: str?, native_url: str?, statement_descriptor: str?}, allow_redisplay: str?, amount: int?, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bancontact: map{bank_code: str?, bank_name: str?, bic: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, card: map{address_line1_check: str?, address_zip_check: str?, brand: str?, country: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, card_present: map{application_cryptogram: str, application_preferred_name: str, authorization_code: str?, authorization_response_code: str, brand: str?, country: str?, cvm_type: str, data_type: str?, dedicated_file_name: str, emv_auth_data: str, evidence_customer_signature: str?, evidence_transaction_certificate: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, pos_device_id: str?, pos_entry_mode: str, read_method: str?, reader: str?, terminal_verification_results: str, transaction_status_information: str}, client_secret: str, code_verification: map{attempts_remaining: int, status: str}, created: int(unix-time), currency: str(currency)?, customer: str, eps: map{reference: str?, statement_descriptor: str?}, flow: str, giropay: map{bank_code: str?, bank_name: str?, bic: str?, statement_descriptor: str?}, id: str, ideal: map{bank: str?, bic: str?, iban_last4: str?, statement_descriptor: str?}, klarna: map{background_image_url: str, client_token: str?, first_name: str, last_name: str, locale: str, logo_url: str, page_title: str, pay_later_asset_urls_descriptive: str, pay_later_asset_urls_standard: str, pay_later_name: str, pay_later_redirect_url: str, pay_now_asset_urls_descriptive: str, pay_now_asset_urls_standard: str, pay_now_name: str, pay_now_redirect_url: str, pay_over_time_asset_urls_descriptive: str, pay_over_time_asset_urls_standard: str, pay_over_time_name: str, pay_over_time_redirect_url: str, payment_method_categories: str, purchase_country: str, purchase_type: str, redirect_url: str, shipping_delay: int, shipping_first_name: str, shipping_last_name: str}, livemode: bool, metadata: map?, multibanco: map{entity: str?, reference: str?, refund_account_holder_address_city: str?, refund_account_holder_address_country: str?, refund_account_holder_address_line1: str?, refund_account_holder_address_line2: str?, refund_account_holder_address_postal_code: str?, refund_account_holder_address_state: str?, refund_account_holder_name: str?, refund_iban: str?}, object: str, owner: any?, p24: map{reference: str?}, receiver: map{address: str?, amount_charged: int, amount_received: int, amount_returned: int, refund_attributes_method: str, refund_attributes_status: str}, redirect: map{failure_reason: str?, return_url: str, status: str, url: str}, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, last4: str?, mandate_reference: str?, mandate_url: str?}, sofort: map{bank_code: str?, bank_name: str?, bic: str?, country: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, source_order: map{amount: int, currency: str(currency), email: str, items: [map]?, shipping: map{address: map, carrier: str?, name: str, phone: str?, tracking_number: str?}}, statement_descriptor: str?, status: str, three_d_secure: map{address_line1_check: str?, address_zip_check: str?, authenticated: bool?, brand: str?, card: str?, country: str?, customer: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, type: str, usage: str?, wechat: map{prepay_id: str, qr_code_url: str?, statement_descriptor: str}} # Successful response.

@endpoint POST /v1/sources/{source}
@desc Update a source
@required {source: str}
@returns(200) {ach_credit_transfer: map{account_number: str?, bank_name: str?, fingerprint: str?, refund_account_holder_name: str?, refund_account_holder_type: str?, refund_routing_number: str?, routing_number: str?, swift_code: str?}, ach_debit: map{bank_name: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?, type: str?}, acss_debit: map{bank_address_city: str?, bank_address_line_1: str?, bank_address_line_2: str?, bank_address_postal_code: str?, bank_name: str?, category: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?}, alipay: map{data_string: str?, native_url: str?, statement_descriptor: str?}, allow_redisplay: str?, amount: int?, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bancontact: map{bank_code: str?, bank_name: str?, bic: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, card: map{address_line1_check: str?, address_zip_check: str?, brand: str?, country: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, card_present: map{application_cryptogram: str, application_preferred_name: str, authorization_code: str?, authorization_response_code: str, brand: str?, country: str?, cvm_type: str, data_type: str?, dedicated_file_name: str, emv_auth_data: str, evidence_customer_signature: str?, evidence_transaction_certificate: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, pos_device_id: str?, pos_entry_mode: str, read_method: str?, reader: str?, terminal_verification_results: str, transaction_status_information: str}, client_secret: str, code_verification: map{attempts_remaining: int, status: str}, created: int(unix-time), currency: str(currency)?, customer: str, eps: map{reference: str?, statement_descriptor: str?}, flow: str, giropay: map{bank_code: str?, bank_name: str?, bic: str?, statement_descriptor: str?}, id: str, ideal: map{bank: str?, bic: str?, iban_last4: str?, statement_descriptor: str?}, klarna: map{background_image_url: str, client_token: str?, first_name: str, last_name: str, locale: str, logo_url: str, page_title: str, pay_later_asset_urls_descriptive: str, pay_later_asset_urls_standard: str, pay_later_name: str, pay_later_redirect_url: str, pay_now_asset_urls_descriptive: str, pay_now_asset_urls_standard: str, pay_now_name: str, pay_now_redirect_url: str, pay_over_time_asset_urls_descriptive: str, pay_over_time_asset_urls_standard: str, pay_over_time_name: str, pay_over_time_redirect_url: str, payment_method_categories: str, purchase_country: str, purchase_type: str, redirect_url: str, shipping_delay: int, shipping_first_name: str, shipping_last_name: str}, livemode: bool, metadata: map?, multibanco: map{entity: str?, reference: str?, refund_account_holder_address_city: str?, refund_account_holder_address_country: str?, refund_account_holder_address_line1: str?, refund_account_holder_address_line2: str?, refund_account_holder_address_postal_code: str?, refund_account_holder_address_state: str?, refund_account_holder_name: str?, refund_iban: str?}, object: str, owner: any?, p24: map{reference: str?}, receiver: map{address: str?, amount_charged: int, amount_received: int, amount_returned: int, refund_attributes_method: str, refund_attributes_status: str}, redirect: map{failure_reason: str?, return_url: str, status: str, url: str}, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, last4: str?, mandate_reference: str?, mandate_url: str?}, sofort: map{bank_code: str?, bank_name: str?, bic: str?, country: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, source_order: map{amount: int, currency: str(currency), email: str, items: [map]?, shipping: map{address: map, carrier: str?, name: str, phone: str?, tracking_number: str?}}, statement_descriptor: str?, status: str, three_d_secure: map{address_line1_check: str?, address_zip_check: str?, authenticated: bool?, brand: str?, card: str?, country: str?, customer: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, type: str, usage: str?, wechat: map{prepay_id: str, qr_code_url: str?, statement_descriptor: str}} # Successful response.

@endpoint GET /v1/sources/{source}/mandate_notifications/{mandate_notification}
@desc Retrieve a Source MandateNotification
@required {mandate_notification: str, source: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {acss_debit: map{statement_descriptor: str}, amount: int?, bacs_debit: map{last4: str}, created: int(unix-time), id: str, livemode: bool, object: str, reason: str, sepa_debit: map{creditor_identifier: str, last4: str, mandate_reference: str}, source: map{ach_credit_transfer: map{account_number: str?, bank_name: str?, fingerprint: str?, refund_account_holder_name: str?, refund_account_holder_type: str?, refund_routing_number: str?, routing_number: str?, swift_code: str?}, ach_debit: map{bank_name: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?, type: str?}, acss_debit: map{bank_address_city: str?, bank_address_line_1: str?, bank_address_line_2: str?, bank_address_postal_code: str?, bank_name: str?, category: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?}, alipay: map{data_string: str?, native_url: str?, statement_descriptor: str?}, allow_redisplay: str?, amount: int?, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bancontact: map{bank_code: str?, bank_name: str?, bic: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, card: map{address_line1_check: str?, address_zip_check: str?, brand: str?, country: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, card_present: map{application_cryptogram: str, application_preferred_name: str, authorization_code: str?, authorization_response_code: str, brand: str?, country: str?, cvm_type: str, data_type: str?, dedicated_file_name: str, emv_auth_data: str, evidence_customer_signature: str?, evidence_transaction_certificate: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, pos_device_id: str?, pos_entry_mode: str, read_method: str?, reader: str?, terminal_verification_results: str, transaction_status_information: str}, client_secret: str, code_verification: map{attempts_remaining: int, status: str}, created: int(unix-time), currency: str(currency)?, customer: str, eps: map{reference: str?, statement_descriptor: str?}, flow: str, giropay: map{bank_code: str?, bank_name: str?, bic: str?, statement_descriptor: str?}, id: str, ideal: map{bank: str?, bic: str?, iban_last4: str?, statement_descriptor: str?}, klarna: map{background_image_url: str, client_token: str?, first_name: str, last_name: str, locale: str, logo_url: str, page_title: str, pay_later_asset_urls_descriptive: str, pay_later_asset_urls_standard: str, pay_later_name: str, pay_later_redirect_url: str, pay_now_asset_urls_descriptive: str, pay_now_asset_urls_standard: str, pay_now_name: str, pay_now_redirect_url: str, pay_over_time_asset_urls_descriptive: str, pay_over_time_asset_urls_standard: str, pay_over_time_name: str, pay_over_time_redirect_url: str, payment_method_categories: str, purchase_country: str, purchase_type: str, redirect_url: str, shipping_delay: int, shipping_first_name: str, shipping_last_name: str}, livemode: bool, metadata: map?, multibanco: map{entity: str?, reference: str?, refund_account_holder_address_city: str?, refund_account_holder_address_country: str?, refund_account_holder_address_line1: str?, refund_account_holder_address_line2: str?, refund_account_holder_address_postal_code: str?, refund_account_holder_address_state: str?, refund_account_holder_name: str?, refund_iban: str?}, object: str, owner: any?, p24: map{reference: str?}, receiver: map{address: str?, amount_charged: int, amount_received: int, amount_returned: int, refund_attributes_method: str, refund_attributes_status: str}, redirect: map{failure_reason: str?, return_url: str, status: str, url: str}, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, last4: str?, mandate_reference: str?, mandate_url: str?}, sofort: map{bank_code: str?, bank_name: str?, bic: str?, country: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, source_order: map{amount: int, currency: str(currency), email: str, items: [map]?, shipping: map}, statement_descriptor: str?, status: str, three_d_secure: map{address_line1_check: str?, address_zip_check: str?, authenticated: bool?, brand: str?, card: str?, country: str?, customer: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, type: str, usage: str?, wechat: map{prepay_id: str, qr_code_url: str?, statement_descriptor: str}}, status: str, type: str} # Successful response.

@endpoint GET /v1/sources/{source}/source_transactions
@desc <p>List source transactions for a given source.</p>
@required {source: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/sources/{source}/source_transactions/{source_transaction}
@desc Retrieve a source transaction
@required {source: str, source_transaction: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {ach_credit_transfer: map{customer_data: str, fingerprint: str, last4: str, routing_number: str}, amount: int, chf_credit_transfer: map{reference: str, sender_address_country: str, sender_address_line1: str, sender_iban: str, sender_name: str}, created: int(unix-time), currency: str(currency), gbp_credit_transfer: map{fingerprint: str, funding_method: str, last4: str, reference: str, sender_account_number: str, sender_name: str, sender_sort_code: str}, id: str, livemode: bool, object: str, paper_check: map{available_at: str, invoices: str}, sepa_credit_transfer: map{reference: str, sender_iban: str, sender_name: str}, source: str, status: str, type: str} # Successful response.

@endpoint POST /v1/sources/{source}/verify
@desc <p>Verify a given source.</p>
@required {source: str}
@returns(200) {ach_credit_transfer: map{account_number: str?, bank_name: str?, fingerprint: str?, refund_account_holder_name: str?, refund_account_holder_type: str?, refund_routing_number: str?, routing_number: str?, swift_code: str?}, ach_debit: map{bank_name: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?, type: str?}, acss_debit: map{bank_address_city: str?, bank_address_line_1: str?, bank_address_line_2: str?, bank_address_postal_code: str?, bank_name: str?, category: str?, country: str?, fingerprint: str?, last4: str?, routing_number: str?}, alipay: map{data_string: str?, native_url: str?, statement_descriptor: str?}, allow_redisplay: str?, amount: int?, au_becs_debit: map{bsb_number: str?, fingerprint: str?, last4: str?}, bancontact: map{bank_code: str?, bank_name: str?, bic: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, card: map{address_line1_check: str?, address_zip_check: str?, brand: str?, country: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, card_present: map{application_cryptogram: str, application_preferred_name: str, authorization_code: str?, authorization_response_code: str, brand: str?, country: str?, cvm_type: str, data_type: str?, dedicated_file_name: str, emv_auth_data: str, evidence_customer_signature: str?, evidence_transaction_certificate: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, pos_device_id: str?, pos_entry_mode: str, read_method: str?, reader: str?, terminal_verification_results: str, transaction_status_information: str}, client_secret: str, code_verification: map{attempts_remaining: int, status: str}, created: int(unix-time), currency: str(currency)?, customer: str, eps: map{reference: str?, statement_descriptor: str?}, flow: str, giropay: map{bank_code: str?, bank_name: str?, bic: str?, statement_descriptor: str?}, id: str, ideal: map{bank: str?, bic: str?, iban_last4: str?, statement_descriptor: str?}, klarna: map{background_image_url: str, client_token: str?, first_name: str, last_name: str, locale: str, logo_url: str, page_title: str, pay_later_asset_urls_descriptive: str, pay_later_asset_urls_standard: str, pay_later_name: str, pay_later_redirect_url: str, pay_now_asset_urls_descriptive: str, pay_now_asset_urls_standard: str, pay_now_name: str, pay_now_redirect_url: str, pay_over_time_asset_urls_descriptive: str, pay_over_time_asset_urls_standard: str, pay_over_time_name: str, pay_over_time_redirect_url: str, payment_method_categories: str, purchase_country: str, purchase_type: str, redirect_url: str, shipping_delay: int, shipping_first_name: str, shipping_last_name: str}, livemode: bool, metadata: map?, multibanco: map{entity: str?, reference: str?, refund_account_holder_address_city: str?, refund_account_holder_address_country: str?, refund_account_holder_address_line1: str?, refund_account_holder_address_line2: str?, refund_account_holder_address_postal_code: str?, refund_account_holder_address_state: str?, refund_account_holder_name: str?, refund_iban: str?}, object: str, owner: any?, p24: map{reference: str?}, receiver: map{address: str?, amount_charged: int, amount_received: int, amount_returned: int, refund_attributes_method: str, refund_attributes_status: str}, redirect: map{failure_reason: str?, return_url: str, status: str, url: str}, sepa_debit: map{bank_code: str?, branch_code: str?, country: str?, fingerprint: str?, last4: str?, mandate_reference: str?, mandate_url: str?}, sofort: map{bank_code: str?, bank_name: str?, bic: str?, country: str?, iban_last4: str?, preferred_language: str?, statement_descriptor: str?}, source_order: map{amount: int, currency: str(currency), email: str, items: [map]?, shipping: map{address: map, carrier: str?, name: str, phone: str?, tracking_number: str?}}, statement_descriptor: str?, status: str, three_d_secure: map{address_line1_check: str?, address_zip_check: str?, authenticated: bool?, brand: str?, card: str?, country: str?, customer: str?, cvc_check: str?, dynamic_last4: str?, exp_month: int?, exp_year: int?, fingerprint: str, funding: str?, last4: str?, name: str?, three_d_secure: str, tokenization_method: str?}, type: str, usage: str?, wechat: map{prepay_id: str, qr_code_url: str?, statement_descriptor: str}} # Successful response.

@endgroup

@group subscription_items
@endpoint GET /v1/subscription_items
@desc List all subscription items
@required {subscription: str # The ID of the subscription whose items will be retrieved.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/subscription_items
@desc Create a subscription item
@returns(200) {billing_thresholds: any?, created: int, current_period_end: int(unix-time), current_period_start: int(unix-time), discounts: [any], id: str, metadata: map, object: str, price: map{active: bool, billing_scheme: str, created: int(unix-time), currency: str(currency), currency_options: map, custom_unit_amount: any?, id: str, livemode: bool, lookup_key: str?, metadata: map, nickname: str?, object: str, product: any, recurring: any?, tax_behavior: str?, tiers: [map], tiers_mode: str?, transform_quantity: any?, type: str, unit_amount: int?, unit_amount_decimal: str(decimal)?}, quantity: int, subscription: str, tax_rates: [map]?} # Successful response.

@endpoint DELETE /v1/subscription_items/{item}
@desc Delete a subscription item
@required {item: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/subscription_items/{item}
@desc Retrieve a subscription item
@required {item: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {billing_thresholds: any?, created: int, current_period_end: int(unix-time), current_period_start: int(unix-time), discounts: [any], id: str, metadata: map, object: str, price: map{active: bool, billing_scheme: str, created: int(unix-time), currency: str(currency), currency_options: map, custom_unit_amount: any?, id: str, livemode: bool, lookup_key: str?, metadata: map, nickname: str?, object: str, product: any, recurring: any?, tax_behavior: str?, tiers: [map], tiers_mode: str?, transform_quantity: any?, type: str, unit_amount: int?, unit_amount_decimal: str(decimal)?}, quantity: int, subscription: str, tax_rates: [map]?} # Successful response.

@endpoint POST /v1/subscription_items/{item}
@desc Update a subscription item
@required {item: str}
@returns(200) {billing_thresholds: any?, created: int, current_period_end: int(unix-time), current_period_start: int(unix-time), discounts: [any], id: str, metadata: map, object: str, price: map{active: bool, billing_scheme: str, created: int(unix-time), currency: str(currency), currency_options: map, custom_unit_amount: any?, id: str, livemode: bool, lookup_key: str?, metadata: map, nickname: str?, object: str, product: any, recurring: any?, tax_behavior: str?, tiers: [map], tiers_mode: str?, transform_quantity: any?, type: str, unit_amount: int?, unit_amount_decimal: str(decimal)?}, quantity: int, subscription: str, tax_rates: [map]?} # Successful response.

@endgroup

@group subscription_schedules
@endpoint GET /v1/subscription_schedules
@desc List all schedules
@optional {canceled_at: any # Only return subscription schedules that were created canceled the given date interval., completed_at: any # Only return subscription schedules that completed during the given date interval., created: any # Only return subscription schedules that were created during the given date interval., customer: str # Only return subscription schedules for the given customer., customer_account: str # Only return subscription schedules for the given account., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., released_at: any # Only return subscription schedules that were released during the given date interval., scheduled: bool # Only return subscription schedules that have not started yet., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/subscription_schedules
@desc Create a schedule
@returns(200) {application: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, canceled_at: int(unix-time)?, completed_at: int(unix-time)?, created: int(unix-time), current_phase: any?, customer: any, customer_account: str?, default_settings: map{application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: str, billing_thresholds: any?, collection_method: str?, default_payment_method: any?, description: str?, invoice_settings: map{account_tax_ids: [any]?, days_until_due: int?, issuer: map}, on_behalf_of: any?, transfer_data: any?}, end_behavior: str, id: str, livemode: bool, metadata: map?, object: str, phases: [map], released_at: int(unix-time)?, released_subscription: str?, status: str, subscription: any?, test_clock: any?} # Successful response.

@endpoint GET /v1/subscription_schedules/{schedule}
@desc Retrieve a schedule
@required {schedule: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {application: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, canceled_at: int(unix-time)?, completed_at: int(unix-time)?, created: int(unix-time), current_phase: any?, customer: any, customer_account: str?, default_settings: map{application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: str, billing_thresholds: any?, collection_method: str?, default_payment_method: any?, description: str?, invoice_settings: map{account_tax_ids: [any]?, days_until_due: int?, issuer: map}, on_behalf_of: any?, transfer_data: any?}, end_behavior: str, id: str, livemode: bool, metadata: map?, object: str, phases: [map], released_at: int(unix-time)?, released_subscription: str?, status: str, subscription: any?, test_clock: any?} # Successful response.

@endpoint POST /v1/subscription_schedules/{schedule}
@desc Update a schedule
@required {schedule: str}
@returns(200) {application: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, canceled_at: int(unix-time)?, completed_at: int(unix-time)?, created: int(unix-time), current_phase: any?, customer: any, customer_account: str?, default_settings: map{application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: str, billing_thresholds: any?, collection_method: str?, default_payment_method: any?, description: str?, invoice_settings: map{account_tax_ids: [any]?, days_until_due: int?, issuer: map}, on_behalf_of: any?, transfer_data: any?}, end_behavior: str, id: str, livemode: bool, metadata: map?, object: str, phases: [map], released_at: int(unix-time)?, released_subscription: str?, status: str, subscription: any?, test_clock: any?} # Successful response.

@endpoint POST /v1/subscription_schedules/{schedule}/cancel
@desc Cancel a schedule
@required {schedule: str}
@returns(200) {application: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, canceled_at: int(unix-time)?, completed_at: int(unix-time)?, created: int(unix-time), current_phase: any?, customer: any, customer_account: str?, default_settings: map{application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: str, billing_thresholds: any?, collection_method: str?, default_payment_method: any?, description: str?, invoice_settings: map{account_tax_ids: [any]?, days_until_due: int?, issuer: map}, on_behalf_of: any?, transfer_data: any?}, end_behavior: str, id: str, livemode: bool, metadata: map?, object: str, phases: [map], released_at: int(unix-time)?, released_subscription: str?, status: str, subscription: any?, test_clock: any?} # Successful response.

@endpoint POST /v1/subscription_schedules/{schedule}/release
@desc Release a schedule
@required {schedule: str}
@returns(200) {application: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, canceled_at: int(unix-time)?, completed_at: int(unix-time)?, created: int(unix-time), current_phase: any?, customer: any, customer_account: str?, default_settings: map{application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: str, billing_thresholds: any?, collection_method: str?, default_payment_method: any?, description: str?, invoice_settings: map{account_tax_ids: [any]?, days_until_due: int?, issuer: map}, on_behalf_of: any?, transfer_data: any?}, end_behavior: str, id: str, livemode: bool, metadata: map?, object: str, phases: [map], released_at: int(unix-time)?, released_subscription: str?, status: str, subscription: any?, test_clock: any?} # Successful response.

@endgroup

@group subscriptions
@endpoint GET /v1/subscriptions
@desc List subscriptions
@optional {automatic_tax: map # Filter subscriptions by their automatic tax settings., collection_method: str(charge_automatically/send_invoice) # The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`., created: any # Only return subscriptions that were created during the given date interval., current_period_end: any # Only return subscriptions whose minimum item current_period_end falls within the given date interval., current_period_start: any # Only return subscriptions whose maximum item current_period_start falls within the given date interval., customer: str # The ID of the customer whose subscriptions you're retrieving., customer_account: str # The ID of the account representing the customer whose subscriptions you're retrieving., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., price: str # Filter for subscriptions that contain this recurring price ID., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(active/all/canceled/ended/incomplete/incomplete_expired/past_due/paused/trialing/unpaid) # The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://docs.stripe.com/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned., test_clock: str # Filter for subscriptions that are associated with the specified test clock. The response will not include subscriptions with test clocks if this and the customer parameter is not set.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/subscriptions
@desc Create a subscription
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endpoint GET /v1/subscriptions/search
@desc Search subscriptions
@required {query: str # The search query string. See [search query language](https://docs.stripe.com/search#search-query-language) and the list of supported [query fields for subscriptions](https://docs.stripe.com/search#query-fields-for-subscriptions).}
@optional {expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., page: str # A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.}
@returns(200) {data: [map], has_more: bool, next_page: str?, object: str, total_count: int, url: str} # Successful response.

@endpoint DELETE /v1/subscriptions/{subscription_exposed_id}
@desc Cancel a subscription
@required {subscription_exposed_id: str}
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endpoint GET /v1/subscriptions/{subscription_exposed_id}
@desc Retrieve a subscription
@required {subscription_exposed_id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endpoint POST /v1/subscriptions/{subscription_exposed_id}
@desc Update a subscription
@required {subscription_exposed_id: str}
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endpoint DELETE /v1/subscriptions/{subscription_exposed_id}/discount
@desc Delete a subscription discount
@required {subscription_exposed_id: str}
@returns(200) {checkout_session: str?, customer: any?, customer_account: str?, deleted: bool, id: str, invoice: str?, invoice_item: str?, object: str, promotion_code: any?, source: map{coupon: any?, type: str}, start: int(unix-time), subscription: str?, subscription_item: str?} # Successful response.

@endpoint POST /v1/subscriptions/{subscription}/migrate
@desc Migrate a subscription
@required {subscription: str}
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endpoint POST /v1/subscriptions/{subscription}/resume
@desc Resume a subscription
@required {subscription: str}
@returns(200) {application: any?, application_fee_percent: num?, automatic_tax: map{disabled_reason: str?, enabled: bool, liability: any?}, billing_cycle_anchor: int(unix-time), billing_cycle_anchor_config: any?, billing_mode: map{flexible: any?, type: str, updated_at: int(unix-time)}, billing_thresholds: any?, cancel_at: int(unix-time)?, cancel_at_period_end: bool, canceled_at: int(unix-time)?, cancellation_details: any?, collection_method: str, created: int(unix-time), currency: str(currency), customer: any, customer_account: str?, days_until_due: int?, default_payment_method: any?, default_source: any?, default_tax_rates: [map]?, description: str?, discounts: [any], ended_at: int(unix-time)?, id: str, invoice_settings: map{account_tax_ids: [any]?, issuer: map{account: any, type: str}}, items: map{data: [map], has_more: bool, object: str, url: str}, latest_invoice: any?, livemode: bool, metadata: map, next_pending_invoice_item_invoice: int(unix-time)?, object: str, on_behalf_of: any?, pause_collection: any?, payment_settings: any?, pending_invoice_item_interval: any?, pending_setup_intent: any?, pending_update: any?, schedule: any?, start_date: int(unix-time), status: str, test_clock: any?, transfer_data: any?, trial_end: int(unix-time)?, trial_settings: any?, trial_start: int(unix-time)?} # Successful response.

@endgroup

@group tax
@endpoint GET /v1/tax/associations/find
@desc Find a Tax Association
@required {payment_intent: str # Valid [PaymentIntent](https://docs.stripe.com/api/payment_intents/object) id}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {calculation: str, id: str, object: str, payment_intent: str, tax_transaction_attempts: [map]?} # Successful response.

@endpoint POST /v1/tax/calculations
@desc Create a Tax Calculation
@returns(200) {amount_total: int, currency: str, customer: str?, customer_details: map{address: any?, address_source: str?, ip_address: str?, tax_ids: [map], taxability_override: str}, expires_at: int(unix-time)?, id: str?, line_items: map?{data: [map], has_more: bool, object: str, url: str}, livemode: bool, object: str, ship_from_details: any?, shipping_cost: any?, tax_amount_exclusive: int, tax_amount_inclusive: int, tax_breakdown: [map], tax_date: int(unix-time)} # Successful response.

@endpoint GET /v1/tax/calculations/{calculation}
@desc Retrieve a Tax Calculation
@required {calculation: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount_total: int, currency: str, customer: str?, customer_details: map{address: any?, address_source: str?, ip_address: str?, tax_ids: [map], taxability_override: str}, expires_at: int(unix-time)?, id: str?, line_items: map?{data: [map], has_more: bool, object: str, url: str}, livemode: bool, object: str, ship_from_details: any?, shipping_cost: any?, tax_amount_exclusive: int, tax_amount_inclusive: int, tax_breakdown: [map], tax_date: int(unix-time)} # Successful response.

@endpoint GET /v1/tax/calculations/{calculation}/line_items
@desc Retrieve a calculation's line items
@required {calculation: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/tax/registrations
@desc List registrations
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(active/all/expired/scheduled) # The status of the Tax Registration.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/tax/registrations
@desc Create a registration
@returns(200) {active_from: int(unix-time), country: str, country_options: map{ae: map{standard: map, type: str}, al: map{type: str}, am: map{type: str}, ao: map{type: str}, at: map{standard: map, type: str}, au: map{standard: map, type: str}, aw: map{type: str}, az: map{type: str}, ba: map{type: str}, bb: map{type: str}, bd: map{type: str}, be: map{standard: map, type: str}, bf: map{type: str}, bg: map{standard: map, type: str}, bh: map{type: str}, bj: map{type: str}, bs: map{type: str}, by: map{type: str}, ca: map{province_standard: map, type: str}, cd: map{type: str}, ch: map{standard: map, type: str}, cl: map{type: str}, cm: map{type: str}, co: map{type: str}, cr: map{type: str}, cv: map{type: str}, cy: map{standard: map, type: str}, cz: map{standard: map, type: str}, de: map{standard: map, type: str}, dk: map{standard: map, type: str}, ec: map{type: str}, ee: map{standard: map, type: str}, eg: map{type: str}, es: map{standard: map, type: str}, et: map{type: str}, fi: map{standard: map, type: str}, fr: map{standard: map, type: str}, gb: map{standard: map, type: str}, ge: map{type: str}, gn: map{type: str}, gr: map{standard: map, type: str}, hr: map{standard: map, type: str}, hu: map{standard: map, type: str}, id: map{type: str}, ie: map{standard: map, type: str}, in: map{type: str}, is: map{type: str}, it: map{standard: map, type: str}, jp: map{standard: map, type: str}, ke: map{type: str}, kg: map{type: str}, kh: map{type: str}, kr: map{type: str}, kz: map{type: str}, la: map{type: str}, lt: map{standard: map, type: str}, lu: map{standard: map, type: str}, lv: map{standard: map, type: str}, ma: map{type: str}, md: map{type: str}, me: map{type: str}, mk: map{type: str}, mr: map{type: str}, mt: map{standard: map, type: str}, mx: map{type: str}, my: map{type: str}, ng: map{type: str}, nl: map{standard: map, type: str}, no: map{standard: map, type: str}, np: map{type: str}, nz: map{standard: map, type: str}, om: map{type: str}, pe: map{type: str}, ph: map{type: str}, pl: map{standard: map, type: str}, pt: map{standard: map, type: str}, ro: map{standard: map, type: str}, rs: map{type: str}, ru: map{type: str}, sa: map{type: str}, se: map{standard: map, type: str}, sg: map{standard: map, type: str}, si: map{standard: map, type: str}, sk: map{standard: map, type: str}, sn: map{type: str}, sr: map{type: str}, th: map{type: str}, tj: map{type: str}, tr: map{type: str}, tw: map{type: str}, tz: map{type: str}, ua: map{type: str}, ug: map{type: str}, us: map{local_amusement_tax: map, local_lease_tax: map, state: str, state_sales_tax: map, type: str}, uy: map{type: str}, uz: map{type: str}, vn: map{type: str}, za: map{type: str}, zm: map{type: str}, zw: map{type: str}}, created: int(unix-time), expires_at: int(unix-time)?, id: str, livemode: bool, object: str, status: str} # Successful response.

@endpoint GET /v1/tax/registrations/{id}
@desc Retrieve a registration
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active_from: int(unix-time), country: str, country_options: map{ae: map{standard: map, type: str}, al: map{type: str}, am: map{type: str}, ao: map{type: str}, at: map{standard: map, type: str}, au: map{standard: map, type: str}, aw: map{type: str}, az: map{type: str}, ba: map{type: str}, bb: map{type: str}, bd: map{type: str}, be: map{standard: map, type: str}, bf: map{type: str}, bg: map{standard: map, type: str}, bh: map{type: str}, bj: map{type: str}, bs: map{type: str}, by: map{type: str}, ca: map{province_standard: map, type: str}, cd: map{type: str}, ch: map{standard: map, type: str}, cl: map{type: str}, cm: map{type: str}, co: map{type: str}, cr: map{type: str}, cv: map{type: str}, cy: map{standard: map, type: str}, cz: map{standard: map, type: str}, de: map{standard: map, type: str}, dk: map{standard: map, type: str}, ec: map{type: str}, ee: map{standard: map, type: str}, eg: map{type: str}, es: map{standard: map, type: str}, et: map{type: str}, fi: map{standard: map, type: str}, fr: map{standard: map, type: str}, gb: map{standard: map, type: str}, ge: map{type: str}, gn: map{type: str}, gr: map{standard: map, type: str}, hr: map{standard: map, type: str}, hu: map{standard: map, type: str}, id: map{type: str}, ie: map{standard: map, type: str}, in: map{type: str}, is: map{type: str}, it: map{standard: map, type: str}, jp: map{standard: map, type: str}, ke: map{type: str}, kg: map{type: str}, kh: map{type: str}, kr: map{type: str}, kz: map{type: str}, la: map{type: str}, lt: map{standard: map, type: str}, lu: map{standard: map, type: str}, lv: map{standard: map, type: str}, ma: map{type: str}, md: map{type: str}, me: map{type: str}, mk: map{type: str}, mr: map{type: str}, mt: map{standard: map, type: str}, mx: map{type: str}, my: map{type: str}, ng: map{type: str}, nl: map{standard: map, type: str}, no: map{standard: map, type: str}, np: map{type: str}, nz: map{standard: map, type: str}, om: map{type: str}, pe: map{type: str}, ph: map{type: str}, pl: map{standard: map, type: str}, pt: map{standard: map, type: str}, ro: map{standard: map, type: str}, rs: map{type: str}, ru: map{type: str}, sa: map{type: str}, se: map{standard: map, type: str}, sg: map{standard: map, type: str}, si: map{standard: map, type: str}, sk: map{standard: map, type: str}, sn: map{type: str}, sr: map{type: str}, th: map{type: str}, tj: map{type: str}, tr: map{type: str}, tw: map{type: str}, tz: map{type: str}, ua: map{type: str}, ug: map{type: str}, us: map{local_amusement_tax: map, local_lease_tax: map, state: str, state_sales_tax: map, type: str}, uy: map{type: str}, uz: map{type: str}, vn: map{type: str}, za: map{type: str}, zm: map{type: str}, zw: map{type: str}}, created: int(unix-time), expires_at: int(unix-time)?, id: str, livemode: bool, object: str, status: str} # Successful response.

@endpoint POST /v1/tax/registrations/{id}
@desc Update a registration
@required {id: str}
@returns(200) {active_from: int(unix-time), country: str, country_options: map{ae: map{standard: map, type: str}, al: map{type: str}, am: map{type: str}, ao: map{type: str}, at: map{standard: map, type: str}, au: map{standard: map, type: str}, aw: map{type: str}, az: map{type: str}, ba: map{type: str}, bb: map{type: str}, bd: map{type: str}, be: map{standard: map, type: str}, bf: map{type: str}, bg: map{standard: map, type: str}, bh: map{type: str}, bj: map{type: str}, bs: map{type: str}, by: map{type: str}, ca: map{province_standard: map, type: str}, cd: map{type: str}, ch: map{standard: map, type: str}, cl: map{type: str}, cm: map{type: str}, co: map{type: str}, cr: map{type: str}, cv: map{type: str}, cy: map{standard: map, type: str}, cz: map{standard: map, type: str}, de: map{standard: map, type: str}, dk: map{standard: map, type: str}, ec: map{type: str}, ee: map{standard: map, type: str}, eg: map{type: str}, es: map{standard: map, type: str}, et: map{type: str}, fi: map{standard: map, type: str}, fr: map{standard: map, type: str}, gb: map{standard: map, type: str}, ge: map{type: str}, gn: map{type: str}, gr: map{standard: map, type: str}, hr: map{standard: map, type: str}, hu: map{standard: map, type: str}, id: map{type: str}, ie: map{standard: map, type: str}, in: map{type: str}, is: map{type: str}, it: map{standard: map, type: str}, jp: map{standard: map, type: str}, ke: map{type: str}, kg: map{type: str}, kh: map{type: str}, kr: map{type: str}, kz: map{type: str}, la: map{type: str}, lt: map{standard: map, type: str}, lu: map{standard: map, type: str}, lv: map{standard: map, type: str}, ma: map{type: str}, md: map{type: str}, me: map{type: str}, mk: map{type: str}, mr: map{type: str}, mt: map{standard: map, type: str}, mx: map{type: str}, my: map{type: str}, ng: map{type: str}, nl: map{standard: map, type: str}, no: map{standard: map, type: str}, np: map{type: str}, nz: map{standard: map, type: str}, om: map{type: str}, pe: map{type: str}, ph: map{type: str}, pl: map{standard: map, type: str}, pt: map{standard: map, type: str}, ro: map{standard: map, type: str}, rs: map{type: str}, ru: map{type: str}, sa: map{type: str}, se: map{standard: map, type: str}, sg: map{standard: map, type: str}, si: map{standard: map, type: str}, sk: map{standard: map, type: str}, sn: map{type: str}, sr: map{type: str}, th: map{type: str}, tj: map{type: str}, tr: map{type: str}, tw: map{type: str}, tz: map{type: str}, ua: map{type: str}, ug: map{type: str}, us: map{local_amusement_tax: map, local_lease_tax: map, state: str, state_sales_tax: map, type: str}, uy: map{type: str}, uz: map{type: str}, vn: map{type: str}, za: map{type: str}, zm: map{type: str}, zw: map{type: str}}, created: int(unix-time), expires_at: int(unix-time)?, id: str, livemode: bool, object: str, status: str} # Successful response.

@endpoint GET /v1/tax/settings
@desc Retrieve settings
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {defaults: map{provider: str, tax_behavior: str?, tax_code: str?}, head_office: any?, livemode: bool, object: str, status: str, status_details: map{active: map, pending: map{missing_fields: [str]?}}} # Successful response.

@endpoint POST /v1/tax/settings
@desc Update settings
@returns(200) {defaults: map{provider: str, tax_behavior: str?, tax_code: str?}, head_office: any?, livemode: bool, object: str, status: str, status_details: map{active: map, pending: map{missing_fields: [str]?}}} # Successful response.

@endpoint POST /v1/tax/transactions/create_from_calculation
@desc Create a transaction from a calculation
@returns(200) {created: int(unix-time), currency: str, customer: str?, customer_details: map{address: any?, address_source: str?, ip_address: str?, tax_ids: [map], taxability_override: str}, id: str, line_items: map?{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, object: str, posted_at: int(unix-time), reference: str, reversal: any?, ship_from_details: any?, shipping_cost: any?, tax_date: int(unix-time), type: str} # Successful response.

@endpoint POST /v1/tax/transactions/create_reversal
@desc Create a reversal transaction
@returns(200) {created: int(unix-time), currency: str, customer: str?, customer_details: map{address: any?, address_source: str?, ip_address: str?, tax_ids: [map], taxability_override: str}, id: str, line_items: map?{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, object: str, posted_at: int(unix-time), reference: str, reversal: any?, ship_from_details: any?, shipping_cost: any?, tax_date: int(unix-time), type: str} # Successful response.

@endpoint GET /v1/tax/transactions/{transaction}
@desc Retrieve a transaction
@required {transaction: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), currency: str, customer: str?, customer_details: map{address: any?, address_source: str?, ip_address: str?, tax_ids: [map], taxability_override: str}, id: str, line_items: map?{data: [map], has_more: bool, object: str, url: str}, livemode: bool, metadata: map?, object: str, posted_at: int(unix-time), reference: str, reversal: any?, ship_from_details: any?, shipping_cost: any?, tax_date: int(unix-time), type: str} # Successful response.

@endpoint GET /v1/tax/transactions/{transaction}/line_items
@desc Retrieve a transaction's line items
@required {transaction: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endgroup

@group tax_codes
@endpoint GET /v1/tax_codes
@desc List all tax codes
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/tax_codes/{id}
@desc Retrieve a tax code
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {description: str, id: str, name: str, object: str} # Successful response.

@endgroup

@group tax_ids
@endpoint GET /v1/tax_ids
@desc List all tax IDs
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., owner: map # The account or customer the tax ID belongs to. Defaults to `owner[type]=self`., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/tax_ids
@desc Create a tax ID
@returns(200) {country: str?, created: int(unix-time), customer: any?, customer_account: str?, id: str, livemode: bool, object: str, owner: any?, type: str, value: str, verification: any?} # Successful response.

@endpoint DELETE /v1/tax_ids/{id}
@desc Delete a tax ID
@required {id: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/tax_ids/{id}
@desc Retrieve a tax ID
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {country: str?, created: int(unix-time), customer: any?, customer_account: str?, id: str, livemode: bool, object: str, owner: any?, type: str, value: str, verification: any?} # Successful response.

@endgroup

@group tax_rates
@endpoint GET /v1/tax_rates
@desc List all tax rates
@optional {active: bool # Optional flag to filter by tax rates that are either active or inactive (archived)., created: any # Optional range for filtering created date., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., inclusive: bool # Optional flag to filter by tax rates that are inclusive (or those that are not inclusive)., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/tax_rates
@desc Create a tax rate
@returns(200) {active: bool, country: str?, created: int(unix-time), description: str?, display_name: str, effective_percentage: num?, flat_amount: any?, id: str, inclusive: bool, jurisdiction: str?, jurisdiction_level: str?, livemode: bool, metadata: map?, object: str, percentage: num, rate_type: str?, state: str?, tax_type: str?} # Successful response.

@endpoint GET /v1/tax_rates/{tax_rate}
@desc Retrieve a tax rate
@required {tax_rate: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active: bool, country: str?, created: int(unix-time), description: str?, display_name: str, effective_percentage: num?, flat_amount: any?, id: str, inclusive: bool, jurisdiction: str?, jurisdiction_level: str?, livemode: bool, metadata: map?, object: str, percentage: num, rate_type: str?, state: str?, tax_type: str?} # Successful response.

@endpoint POST /v1/tax_rates/{tax_rate}
@desc Update a tax rate
@required {tax_rate: str}
@returns(200) {active: bool, country: str?, created: int(unix-time), description: str?, display_name: str, effective_percentage: num?, flat_amount: any?, id: str, inclusive: bool, jurisdiction: str?, jurisdiction_level: str?, livemode: bool, metadata: map?, object: str, percentage: num, rate_type: str?, state: str?, tax_type: str?} # Successful response.

@endgroup

@group terminal
@endpoint GET /v1/terminal/configurations
@desc List all Configurations
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., is_account_default: bool # if present, only return the account default or non-default configurations., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/terminal/configurations
@desc Create a Configuration
@returns(200) {bbpos_wisepad3: map{splashscreen: any}, bbpos_wisepos_e: map{splashscreen: any}, id: str, is_account_default: bool?, livemode: bool, name: str?, object: str, offline: map{enabled: bool?}, reboot_window: map{end_hour: int, start_hour: int}, stripe_s700: map{splashscreen: any}, tipping: map{aed: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, aud: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, cad: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, chf: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, czk: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, dkk: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, eur: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, gbp: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, gip: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, hkd: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, huf: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, jpy: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, mxn: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, myr: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, nok: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, nzd: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, pln: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, ron: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, sek: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, sgd: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}, usd: map{fixed_amounts: [int]?, percentages: [int]?, smart_tip_threshold: int}}, verifone_p400: map{splashscreen: any}, wifi: map{enterprise_eap_peap: map{ca_certificate_file: str, password: str, ssid: str, username: str}, enterprise_eap_tls: map{ca_certificate_file: str, client_certificate_file: str, private_key_file: str, private_key_file_password: str, ssid: str}, personal_psk: map{password: str, ssid: str}, type: str}} # Successful response.

@endpoint DELETE /v1/terminal/configurations/{configuration}
@desc Delete a Configuration
@required {configuration: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/terminal/configurations/{configuration}
@desc Retrieve a Configuration
@required {configuration: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) Successful response.

@endpoint POST /v1/terminal/configurations/{configuration}
@desc Update a Configuration
@required {configuration: str}
@returns(200) Successful response.

@endpoint POST /v1/terminal/connection_tokens
@desc Create a Connection Token
@returns(200) {location: str, object: str, secret: str} # Successful response.

@endpoint GET /v1/terminal/locations
@desc List all Locations
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/terminal/locations
@desc Create a Location
@returns(200) {address: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?}, address_kana: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?, town: str?}, address_kanji: map{city: str?, country: str?, line1: str?, line2: str?, postal_code: str?, state: str?, town: str?}, configuration_overrides: str, display_name: str, display_name_kana: str, display_name_kanji: str, id: str, livemode: bool, metadata: map, object: str, phone: str} # Successful response.

@endpoint DELETE /v1/terminal/locations/{location}
@desc Delete a Location
@required {location: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/terminal/locations/{location}
@desc Retrieve a Location
@required {location: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) Successful response.

@endpoint POST /v1/terminal/locations/{location}
@desc Update a Location
@required {location: str}
@returns(200) Successful response.

@endpoint POST /v1/terminal/onboarding_links
@desc Create an Onboarding Link
@returns(200) {link_options: map{apple_terms_and_conditions: any?}, link_type: str, object: str, on_behalf_of: str?, redirect_url: str} # Successful response.

@endpoint GET /v1/terminal/readers
@desc List all Readers
@optional {device_type: str(bbpos_chipper2x/bbpos_wisepad3/bbpos_wisepos_e/mobile_phone_reader/simulated_stripe_s700/simulated_wisepos_e/stripe_m2/stripe_s700/verifone_P400) # Filters readers by device type, ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., location: str # A location ID to filter the response list to only readers at the specific location, serial_number: str # Filters readers by serial number, starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(offline/online) # A status filter to filter readers to only offline or online readers}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/terminal/readers
@desc Create a Reader
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint DELETE /v1/terminal/readers/{reader}
@desc Delete a Reader
@required {reader: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/terminal/readers/{reader}
@desc Retrieve a Reader
@required {reader: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) Successful response.

@endpoint POST /v1/terminal/readers/{reader}
@desc Update a Reader
@required {reader: str}
@returns(200) Successful response.

@endpoint POST /v1/terminal/readers/{reader}/cancel_action
@desc Cancel the current reader action
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint POST /v1/terminal/readers/{reader}/collect_inputs
@desc Collect inputs using a Reader
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint POST /v1/terminal/readers/{reader}/collect_payment_method
@desc Hand off a PaymentIntent to a Reader and collect card details
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint POST /v1/terminal/readers/{reader}/confirm_payment_intent
@desc Confirm a PaymentIntent on the Reader
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint POST /v1/terminal/readers/{reader}/process_payment_intent
@desc Hand-off a PaymentIntent to a Reader
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint POST /v1/terminal/readers/{reader}/process_setup_intent
@desc Hand-off a SetupIntent to a Reader
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint POST /v1/terminal/readers/{reader}/refund_payment
@desc Refund a Charge or a PaymentIntent in-person
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint POST /v1/terminal/readers/{reader}/set_reader_display
@desc Set reader display
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endgroup

@group test_helpers
@endpoint POST /v1/test_helpers/confirmation_tokens
@desc Create a test Confirmation Token
@returns(200) {created: int(unix-time), expires_at: int(unix-time)?, id: str, livemode: bool, mandate_data: any?, object: str, payment_intent: str?, payment_method_options: any?, payment_method_preview: any?, return_url: str?, setup_future_usage: str?, setup_intent: str?, shipping: any?, use_stripe_sdk: bool} # Successful response.

@endpoint POST /v1/test_helpers/customers/{customer}/fund_cash_balance
@desc Fund a test mode cash balance
@required {customer: str}
@returns(200) {adjusted_for_overdraft: map{balance_transaction: any, linked_transaction: any}, applied_to_payment: map{payment_intent: any}, created: int(unix-time), currency: str, customer: any, customer_account: str?, ending_balance: int, funded: map{bank_transfer: map{eu_bank_transfer: map, gb_bank_transfer: map, jp_bank_transfer: map, reference: str?, type: str, us_bank_transfer: map}}, id: str, livemode: bool, net_amount: int, object: str, refunded_from_payment: map{refund: any}, transferred_to_balance: map{balance_transaction: any}, type: str, unapplied_from_payment: map{payment_intent: any}} # Successful response.

@endpoint POST /v1/test_helpers/issuing/authorizations
@desc Create a test-mode authorization
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/authorizations/{authorization}/capture
@desc Capture a test-mode authorization
@required {authorization: str}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/authorizations/{authorization}/expire
@desc Expire a test-mode authorization
@required {authorization: str}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/authorizations/{authorization}/finalize_amount
@desc Finalize a test-mode authorization's amount
@required {authorization: str}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/authorizations/{authorization}/fraud_challenges/respond
@desc Respond to fraud challenge
@required {authorization: str}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/authorizations/{authorization}/increment
@desc Increment a test-mode authorization
@required {authorization: str}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/authorizations/{authorization}/reverse
@desc Reverse a test-mode authorization
@required {authorization: str}
@returns(200) {amount: int, amount_details: any?, approved: bool, authorization_method: str, balance_transactions: [map], card: map{brand: str, cancellation_reason: str?, cardholder: map{billing: map, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?}, cardholder: any?, created: int(unix-time), currency: str(currency), fleet: any?, fraud_challenges: [map]?, fuel: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, pending_request: any?, request_history: [map], status: str, token: any?, transactions: [map], treasury: any?, verification_data: map{address_line1_check: str, address_postal_code_check: str, authentication_exemption: any?, cvc_check: str, expiry_check: str, postal_code: str?, three_d_secure: any?}, verified_by_fraud_challenge: bool?, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/cards/{card}/shipping/deliver
@desc Deliver a testmode card
@required {card: str}
@returns(200) {brand: str, cancellation_reason: str?, cardholder: map{billing: map{address: map}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/cards/{card}/shipping/fail
@desc Fail a testmode card
@required {card: str}
@returns(200) {brand: str, cancellation_reason: str?, cardholder: map{billing: map{address: map}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/cards/{card}/shipping/return
@desc Return a testmode card
@required {card: str}
@returns(200) {brand: str, cancellation_reason: str?, cardholder: map{billing: map{address: map}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/cards/{card}/shipping/ship
@desc Ship a testmode card
@required {card: str}
@returns(200) {brand: str, cancellation_reason: str?, cardholder: map{billing: map{address: map}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/cards/{card}/shipping/submit
@desc Submit a testmode card
@required {card: str}
@returns(200) {brand: str, cancellation_reason: str?, cardholder: map{billing: map{address: map}, company: any?, created: int(unix-time), email: str?, id: str, individual: any?, livemode: bool, metadata: map, name: str, object: str, phone_number: str?, preferred_locales: [str]?, requirements: map{disabled_reason: str?, past_due: [str]?}, spending_controls: any?, status: str, type: str}, created: int(unix-time), currency: str(currency), cvc: str, exp_month: int, exp_year: int, financial_account: str?, id: str, last4: str, latest_fraud_warning: any?, livemode: bool, metadata: map, number: str, object: str, personalization_design: any?, replaced_by: any?, replacement_for: any?, replacement_reason: str?, second_line: str?, shipping: any?, spending_controls: map{allowed_categories: [str]?, allowed_merchant_countries: [str]?, blocked_categories: [str]?, blocked_merchant_countries: [str]?, spending_limits: [map]?, spending_limits_currency: str(currency)?}, status: str, type: str, wallets: any?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/personalization_designs/{personalization_design}/activate
@desc Activate a testmode personalization design
@required {personalization_design: str}
@returns(200) {card_logo: any?, carrier_text: any?, created: int(unix-time), id: str, livemode: bool, lookup_key: str?, metadata: map, name: str?, object: str, physical_bundle: any, preferences: map{is_default: bool, is_platform_default: bool?}, rejection_reasons: map{card_logo: [str]?, carrier_text: [str]?}, status: str} # Successful response.

@endpoint POST /v1/test_helpers/issuing/personalization_designs/{personalization_design}/deactivate
@desc Deactivate a testmode personalization design
@required {personalization_design: str}
@returns(200) {card_logo: any?, carrier_text: any?, created: int(unix-time), id: str, livemode: bool, lookup_key: str?, metadata: map, name: str?, object: str, physical_bundle: any, preferences: map{is_default: bool, is_platform_default: bool?}, rejection_reasons: map{card_logo: [str]?, carrier_text: [str]?}, status: str} # Successful response.

@endpoint POST /v1/test_helpers/issuing/personalization_designs/{personalization_design}/reject
@desc Reject a testmode personalization design
@required {personalization_design: str}
@returns(200) {card_logo: any?, carrier_text: any?, created: int(unix-time), id: str, livemode: bool, lookup_key: str?, metadata: map, name: str?, object: str, physical_bundle: any, preferences: map{is_default: bool, is_platform_default: bool?}, rejection_reasons: map{card_logo: [str]?, carrier_text: [str]?}, status: str} # Successful response.

@endpoint POST /v1/test_helpers/issuing/settlements
@desc Create a test-mode settlement
@returns(200) {bin: str, clearing_date: int(unix-time), created: int(unix-time), currency: str(currency), id: str, interchange_fees_amount: int, livemode: bool, metadata: map, net_total_amount: int, network: str, network_fees_amount: int, network_settlement_identifier: str, object: str, settlement_service: str, status: str, transaction_amount: int, transaction_count: int} # Successful response.

@endpoint POST /v1/test_helpers/issuing/settlements/{settlement}/complete
@desc Complete a test-mode settlement
@required {settlement: str # The settlement token to mark as complete.}
@returns(200) {bin: str, clearing_date: int(unix-time), created: int(unix-time), currency: str(currency), id: str, interchange_fees_amount: int, livemode: bool, metadata: map, net_total_amount: int, network: str, network_fees_amount: int, network_settlement_identifier: str, object: str, settlement_service: str, status: str, transaction_amount: int, transaction_count: int} # Successful response.

@endpoint POST /v1/test_helpers/issuing/transactions/create_force_capture
@desc Create a test-mode force capture
@returns(200) {amount: int, amount_details: any?, authorization: any?, balance_transaction: any?, card: any, cardholder: any?, created: int(unix-time), currency: str(currency), dispute: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, purchase_details: any?, token: any?, treasury: any?, type: str, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/transactions/create_unlinked_refund
@desc Create a test-mode unlinked refund
@returns(200) {amount: int, amount_details: any?, authorization: any?, balance_transaction: any?, card: any, cardholder: any?, created: int(unix-time), currency: str(currency), dispute: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, purchase_details: any?, token: any?, treasury: any?, type: str, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/issuing/transactions/{transaction}/refund
@desc Refund a test-mode transaction
@required {transaction: str}
@returns(200) {amount: int, amount_details: any?, authorization: any?, balance_transaction: any?, card: any, cardholder: any?, created: int(unix-time), currency: str(currency), dispute: any?, id: str, livemode: bool, merchant_amount: int, merchant_currency: str(currency), merchant_data: map{category: str, category_code: str, city: str?, country: str?, name: str?, network_id: str, postal_code: str?, state: str?, tax_id: str?, terminal_id: str?, url: str?}, metadata: map, network_data: any?, object: str, purchase_details: any?, token: any?, treasury: any?, type: str, wallet: str?} # Successful response.

@endpoint POST /v1/test_helpers/refunds/{refund}/expire
@desc Expire a pending refund.
@required {refund: str}
@returns(200) {amount: int, balance_transaction: any?, charge: any?, created: int(unix-time), currency: str(currency), description: str, destination_details: map{affirm: map, afterpay_clearpay: map, alipay: map, alma: map, amazon_pay: map, au_bank_transfer: map, blik: map{network_decline_code: str?, reference: str?, reference_status: str?}, br_bank_transfer: map{reference: str?, reference_status: str?}, card: map{reference: str, reference_status: str, reference_type: str, type: str}, cashapp: map, crypto: map{reference: str?}, customer_cash_balance: map, eps: map, eu_bank_transfer: map{reference: str?, reference_status: str?}, gb_bank_transfer: map{reference: str?, reference_status: str?}, giropay: map, grabpay: map, jp_bank_transfer: map{reference: str?, reference_status: str?}, klarna: map, mb_way: map{reference: str?, reference_status: str?}, multibanco: map{reference: str?, reference_status: str?}, mx_bank_transfer: map{reference: str?, reference_status: str?}, nz_bank_transfer: map, p24: map{reference: str?, reference_status: str?}, paynow: map, paypal: map{network_decline_code: str?}, pix: map, revolut: map, sofort: map, swish: map{network_decline_code: str?, reference: str?, reference_status: str?}, th_bank_transfer: map{reference: str?, reference_status: str?}, twint: map, type: str, us_bank_transfer: map{reference: str?, reference_status: str?}, wechat_pay: map, zip: map}, failure_balance_transaction: any, failure_reason: str, id: str, instructions_email: str, metadata: map?, next_action: map{display_details: map{email_sent: map, expires_at: int(unix-time)}, type: str}, object: str, payment_intent: any?, pending_reason: str, presentment_details: map{presentment_amount: int, presentment_currency: str}, reason: str?, receipt_number: str?, source_transfer_reversal: any?, status: str?, transfer_reversal: any?} # Successful response.

@endpoint POST /v1/test_helpers/terminal/readers/{reader}/present_payment_method
@desc Simulate presenting a payment method
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint POST /v1/test_helpers/terminal/readers/{reader}/succeed_input_collection
@desc Simulate a successful input collection
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint POST /v1/test_helpers/terminal/readers/{reader}/timeout_input_collection
@desc Simulate an input collection timeout
@required {reader: str}
@returns(200) {action: any?, device_sw_version: str?, device_type: str, id: str, ip_address: str?, label: str, last_seen_at: int(unix-time)?, livemode: bool, location: any?, metadata: map, object: str, serial_number: str, status: str?} # Successful response.

@endpoint GET /v1/test_helpers/test_clocks
@desc List all test clocks
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/test_helpers/test_clocks
@desc Create a test clock
@returns(200) {created: int(unix-time), deletes_after: int(unix-time), frozen_time: int(unix-time), id: str, livemode: bool, name: str?, object: str, status: str, status_details: map{advancing: map{target_frozen_time: int(unix-time)}}} # Successful response.

@endpoint DELETE /v1/test_helpers/test_clocks/{test_clock}
@desc Delete a test clock
@required {test_clock: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/test_helpers/test_clocks/{test_clock}
@desc Retrieve a test clock
@required {test_clock: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {created: int(unix-time), deletes_after: int(unix-time), frozen_time: int(unix-time), id: str, livemode: bool, name: str?, object: str, status: str, status_details: map{advancing: map{target_frozen_time: int(unix-time)}}} # Successful response.

@endpoint POST /v1/test_helpers/test_clocks/{test_clock}/advance
@desc Advance a test clock
@required {test_clock: str}
@returns(200) {created: int(unix-time), deletes_after: int(unix-time), frozen_time: int(unix-time), id: str, livemode: bool, name: str?, object: str, status: str, status_details: map{advancing: map{target_frozen_time: int(unix-time)}}} # Successful response.

@endpoint POST /v1/test_helpers/treasury/inbound_transfers/{id}/fail
@desc Test mode: Fail an InboundTransfer
@required {id: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, failure_details: any?, financial_account: str, hosted_regulatory_receipt_url: str?, id: str, linked_flows: map{received_debit: str?}, livemode: bool, metadata: map, object: str, origin_payment_method: str?, origin_payment_method_details: any?, returned: bool?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, succeeded_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint POST /v1/test_helpers/treasury/inbound_transfers/{id}/return
@desc Test mode: Return an InboundTransfer
@required {id: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, failure_details: any?, financial_account: str, hosted_regulatory_receipt_url: str?, id: str, linked_flows: map{received_debit: str?}, livemode: bool, metadata: map, object: str, origin_payment_method: str?, origin_payment_method_details: any?, returned: bool?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, succeeded_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint POST /v1/test_helpers/treasury/inbound_transfers/{id}/succeed
@desc Test mode: Succeed an InboundTransfer
@required {id: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, failure_details: any?, financial_account: str, hosted_regulatory_receipt_url: str?, id: str, linked_flows: map{received_debit: str?}, livemode: bool, metadata: map, object: str, origin_payment_method: str?, origin_payment_method_details: any?, returned: bool?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, succeeded_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint POST /v1/test_helpers/treasury/outbound_payments/{id}
@desc Test mode: Update an OutboundPayment
@required {id: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), customer: str?, description: str?, destination_payment_method: str?, destination_payment_method_details: any?, end_user_details: any?, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/test_helpers/treasury/outbound_payments/{id}/fail
@desc Test mode: Fail an OutboundPayment
@required {id: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), customer: str?, description: str?, destination_payment_method: str?, destination_payment_method_details: any?, end_user_details: any?, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/test_helpers/treasury/outbound_payments/{id}/post
@desc Test mode: Post an OutboundPayment
@required {id: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), customer: str?, description: str?, destination_payment_method: str?, destination_payment_method_details: any?, end_user_details: any?, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/test_helpers/treasury/outbound_payments/{id}/return
@desc Test mode: Return an OutboundPayment
@required {id: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), customer: str?, description: str?, destination_payment_method: str?, destination_payment_method_details: any?, end_user_details: any?, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}
@desc Test mode: Update an OutboundTransfer
@required {outbound_transfer: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, destination_payment_method: str?, destination_payment_method_details: map{billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, fingerprint: str?, last4: str?, mandate: any, network: str, routing_number: str?}}, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/fail
@desc Test mode: Fail an OutboundTransfer
@required {outbound_transfer: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, destination_payment_method: str?, destination_payment_method_details: map{billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, fingerprint: str?, last4: str?, mandate: any, network: str, routing_number: str?}}, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/post
@desc Test mode: Post an OutboundTransfer
@required {outbound_transfer: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, destination_payment_method: str?, destination_payment_method_details: map{billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, fingerprint: str?, last4: str?, mandate: any, network: str, routing_number: str?}}, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/return
@desc Test mode: Return an OutboundTransfer
@required {outbound_transfer: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, destination_payment_method: str?, destination_payment_method_details: map{billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, fingerprint: str?, last4: str?, mandate: any, network: str, routing_number: str?}}, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/test_helpers/treasury/received_credits
@desc Test mode: Create a ReceivedCredit
@returns(200) {amount: int, created: int(unix-time), currency: str(currency), description: str, failure_code: str?, financial_account: str?, hosted_regulatory_receipt_url: str?, id: str, initiating_payment_method_details: map{balance: str, billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, issuing_card: str, type: str, us_bank_account: map{bank_name: str?, last4: str?, routing_number: str?}}, linked_flows: map{credit_reversal: str?, issuing_authorization: str?, issuing_transaction: str?, source_flow: str?, source_flow_details: any?, source_flow_type: str?}, livemode: bool, network: str, object: str, reversal_details: any?, status: str, transaction: any?} # Successful response.

@endpoint POST /v1/test_helpers/treasury/received_debits
@desc Test mode: Create a ReceivedDebit
@returns(200) {amount: int, created: int(unix-time), currency: str(currency), description: str, failure_code: str?, financial_account: str?, hosted_regulatory_receipt_url: str?, id: str, initiating_payment_method_details: map{balance: str, billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, issuing_card: str, type: str, us_bank_account: map{bank_name: str?, last4: str?, routing_number: str?}}, linked_flows: map{debit_reversal: str?, inbound_transfer: str?, issuing_authorization: str?, issuing_transaction: str?, payout: str?, topup: str?}, livemode: bool, network: str, object: str, reversal_details: any?, status: str, transaction: any?} # Successful response.

@endgroup

@group tokens
@endpoint POST /v1/tokens
@desc Create a CVC update token
@returns(200) {bank_account: map{account: any?, account_holder_name: str?, account_holder_type: str?, account_type: str?, available_payout_methods: [str]?, bank_name: str?, country: str, currency: str(currency), customer: any?, default_for_currency: bool?, fingerprint: str?, future_requirements: any?, id: str, last4: str, metadata: map?, object: str, requirements: any?, routing_number: str?, status: str}, card: map{account: any?, address_city: str?, address_country: str?, address_line1: str?, address_line1_check: str?, address_line2: str?, address_state: str?, address_zip: str?, address_zip_check: str?, allow_redisplay: str?, available_payout_methods: [str]?, brand: str, country: str?, currency: str(currency)?, customer: any?, cvc_check: str?, default_for_currency: bool?, dynamic_last4: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str, id: str, iin: str, last4: str, metadata: map?, name: str?, networks: map{preferred: str?}, object: str, regulated_status: str?, status: str?, tokenization_method: str?}, client_ip: str?, created: int(unix-time), id: str, livemode: bool, object: str, type: str, used: bool} # Successful response.

@endpoint GET /v1/tokens/{token}
@desc Retrieve a token
@required {token: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {bank_account: map{account: any?, account_holder_name: str?, account_holder_type: str?, account_type: str?, available_payout_methods: [str]?, bank_name: str?, country: str, currency: str(currency), customer: any?, default_for_currency: bool?, fingerprint: str?, future_requirements: any?, id: str, last4: str, metadata: map?, object: str, requirements: any?, routing_number: str?, status: str}, card: map{account: any?, address_city: str?, address_country: str?, address_line1: str?, address_line1_check: str?, address_line2: str?, address_state: str?, address_zip: str?, address_zip_check: str?, allow_redisplay: str?, available_payout_methods: [str]?, brand: str, country: str?, currency: str(currency)?, customer: any?, cvc_check: str?, default_for_currency: bool?, dynamic_last4: str?, exp_month: int, exp_year: int, fingerprint: str?, funding: str, id: str, iin: str, last4: str, metadata: map?, name: str?, networks: map{preferred: str?}, object: str, regulated_status: str?, status: str?, tokenization_method: str?}, client_ip: str?, created: int(unix-time), id: str, livemode: bool, object: str, type: str, used: bool} # Successful response.

@endgroup

@group topups
@endpoint GET /v1/topups
@desc List all top-ups
@optional {amount: any # A positive integer representing how much to transfer., created: any # A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(canceled/failed/pending/succeeded) # Only return top-ups that have the given status. One of `canceled`, `failed`, `pending` or `succeeded`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/topups
@desc Create a top-up
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str, description: str?, expected_availability_date: int?, failure_code: str?, failure_message: str?, id: str, livemode: bool, metadata: map, object: str, source: any?, statement_descriptor: str?, status: str, transfer_group: str?} # Successful response.

@endpoint GET /v1/topups/{topup}
@desc Retrieve a top-up
@required {topup: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str, description: str?, expected_availability_date: int?, failure_code: str?, failure_message: str?, id: str, livemode: bool, metadata: map, object: str, source: any?, statement_descriptor: str?, status: str, transfer_group: str?} # Successful response.

@endpoint POST /v1/topups/{topup}
@desc Update a top-up
@required {topup: str}
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str, description: str?, expected_availability_date: int?, failure_code: str?, failure_message: str?, id: str, livemode: bool, metadata: map, object: str, source: any?, statement_descriptor: str?, status: str, transfer_group: str?} # Successful response.

@endpoint POST /v1/topups/{topup}/cancel
@desc Cancel a top-up
@required {topup: str}
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str, description: str?, expected_availability_date: int?, failure_code: str?, failure_message: str?, id: str, livemode: bool, metadata: map, object: str, source: any?, statement_descriptor: str?, status: str, transfer_group: str?} # Successful response.

@endgroup

@group transfers
@endpoint GET /v1/transfers
@desc List all transfers
@optional {created: any # Only return transfers that were created during the given date interval., destination: str # Only return transfers for the destination specified by this account ID., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., transfer_group: str # Only return transfers with the specified transfer group.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/transfers
@desc Create a transfer
@returns(200) {amount: int, amount_reversed: int, balance_transaction: any?, created: int(unix-time), currency: str(currency), description: str?, destination: any?, destination_payment: any, id: str, livemode: bool, metadata: map, object: str, reversals: map{data: [map], has_more: bool, object: str, url: str}, reversed: bool, source_transaction: any?, source_type: str, transfer_group: str?} # Successful response.

@endpoint GET /v1/transfers/{id}/reversals
@desc List all reversals
@required {id: str}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/transfers/{id}/reversals
@desc Create a transfer reversal
@required {id: str}
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str(currency), destination_payment_refund: any?, id: str, metadata: map?, object: str, source_refund: any?, transfer: any} # Successful response.

@endpoint GET /v1/transfers/{transfer}
@desc Retrieve a transfer
@required {transfer: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, amount_reversed: int, balance_transaction: any?, created: int(unix-time), currency: str(currency), description: str?, destination: any?, destination_payment: any, id: str, livemode: bool, metadata: map, object: str, reversals: map{data: [map], has_more: bool, object: str, url: str}, reversed: bool, source_transaction: any?, source_type: str, transfer_group: str?} # Successful response.

@endpoint POST /v1/transfers/{transfer}
@desc Update a transfer
@required {transfer: str}
@returns(200) {amount: int, amount_reversed: int, balance_transaction: any?, created: int(unix-time), currency: str(currency), description: str?, destination: any?, destination_payment: any, id: str, livemode: bool, metadata: map, object: str, reversals: map{data: [map], has_more: bool, object: str, url: str}, reversed: bool, source_transaction: any?, source_type: str, transfer_group: str?} # Successful response.

@endpoint GET /v1/transfers/{transfer}/reversals/{id}
@desc Retrieve a reversal
@required {id: str, transfer: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str(currency), destination_payment_refund: any?, id: str, metadata: map?, object: str, source_refund: any?, transfer: any} # Successful response.

@endpoint POST /v1/transfers/{transfer}/reversals/{id}
@desc Update a reversal
@required {id: str, transfer: str}
@returns(200) {amount: int, balance_transaction: any?, created: int(unix-time), currency: str(currency), destination_payment_refund: any?, id: str, metadata: map?, object: str, source_refund: any?, transfer: any} # Successful response.

@endgroup

@group treasury
@endpoint GET /v1/treasury/credit_reversals
@desc List all CreditReversals
@required {financial_account: str # Returns objects associated with this FinancialAccount.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., received_credit: str # Only return CreditReversals for the ReceivedCredit ID., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(canceled/posted/processing) # Only return CreditReversals for a given status.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/treasury/credit_reversals
@desc Create a CreditReversal
@returns(200) {amount: int, created: int(unix-time), currency: str(currency), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, network: str, object: str, received_credit: str, status: str, status_transitions: map{posted_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint GET /v1/treasury/credit_reversals/{credit_reversal}
@desc Retrieve a CreditReversal
@required {credit_reversal: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, created: int(unix-time), currency: str(currency), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, network: str, object: str, received_credit: str, status: str, status_transitions: map{posted_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint GET /v1/treasury/debit_reversals
@desc List all DebitReversals
@required {financial_account: str # Returns objects associated with this FinancialAccount.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., received_debit: str # Only return DebitReversals for the ReceivedDebit ID., resolution: str(lost/won) # Only return DebitReversals for a given resolution., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(canceled/completed/processing) # Only return DebitReversals for a given status.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/treasury/debit_reversals
@desc Create a DebitReversal
@returns(200) {amount: int, created: int(unix-time), currency: str(currency), financial_account: str?, hosted_regulatory_receipt_url: str?, id: str, linked_flows: any?, livemode: bool, metadata: map, network: str, object: str, received_debit: str, status: str, status_transitions: map{completed_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint GET /v1/treasury/debit_reversals/{debit_reversal}
@desc Retrieve a DebitReversal
@required {debit_reversal: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, created: int(unix-time), currency: str(currency), financial_account: str?, hosted_regulatory_receipt_url: str?, id: str, linked_flows: any?, livemode: bool, metadata: map, network: str, object: str, received_debit: str, status: str, status_transitions: map{completed_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint GET /v1/treasury/financial_accounts
@desc List all FinancialAccounts
@optional {created: any # Only return FinancialAccounts that were created during the given date interval., ending_before: str # An object ID cursor for use in pagination., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit ranging from 1 to 100 (defaults to 10)., starting_after: str # An object ID cursor for use in pagination., status: str(closed/open) # Only return FinancialAccounts that have the given status: `open` or `closed`}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/treasury/financial_accounts
@desc Create a FinancialAccount
@returns(200) {active_features: [str], balance: map{cash: map, inbound_pending: map, outbound_pending: map}, country: str, created: int(unix-time), features: map{card_issuing: map{requested: bool, status: str, status_details: [map]}, deposit_insurance: map{requested: bool, status: str, status_details: [map]}, financial_addresses: map{aba: map}, inbound_transfers: map{ach: map}, intra_stripe_flows: map{requested: bool, status: str, status_details: [map]}, object: str, outbound_payments: map{ach: map, us_domestic_wire: map}, outbound_transfers: map{ach: map, us_domestic_wire: map}}, financial_addresses: [map], id: str, is_default: bool, livemode: bool, metadata: map?, nickname: str?, object: str, pending_features: [str], platform_restrictions: any?, restricted_features: [str], status: str, status_details: map{closed: any?}, supported_currencies: [str]} # Successful response.

@endpoint GET /v1/treasury/financial_accounts/{financial_account}
@desc Retrieve a FinancialAccount
@required {financial_account: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {active_features: [str], balance: map{cash: map, inbound_pending: map, outbound_pending: map}, country: str, created: int(unix-time), features: map{card_issuing: map{requested: bool, status: str, status_details: [map]}, deposit_insurance: map{requested: bool, status: str, status_details: [map]}, financial_addresses: map{aba: map}, inbound_transfers: map{ach: map}, intra_stripe_flows: map{requested: bool, status: str, status_details: [map]}, object: str, outbound_payments: map{ach: map, us_domestic_wire: map}, outbound_transfers: map{ach: map, us_domestic_wire: map}}, financial_addresses: [map], id: str, is_default: bool, livemode: bool, metadata: map?, nickname: str?, object: str, pending_features: [str], platform_restrictions: any?, restricted_features: [str], status: str, status_details: map{closed: any?}, supported_currencies: [str]} # Successful response.

@endpoint POST /v1/treasury/financial_accounts/{financial_account}
@desc Update a FinancialAccount
@required {financial_account: str}
@returns(200) {active_features: [str], balance: map{cash: map, inbound_pending: map, outbound_pending: map}, country: str, created: int(unix-time), features: map{card_issuing: map{requested: bool, status: str, status_details: [map]}, deposit_insurance: map{requested: bool, status: str, status_details: [map]}, financial_addresses: map{aba: map}, inbound_transfers: map{ach: map}, intra_stripe_flows: map{requested: bool, status: str, status_details: [map]}, object: str, outbound_payments: map{ach: map, us_domestic_wire: map}, outbound_transfers: map{ach: map, us_domestic_wire: map}}, financial_addresses: [map], id: str, is_default: bool, livemode: bool, metadata: map?, nickname: str?, object: str, pending_features: [str], platform_restrictions: any?, restricted_features: [str], status: str, status_details: map{closed: any?}, supported_currencies: [str]} # Successful response.

@endpoint POST /v1/treasury/financial_accounts/{financial_account}/close
@desc Close a FinancialAccount
@required {financial_account: str}
@returns(200) {active_features: [str], balance: map{cash: map, inbound_pending: map, outbound_pending: map}, country: str, created: int(unix-time), features: map{card_issuing: map{requested: bool, status: str, status_details: [map]}, deposit_insurance: map{requested: bool, status: str, status_details: [map]}, financial_addresses: map{aba: map}, inbound_transfers: map{ach: map}, intra_stripe_flows: map{requested: bool, status: str, status_details: [map]}, object: str, outbound_payments: map{ach: map, us_domestic_wire: map}, outbound_transfers: map{ach: map, us_domestic_wire: map}}, financial_addresses: [map], id: str, is_default: bool, livemode: bool, metadata: map?, nickname: str?, object: str, pending_features: [str], platform_restrictions: any?, restricted_features: [str], status: str, status_details: map{closed: any?}, supported_currencies: [str]} # Successful response.

@endpoint GET /v1/treasury/financial_accounts/{financial_account}/features
@desc Retrieve FinancialAccount Features
@required {financial_account: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {card_issuing: map{requested: bool, status: str, status_details: [map]}, deposit_insurance: map{requested: bool, status: str, status_details: [map]}, financial_addresses: map{aba: map{requested: bool, status: str, status_details: [map]}}, inbound_transfers: map{ach: map{requested: bool, status: str, status_details: [map]}}, intra_stripe_flows: map{requested: bool, status: str, status_details: [map]}, object: str, outbound_payments: map{ach: map{requested: bool, status: str, status_details: [map]}, us_domestic_wire: map{requested: bool, status: str, status_details: [map]}}, outbound_transfers: map{ach: map{requested: bool, status: str, status_details: [map]}, us_domestic_wire: map{requested: bool, status: str, status_details: [map]}}} # Successful response.

@endpoint POST /v1/treasury/financial_accounts/{financial_account}/features
@desc Update FinancialAccount Features
@required {financial_account: str}
@returns(200) {card_issuing: map{requested: bool, status: str, status_details: [map]}, deposit_insurance: map{requested: bool, status: str, status_details: [map]}, financial_addresses: map{aba: map{requested: bool, status: str, status_details: [map]}}, inbound_transfers: map{ach: map{requested: bool, status: str, status_details: [map]}}, intra_stripe_flows: map{requested: bool, status: str, status_details: [map]}, object: str, outbound_payments: map{ach: map{requested: bool, status: str, status_details: [map]}, us_domestic_wire: map{requested: bool, status: str, status_details: [map]}}, outbound_transfers: map{ach: map{requested: bool, status: str, status_details: [map]}, us_domestic_wire: map{requested: bool, status: str, status_details: [map]}}} # Successful response.

@endpoint GET /v1/treasury/inbound_transfers
@desc List all InboundTransfers
@required {financial_account: str # Returns objects associated with this FinancialAccount.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(canceled/failed/processing/succeeded) # Only return InboundTransfers that have the given status: `processing`, `succeeded`, `failed` or `canceled`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/treasury/inbound_transfers
@desc Create an InboundTransfer
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, failure_details: any?, financial_account: str, hosted_regulatory_receipt_url: str?, id: str, linked_flows: map{received_debit: str?}, livemode: bool, metadata: map, object: str, origin_payment_method: str?, origin_payment_method_details: any?, returned: bool?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, succeeded_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint GET /v1/treasury/inbound_transfers/{id}
@desc Retrieve an InboundTransfer
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, failure_details: any?, financial_account: str, hosted_regulatory_receipt_url: str?, id: str, linked_flows: map{received_debit: str?}, livemode: bool, metadata: map, object: str, origin_payment_method: str?, origin_payment_method_details: any?, returned: bool?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, succeeded_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint POST /v1/treasury/inbound_transfers/{inbound_transfer}/cancel
@desc Cancel an InboundTransfer
@required {inbound_transfer: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, failure_details: any?, financial_account: str, hosted_regulatory_receipt_url: str?, id: str, linked_flows: map{received_debit: str?}, livemode: bool, metadata: map, object: str, origin_payment_method: str?, origin_payment_method_details: any?, returned: bool?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, succeeded_at: int(unix-time)?}, transaction: any?} # Successful response.

@endpoint GET /v1/treasury/outbound_payments
@desc List all OutboundPayments
@required {financial_account: str # Returns objects associated with this FinancialAccount.}
@optional {created: any # Only return OutboundPayments that were created during the given date interval., customer: str # Only return OutboundPayments sent to this customer., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(canceled/failed/posted/processing/returned) # Only return OutboundPayments that have the given status: `processing`, `failed`, `posted`, `returned`, or `canceled`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/treasury/outbound_payments
@desc Create an OutboundPayment
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), customer: str?, description: str?, destination_payment_method: str?, destination_payment_method_details: any?, end_user_details: any?, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint GET /v1/treasury/outbound_payments/{id}
@desc Retrieve an OutboundPayment
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), customer: str?, description: str?, destination_payment_method: str?, destination_payment_method_details: any?, end_user_details: any?, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/treasury/outbound_payments/{id}/cancel
@desc Cancel an OutboundPayment
@required {id: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), customer: str?, description: str?, destination_payment_method: str?, destination_payment_method_details: any?, end_user_details: any?, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint GET /v1/treasury/outbound_transfers
@desc List all OutboundTransfers
@required {financial_account: str # Returns objects associated with this FinancialAccount.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(canceled/failed/posted/processing/returned) # Only return OutboundTransfers that have the given status: `processing`, `canceled`, `failed`, `posted`, or `returned`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/treasury/outbound_transfers
@desc Create an OutboundTransfer
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, destination_payment_method: str?, destination_payment_method_details: map{billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, fingerprint: str?, last4: str?, mandate: any, network: str, routing_number: str?}}, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint GET /v1/treasury/outbound_transfers/{outbound_transfer}
@desc Retrieve an OutboundTransfer
@required {outbound_transfer: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, destination_payment_method: str?, destination_payment_method_details: map{billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, fingerprint: str?, last4: str?, mandate: any, network: str, routing_number: str?}}, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint POST /v1/treasury/outbound_transfers/{outbound_transfer}/cancel
@desc Cancel an OutboundTransfer
@required {outbound_transfer: str}
@returns(200) {amount: int, cancelable: bool, created: int(unix-time), currency: str(currency), description: str?, destination_payment_method: str?, destination_payment_method_details: map{billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, type: str, us_bank_account: map{account_holder_type: str?, account_type: str?, bank_name: str?, fingerprint: str?, last4: str?, mandate: any, network: str, routing_number: str?}}, expected_arrival_date: int(unix-time), financial_account: str, hosted_regulatory_receipt_url: str?, id: str, livemode: bool, metadata: map, object: str, returned_details: any?, statement_descriptor: str, status: str, status_transitions: map{canceled_at: int(unix-time)?, failed_at: int(unix-time)?, posted_at: int(unix-time)?, returned_at: int(unix-time)?}, tracking_details: any?, transaction: any} # Successful response.

@endpoint GET /v1/treasury/received_credits
@desc List all ReceivedCredits
@required {financial_account: str # The FinancialAccount that received the funds.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., linked_flows: map # Only return ReceivedCredits described by the flow., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(failed/succeeded) # Only return ReceivedCredits that have the given status: `succeeded` or `failed`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/treasury/received_credits/{id}
@desc Retrieve a ReceivedCredit
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, created: int(unix-time), currency: str(currency), description: str, failure_code: str?, financial_account: str?, hosted_regulatory_receipt_url: str?, id: str, initiating_payment_method_details: map{balance: str, billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, issuing_card: str, type: str, us_bank_account: map{bank_name: str?, last4: str?, routing_number: str?}}, linked_flows: map{credit_reversal: str?, issuing_authorization: str?, issuing_transaction: str?, source_flow: str?, source_flow_details: any?, source_flow_type: str?}, livemode: bool, network: str, object: str, reversal_details: any?, status: str, transaction: any?} # Successful response.

@endpoint GET /v1/treasury/received_debits
@desc List all ReceivedDebits
@required {financial_account: str # The FinancialAccount that funds were pulled from.}
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(failed/succeeded) # Only return ReceivedDebits that have the given status: `succeeded` or `failed`.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/treasury/received_debits/{id}
@desc Retrieve a ReceivedDebit
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, created: int(unix-time), currency: str(currency), description: str, failure_code: str?, financial_account: str?, hosted_regulatory_receipt_url: str?, id: str, initiating_payment_method_details: map{balance: str, billing_details: map{address: map, email: str?, name: str?}, financial_account: map{id: str, network: str}, issuing_card: str, type: str, us_bank_account: map{bank_name: str?, last4: str?, routing_number: str?}}, linked_flows: map{debit_reversal: str?, inbound_transfer: str?, issuing_authorization: str?, issuing_transaction: str?, payout: str?, topup: str?}, livemode: bool, network: str, object: str, reversal_details: any?, status: str, transaction: any?} # Successful response.

@endpoint GET /v1/treasury/transaction_entries
@desc List all TransactionEntries
@required {financial_account: str # Returns objects associated with this FinancialAccount.}
@optional {created: any # Only return TransactionEntries that were created during the given date interval., effective_at: any, ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., order_by: str(created/effective_at) # The results are in reverse chronological order by `created` or `effective_at`. The default is `created`., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., transaction: str # Only return TransactionEntries associated with this Transaction.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/treasury/transaction_entries/{id}
@desc Retrieve a TransactionEntry
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {balance_impact: map{cash: int, inbound_pending: int, outbound_pending: int}, created: int(unix-time), currency: str(currency), effective_at: int(unix-time), financial_account: str, flow: str?, flow_details: any?, flow_type: str, id: str, livemode: bool, object: str, transaction: any, type: str} # Successful response.

@endpoint GET /v1/treasury/transactions
@desc List all Transactions
@required {financial_account: str # Returns objects associated with this FinancialAccount.}
@optional {created: any # Only return Transactions that were created during the given date interval., ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., order_by: str(created/posted_at) # The results are in reverse chronological order by `created` or `posted_at`. The default is `created`., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list., status: str(open/posted/void) # Only return Transactions that have the given status: `open`, `posted`, or `void`., status_transitions: map # A filter for the `status_transitions.posted_at` timestamp. When using this filter, `status=posted` and `order_by=posted_at` must also be specified.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint GET /v1/treasury/transactions/{id}
@desc Retrieve a Transaction
@required {id: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {amount: int, balance_impact: map{cash: int, inbound_pending: int, outbound_pending: int}, created: int(unix-time), currency: str(currency), description: str, entries: map?{data: [map], has_more: bool, object: str, url: str}, financial_account: str, flow: str?, flow_details: any?, flow_type: str, id: str, livemode: bool, object: str, status: str, status_transitions: map{posted_at: int(unix-time)?, void_at: int(unix-time)?}} # Successful response.

@endgroup

@group webhook_endpoints
@endpoint GET /v1/webhook_endpoints
@desc List all webhook endpoints
@optional {ending_before: str # A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list., expand: [str] # Specifies which fields in the response should be expanded., limit: int # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10., starting_after: str # A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.}
@returns(200) {data: [map], has_more: bool, object: str, url: str} # Successful response.

@endpoint POST /v1/webhook_endpoints
@desc Create a webhook endpoint
@returns(200) {api_version: str?, application: str?, created: int(unix-time), description: str?, enabled_events: [str], id: str, livemode: bool, metadata: map, object: str, secret: str, status: str, url: str} # Successful response.

@endpoint DELETE /v1/webhook_endpoints/{webhook_endpoint}
@desc Delete a webhook endpoint
@required {webhook_endpoint: str}
@returns(200) {deleted: bool, id: str, object: str} # Successful response.

@endpoint GET /v1/webhook_endpoints/{webhook_endpoint}
@desc Retrieve a webhook endpoint
@required {webhook_endpoint: str}
@optional {expand: [str] # Specifies which fields in the response should be expanded.}
@returns(200) {api_version: str?, application: str?, created: int(unix-time), description: str?, enabled_events: [str], id: str, livemode: bool, metadata: map, object: str, secret: str, status: str, url: str} # Successful response.

@endpoint POST /v1/webhook_endpoints/{webhook_endpoint}
@desc Update a webhook endpoint
@required {webhook_endpoint: str}
@returns(200) {api_version: str?, application: str?, created: int(unix-time), description: str?, enabled_events: [str], id: str, livemode: bool, metadata: map, object: str, secret: str, status: str, url: str} # Successful response.

@endgroup

@end
