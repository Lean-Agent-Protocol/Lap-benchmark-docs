@lap v0.3
# Machine-readable API spec. Each @endpoint block is one API call.
@api GitHub v3 REST API
@base https://api.github.com
@version 1.1.4
@endpoints 1080
@hint download_for_search
@toc root(1), advisories(2), app(13), app-manifests(1), applications(5), apps(1), assignments(3), classrooms(3), codes_of_conduct(2), credentials(1), emojis(1), enterprises(31), events(1), feeds(1), gists(19), gitignore(2), installation(2), issues(1), licenses(2), markdown(2), marketplace_listing(6), meta(1), networks(1), notifications(8), octocat(1), organizations(15), orgs(310), rate_limit(1), repos(473), repositories(1), search(7), teams(16), user(94), users(50), versions(1), zen(1)

@group root
@endpoint GET /
@desc GitHub API Root
@returns(200) {current_user_url: str(uri-template), current_user_authorizations_html_url: str(uri-template), authorizations_url: str(uri-template), code_search_url: str(uri-template), commit_search_url: str(uri-template), emails_url: str(uri-template), emojis_url: str(uri-template), events_url: str(uri-template), feeds_url: str(uri-template), followers_url: str(uri-template), following_url: str(uri-template), gists_url: str(uri-template), hub_url: str(uri-template), issue_search_url: str(uri-template), issues_url: str(uri-template), keys_url: str(uri-template), label_search_url: str(uri-template), notifications_url: str(uri-template), organization_url: str(uri-template), organization_repositories_url: str(uri-template), organization_teams_url: str(uri-template), public_gists_url: str(uri-template), rate_limit_url: str(uri-template), repository_url: str(uri-template), repository_search_url: str(uri-template), current_user_repositories_url: str(uri-template), starred_url: str(uri-template), starred_gists_url: str(uri-template), topic_search_url: str(uri-template), user_url: str(uri-template), user_organizations_url: str(uri-template), user_repositories_url: str(uri-template), user_search_url: str(uri-template)} # Response

@endgroup

@group advisories
@endpoint GET /advisories
@desc List global security advisories
@optional {ghsa_id: str # If specified, only advisories with this GHSA (GitHub Security Advisory) identifier will be returned., type: str(reviewed/malware/unreviewed)=reviewed # If specified, only advisories of this type will be returned. By default, a request with no other parameters defined will only return reviewed advisories that are not malware., cve_id: str # If specified, only advisories with this CVE (Common Vulnerabilities and Exposures) identifier will be returned., ecosystem: str # If specified, only advisories for these ecosystems will be returned., severity: str(unknown/low/medium/high/critical) # If specified, only advisories with these severities will be returned., cwes: any # If specified, only advisories with these Common Weakness Enumerations (CWEs) will be returned.  Example: `cwes=79,284,22` or `cwes[]=79&cwes[]=284&cwes[]=22`, is_withdrawn: bool # Whether to only return advisories that have been withdrawn., affects: any # If specified, only return advisories that affect any of `package` or `package@version`. A maximum of 1000 packages can be specified. If the query parameter causes the URL to exceed the maximum URL length supported by your client, you must specify fewer packages.  Example: `affects=package1,package2@1.0.0,package3@2.0.0` or `affects[]=package1&affects[]=package2@1.0.0`, published: str # If specified, only return advisories that were published on a date or date range.  For more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).", updated: str # If specified, only return advisories that were updated on a date or date range.  For more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).", modified: str # If specified, only show advisories that were updated or published on a date or date range.  For more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).", epss_percentage: str # If specified, only return advisories that have an EPSS percentage score that matches the provided value. The EPSS percentage represents the likelihood of a CVE being exploited., epss_percentile: str # If specified, only return advisories that have an EPSS percentile score that matches the provided value. The EPSS percentile represents the relative rank of the CVE's likelihood of being exploited compared to other CVEs., before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", direction: str(asc/desc)=desc # The direction to sort the results by., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", sort: str(updated/published/epss_percentage/epss_percentile)=published # The property to sort the results by.}
@returns(200) Response
@errors {429: Too many requests, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /advisories/{ghsa_id}
@desc Get a global security advisory
@required {ghsa_id: str # The GHSA (GitHub Security Advisory) identifier of the advisory.}
@returns(200) {ghsa_id: str, cve_id: str?, url: str, html_url: str(uri), repository_advisory_url: str(uri)?, summary: str, description: str?, type: str, severity: str, source_code_location: str(uri)?, identifiers: [map]?, references: [str]?, published_at: str(date-time), updated_at: str(date-time), github_reviewed_at: str(date-time)?, nvd_published_at: str(date-time)?, withdrawn_at: str(date-time)?, vulnerabilities: [map]?, cvss: map?{vector_string: str?, score: num?}, cvss_severities: map?{cvss_v3: map?{vector_string: str?, score: num?}, cvss_v4: map?{vector_string: str?, score: num?}}, epss: map?{percentage: num, percentile: num}, cwes: [map]?, credits: [map]?} # Response
@errors {404: Resource not found}

@endgroup

@group app
@endpoint GET /app
@desc Get the authenticated app
@returns(200) {id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int} # Response

@endgroup

@group app-manifests
@endpoint POST /app-manifests/{code}/conversions
@desc Create a GitHub App from a manifest
@required {code: str}
@returns(201) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endgroup

@group app
@endpoint GET /app/hook/config
@desc Get a webhook configuration for an app
@returns(200) {url: str(uri), content_type: str, secret: str, insecure_ssl: any} # Response

@endpoint PATCH /app/hook/config
@desc Update a webhook configuration for an app
@optional {url: str(uri) # The URL to which the payloads will be delivered., content_type: str # The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`., secret: str # If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers)., insecure_ssl: any}
@returns(200) {url: str(uri), content_type: str, secret: str, insecure_ssl: any} # Response
@example_request {"content_type":"json","insecure_ssl":"0","secret":"********","url":"https://example.com/webhook"}

@endpoint GET /app/hook/deliveries
@desc List deliveries for an app webhook
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", cursor: str # Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.}
@returns(200) Response
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /app/hook/deliveries/{delivery_id}
@desc Get a delivery for an app webhook
@required {delivery_id: int}
@returns(200) {id: int, guid: str, delivered_at: str(date-time), redelivery: bool, duration: num, status: str, status_code: int, event: str, action: str?, installation_id: int?, repository_id: int?, throttled_at: str(date-time)?, url: str, request: map{headers: map?, payload: map?}, response: map{headers: map?, payload: str?}} # Response
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}

@endpoint POST /app/hook/deliveries/{delivery_id}/attempts
@desc Redeliver a delivery for an app webhook
@required {delivery_id: int}
@returns(202) Accepted
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /app/installation-requests
@desc List installation requests for the authenticated app
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) List of integration installation requests
@errors {304: Not modified, 401: Requires authentication}

@endpoint GET /app/installations
@desc List installations for the authenticated app
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., outdated: str}
@returns(200) The permissions the installation has are included under the `permissions` key.

@endpoint GET /app/installations/{installation_id}
@desc Get an installation for the authenticated app
@required {installation_id: int # The unique identifier of the installation.}
@returns(200) {id: int, account: any?, repository_selection: str, access_tokens_url: str(uri), repositories_url: str(uri), html_url: str(uri), app_id: int, client_id: str, target_id: int, target_type: str, permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str}, events: [str], created_at: str(date-time), updated_at: str(date-time), single_file_name: str?, has_multiple_single_files: bool, single_file_paths: [str], app_slug: str, suspended_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, suspended_at: str(date-time)?, contact_email: str?} # Response
@errors {404: Resource not found}

@endpoint DELETE /app/installations/{installation_id}
@desc Delete an installation for the authenticated app
@required {installation_id: int # The unique identifier of the installation.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint POST /app/installations/{installation_id}/access_tokens
@desc Create an installation access token for an app
@required {installation_id: int # The unique identifier of the installation.}
@optional {repositories: [str] # List of repository names that the token should have access to, repository_ids: [int] # List of repository IDs that the token should have access to, permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str} # The permissions granted to the user access token.}
@returns(201) {token: str, expires_at: str, permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str}, repository_selection: str, repositories: [map], single_file: str, has_multiple_single_files: bool, single_file_paths: [str]} # Response
@errors {403: Forbidden, 401: Requires authentication, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"repositories":["Hello-World"],"permissions":{"issues":"write","contents":"read"}}

@endpoint PUT /app/installations/{installation_id}/suspended
@desc Suspend an app installation
@required {installation_id: int # The unique identifier of the installation.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint DELETE /app/installations/{installation_id}/suspended
@desc Unsuspend an app installation
@required {installation_id: int # The unique identifier of the installation.}
@returns(204) Response
@errors {404: Resource not found}

@endgroup

@group applications
@endpoint DELETE /applications/{client_id}/grant
@desc Delete an app authorization
@required {client_id: str # The client ID of the GitHub app., access_token: str # The OAuth access token used to authenticate to the GitHub API.}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"access_token":"e72e16c7e42f292c6912e7710c838347ae178b4a"}

@endpoint POST /applications/{client_id}/token
@desc Check a token
@required {client_id: str # The client ID of the GitHub app., access_token: str # The access_token of the OAuth or GitHub application.}
@returns(200) {id: int(int64), url: str(uri), scopes: [str]?, token: str, token_last_eight: str?, hashed_token: str?, app: map{client_id: str, name: str, url: str(uri)}, note: str?, note_url: str(uri)?, updated_at: str(date-time), created_at: str(date-time), fingerprint: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, installation: map?{permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str}, repository_selection: str, single_file_name: str?, has_multiple_single_files: bool, single_file_paths: [str], repositories_url: str(uri), account: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, expires_at: str(date-time)?} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"access_token":"e72e16c7e42f292c6912e7710c838347ae178b4a"}

@endpoint PATCH /applications/{client_id}/token
@desc Reset a token
@required {client_id: str # The client ID of the GitHub app., access_token: str # The access_token of the OAuth or GitHub application.}
@returns(200) {id: int(int64), url: str(uri), scopes: [str]?, token: str, token_last_eight: str?, hashed_token: str?, app: map{client_id: str, name: str, url: str(uri)}, note: str?, note_url: str(uri)?, updated_at: str(date-time), created_at: str(date-time), fingerprint: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, installation: map?{permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str}, repository_selection: str, single_file_name: str?, has_multiple_single_files: bool, single_file_paths: [str], repositories_url: str(uri), account: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, expires_at: str(date-time)?} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"access_token":"e72e16c7e42f292c6912e7710c838347ae178b4a"}

@endpoint DELETE /applications/{client_id}/token
@desc Delete an app token
@required {client_id: str # The client ID of the GitHub app., access_token: str # The OAuth access token used to authenticate to the GitHub API.}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"access_token":"e72e16c7e42f292c6912e7710c838347ae178b4a"}

@endpoint POST /applications/{client_id}/token/scoped
@desc Create a scoped access token
@required {client_id: str # The client ID of the GitHub app., access_token: str # The access token used to authenticate to the GitHub API.}
@optional {target: str # The name of the user or organization to scope the user access token to. **Required** unless `target_id` is specified., target_id: int # The ID of the user or organization to scope the user access token to. **Required** unless `target` is specified., repositories: [str] # The list of repository names to scope the user access token to. `repositories` may not be specified if `repository_ids` is specified., repository_ids: [int] # The list of repository IDs to scope the user access token to. `repository_ids` may not be specified if `repositories` is specified., permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str} # The permissions granted to the user access token.}
@returns(200) {id: int(int64), url: str(uri), scopes: [str]?, token: str, token_last_eight: str?, hashed_token: str?, app: map{client_id: str, name: str, url: str(uri)}, note: str?, note_url: str(uri)?, updated_at: str(date-time), created_at: str(date-time), fingerprint: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, installation: map?{permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str}, repository_selection: str, single_file_name: str?, has_multiple_single_files: bool, single_file_paths: [str], repositories_url: str(uri), account: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, expires_at: str(date-time)?} # Response
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"access_token":"e72e16c7e42f292c6912e7710c838347ae178b4a","target":"octocat","permissions":{"metadata":"read","issues":"write","contents":"read"}}

@endgroup

@group apps
@endpoint GET /apps/{app_slug}
@desc Get an app
@required {app_slug: str}
@returns(200) {id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int} # Response
@errors {403: Forbidden, 404: Resource not found}

@endgroup

@group assignments
@endpoint GET /assignments/{assignment_id}
@desc Get an assignment
@required {assignment_id: int # The unique identifier of the classroom assignment.}
@returns(200) {id: int, public_repo: bool, title: str, type: str, invite_link: str, invitations_enabled: bool, slug: str, students_are_repo_admins: bool, feedback_pull_requests_enabled: bool, max_teams: int?, max_members: int?, editor: str, accepted: int, submitted: int, passing: int, language: str, deadline: str(date-time)?, starter_code_repository: map{id: int, full_name: str, html_url: str(uri), node_id: str, private: bool, default_branch: str}, classroom: map{id: int, name: str, archived: bool, organization: map{id: int, login: str, node_id: str, html_url: str(uri), name: str?, avatar_url: str}, url: str}} # Response
@errors {404: Resource not found}

@endpoint GET /assignments/{assignment_id}/accepted_assignments
@desc List accepted assignments for an assignment
@required {assignment_id: int # The unique identifier of the classroom assignment.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /assignments/{assignment_id}/grades
@desc Get assignment grades
@required {assignment_id: int # The unique identifier of the classroom assignment.}
@returns(200) Response
@errors {404: Resource not found}

@endgroup

@group classrooms
@endpoint GET /classrooms
@desc List classrooms
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /classrooms/{classroom_id}
@desc Get a classroom
@required {classroom_id: int # The unique identifier of the classroom.}
@returns(200) {id: int, name: str, archived: bool, organization: map{id: int, login: str, node_id: str, html_url: str(uri), name: str?, avatar_url: str}, url: str} # Response
@errors {404: Resource not found}

@endpoint GET /classrooms/{classroom_id}/assignments
@desc List assignments for a classroom
@required {classroom_id: int # The unique identifier of the classroom.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endgroup

@group codes_of_conduct
@endpoint GET /codes_of_conduct
@desc Get all codes of conduct
@returns(200) Response
@errors {304: Not modified}

@endpoint GET /codes_of_conduct/{key}
@desc Get a code of conduct
@required {key: str}
@returns(200) {key: str, name: str, url: str(uri), body: str, html_url: str(uri)?} # Response
@errors {404: Resource not found, 304: Not modified}

@endgroup

@group credentials
@endpoint POST /credentials/revoke
@desc Revoke a list of credentials
@required {credentials: [str] # A list of credentials to be revoked, up to 1000 per request.}
@returns(202) Accepted
@errors {422: Validation failed, or the endpoint has been spammed., 500: Internal Error}
@example_request {"credentials":["ghp_1234567890abcdef1234567890abcdef12345678","ghp_abcdef1234567890abcdef1234567890abcdef12"]}

@endgroup

@group emojis
@endpoint GET /emojis
@desc Get emojis
@returns(200) Response
@errors {304: Not modified}

@endgroup

@group enterprises
@endpoint GET /enterprises/{enterprise}/actions/cache/retention-limit
@desc Get GitHub Actions cache retention limit for an enterprise
@required {enterprise: str # The slug version of the enterprise name.}
@returns(200) {max_cache_retention_days: int} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /enterprises/{enterprise}/actions/cache/retention-limit
@desc Set GitHub Actions cache retention limit for an enterprise
@required {enterprise: str # The slug version of the enterprise name.}
@optional {max_cache_retention_days: int # For repositories & organizations in an enterprise, the maximum duration, in days, for which caches in a repository may be retained.}
@returns(204) Response
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found}
@example_request {"max_cache_retention_days":80}

@endpoint GET /enterprises/{enterprise}/actions/cache/storage-limit
@desc Get GitHub Actions cache storage limit for an enterprise
@required {enterprise: str # The slug version of the enterprise name.}
@returns(200) {max_cache_size_gb: int} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /enterprises/{enterprise}/actions/cache/storage-limit
@desc Set GitHub Actions cache storage limit for an enterprise
@required {enterprise: str # The slug version of the enterprise name.}
@optional {max_cache_size_gb: int # For repositories & organizations in an enterprise, the maximum size limit for the sum of all caches in a repository, in gigabytes.}
@returns(204) Response
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found}
@example_request {"max_cache_size_gb":150}

@endpoint GET /enterprises/{enterprise}/code-security/configurations
@desc Get code security configurations for an enterprise
@required {enterprise: str # The slug version of the enterprise name.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint POST /enterprises/{enterprise}/code-security/configurations
@desc Create a code security configuration for an enterprise
@required {enterprise: str # The slug version of the enterprise name., name: str # The name of the code security configuration. Must be unique within the enterprise., description: str # A description of the code security configuration}
@optional {advanced_security: str(enabled/disabled/code_security/secret_protection)=disabled # The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.  > [!WARNING] > `code_security` and `secret_protection` are deprecated values for this field. Prefer the individual `code_security` and `secret_protection` fields to set the status of these features., code_security: str(enabled/disabled/not_set) # The enablement status of GitHub Code Security features., dependency_graph: str(enabled/disabled/not_set)=enabled # The enablement status of Dependency Graph, dependency_graph_autosubmit_action: str(enabled/disabled/not_set)=disabled # The enablement status of Automatic dependency submission, dependency_graph_autosubmit_action_options: map{labeled_runners: bool} # Feature options for Automatic dependency submission, dependabot_alerts: str(enabled/disabled/not_set)=disabled # The enablement status of Dependabot alerts, dependabot_security_updates: str(enabled/disabled/not_set)=disabled # The enablement status of Dependabot security updates, code_scanning_options: map{allow_advanced: bool} # Security Configuration feature options for code scanning, code_scanning_default_setup: str(enabled/disabled/not_set)=disabled # The enablement status of code scanning default setup, code_scanning_default_setup_options: map{runner_type: str, runner_label: str} # Feature options for code scanning default setup, code_scanning_delegated_alert_dismissal: str(enabled/disabled/not_set)=disabled # The enablement status of code scanning delegated alert dismissal, secret_protection: str(enabled/disabled/not_set) # The enablement status of GitHub Secret Protection features., secret_scanning: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning, secret_scanning_push_protection: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning push protection, secret_scanning_validity_checks: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning validity checks, secret_scanning_non_provider_patterns: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning non provider patterns, secret_scanning_generic_secrets: str(enabled/disabled/not_set)=disabled # The enablement status of Copilot secret scanning, secret_scanning_delegated_alert_dismissal: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning delegated alert dismissal, private_vulnerability_reporting: str(enabled/disabled/not_set)=disabled # The enablement status of private vulnerability reporting, enforcement: str(enforced/unenforced)=enforced # The enforcement status for a security configuration}
@returns(201) {id: int, name: str, target_type: str, description: str, advanced_security: str, dependency_graph: str, dependency_graph_autosubmit_action: str, dependency_graph_autosubmit_action_options: map{labeled_runners: bool}, dependabot_alerts: str, dependabot_security_updates: str, dependabot_delegated_alert_dismissal: str?, code_scanning_options: map?{allow_advanced: bool?}, code_scanning_default_setup: str, code_scanning_default_setup_options: map?{runner_type: str?, runner_label: str?}, code_scanning_delegated_alert_dismissal: str, secret_scanning: str, secret_scanning_push_protection: str, secret_scanning_delegated_bypass: str, secret_scanning_delegated_bypass_options: map{reviewers: [map]}, secret_scanning_validity_checks: str, secret_scanning_non_provider_patterns: str, secret_scanning_generic_secrets: str, secret_scanning_delegated_alert_dismissal: str, private_vulnerability_reporting: str, enforcement: str, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time)} # Successfully created code security configuration
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found}
@example_request {"name":"High rish settings","description":"This is a code security configuration for octo-enterprise","advanced_security":"enabled","dependabot_alerts":"enabled","dependabot_security_updates":"not_set","secret_scanning":"enabled"}

@endpoint GET /enterprises/{enterprise}/code-security/configurations/defaults
@desc Get default code security configurations for an enterprise
@required {enterprise: str # The slug version of the enterprise name.}
@returns(200) Response

@endpoint GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}
@desc Retrieve a code security configuration of an enterprise
@required {enterprise: str # The slug version of the enterprise name., configuration_id: int # The unique identifier of the code security configuration.}
@returns(200) {id: int, name: str, target_type: str, description: str, advanced_security: str, dependency_graph: str, dependency_graph_autosubmit_action: str, dependency_graph_autosubmit_action_options: map{labeled_runners: bool}, dependabot_alerts: str, dependabot_security_updates: str, dependabot_delegated_alert_dismissal: str?, code_scanning_options: map?{allow_advanced: bool?}, code_scanning_default_setup: str, code_scanning_default_setup_options: map?{runner_type: str?, runner_label: str?}, code_scanning_delegated_alert_dismissal: str, secret_scanning: str, secret_scanning_push_protection: str, secret_scanning_delegated_bypass: str, secret_scanning_delegated_bypass_options: map{reviewers: [map]}, secret_scanning_validity_checks: str, secret_scanning_non_provider_patterns: str, secret_scanning_generic_secrets: str, secret_scanning_delegated_alert_dismissal: str, private_vulnerability_reporting: str, enforcement: str, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {304: Not modified, 403: Forbidden, 404: Resource not found}

@endpoint PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}
@desc Update a custom code security configuration for an enterprise
@required {enterprise: str # The slug version of the enterprise name., configuration_id: int # The unique identifier of the code security configuration.}
@optional {name: str # The name of the code security configuration. Must be unique across the enterprise., description: str # A description of the code security configuration, advanced_security: str(enabled/disabled/code_security/secret_protection) # The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.  > [!WARNING] > `code_security` and `secret_protection` are deprecated values for this field. Prefer the individual `code_security` and `secret_protection` fields to set the status of these features., code_security: str(enabled/disabled/not_set) # The enablement status of GitHub Code Security features., dependency_graph: str(enabled/disabled/not_set) # The enablement status of Dependency Graph, dependency_graph_autosubmit_action: str(enabled/disabled/not_set) # The enablement status of Automatic dependency submission, dependency_graph_autosubmit_action_options: map{labeled_runners: bool} # Feature options for Automatic dependency submission, dependabot_alerts: str(enabled/disabled/not_set) # The enablement status of Dependabot alerts, dependabot_security_updates: str(enabled/disabled/not_set) # The enablement status of Dependabot security updates, code_scanning_default_setup: str(enabled/disabled/not_set) # The enablement status of code scanning default setup, code_scanning_default_setup_options: map{runner_type: str, runner_label: str} # Feature options for code scanning default setup, code_scanning_options: map{allow_advanced: bool} # Security Configuration feature options for code scanning, code_scanning_delegated_alert_dismissal: str(enabled/disabled/not_set)=disabled # The enablement status of code scanning delegated alert dismissal, secret_protection: str(enabled/disabled/not_set) # The enablement status of GitHub Secret Protection features., secret_scanning: str(enabled/disabled/not_set) # The enablement status of secret scanning, secret_scanning_push_protection: str(enabled/disabled/not_set) # The enablement status of secret scanning push protection, secret_scanning_validity_checks: str(enabled/disabled/not_set) # The enablement status of secret scanning validity checks, secret_scanning_non_provider_patterns: str(enabled/disabled/not_set) # The enablement status of secret scanning non-provider patterns, secret_scanning_generic_secrets: str(enabled/disabled/not_set)=disabled # The enablement status of Copilot secret scanning, secret_scanning_delegated_alert_dismissal: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning delegated alert dismissal, private_vulnerability_reporting: str(enabled/disabled/not_set) # The enablement status of private vulnerability reporting, enforcement: str(enforced/unenforced) # The enforcement status for a security configuration}
@returns(200) {id: int, name: str, target_type: str, description: str, advanced_security: str, dependency_graph: str, dependency_graph_autosubmit_action: str, dependency_graph_autosubmit_action_options: map{labeled_runners: bool}, dependabot_alerts: str, dependabot_security_updates: str, dependabot_delegated_alert_dismissal: str?, code_scanning_options: map?{allow_advanced: bool?}, code_scanning_default_setup: str, code_scanning_default_setup_options: map?{runner_type: str?, runner_label: str?}, code_scanning_delegated_alert_dismissal: str, secret_scanning: str, secret_scanning_push_protection: str, secret_scanning_delegated_bypass: str, secret_scanning_delegated_bypass_options: map{reviewers: [map]}, secret_scanning_validity_checks: str, secret_scanning_non_provider_patterns: str, secret_scanning_generic_secrets: str, secret_scanning_delegated_alert_dismissal: str, private_vulnerability_reporting: str, enforcement: str, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {304: Not modified, 403: Forbidden, 404: Resource not found, 409: Conflict}
@example_request {"name":"octo-enterprise recommended settings v2","secret_scanning":"disabled","code_scanning_default_setup":"enabled"}

@endpoint DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}
@desc Delete a code security configuration for an enterprise
@required {enterprise: str # The slug version of the enterprise name., configuration_id: int # The unique identifier of the code security configuration.}
@returns(204) A header with no content is returned.
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found, 409: Conflict}

@endpoint POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach
@desc Attach an enterprise configuration to repositories
@required {enterprise: str # The slug version of the enterprise name., configuration_id: int # The unique identifier of the code security configuration., scope: str(all/all_without_configurations) # The type of repositories to attach the configuration to.}
@returns(202) Accepted
@errors {403: Forbidden, 404: Resource not found, 409: Conflict}
@example_request {"scope":"all"}

@endpoint PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults
@desc Set a code security configuration as a default for an enterprise
@required {enterprise: str # The slug version of the enterprise name., configuration_id: int # The unique identifier of the code security configuration.}
@optional {default_for_new_repos: str(all/none/private_and_internal/public) # Specify which types of repository this security configuration should be applied to by default.}
@returns(200) {default_for_new_repos: str, configuration: map{id: int, name: str, target_type: str, description: str, advanced_security: str, dependency_graph: str, dependency_graph_autosubmit_action: str, dependency_graph_autosubmit_action_options: map{labeled_runners: bool}, dependabot_alerts: str, dependabot_security_updates: str, dependabot_delegated_alert_dismissal: str?, code_scanning_options: map?{allow_advanced: bool?}, code_scanning_default_setup: str, code_scanning_default_setup_options: map?{runner_type: str?, runner_label: str?}, code_scanning_delegated_alert_dismissal: str, secret_scanning: str, secret_scanning_push_protection: str, secret_scanning_delegated_bypass: str, secret_scanning_delegated_bypass_options: map{reviewers: [map]}, secret_scanning_validity_checks: str, secret_scanning_non_provider_patterns: str, secret_scanning_generic_secrets: str, secret_scanning_delegated_alert_dismissal: str, private_vulnerability_reporting: str, enforcement: str, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time)}} # Default successfully changed.
@errors {403: Forbidden, 404: Resource not found}
@example_request {"default_for_new_repos":"all"}

@endpoint GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories
@desc Get repositories associated with an enterprise code security configuration
@required {enterprise: str # The slug version of the enterprise name., configuration_id: int # The unique identifier of the code security configuration.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", status: str=all # A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned.  Can be: `all`, `attached`, `attaching`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`}
@returns(200) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint GET /enterprises/{enterprise}/dependabot/alerts
@desc List Dependabot alerts for an enterprise
@required {enterprise: str # The slug version of the enterprise name.}
@optional {state: str # A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`, severity: str # A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`, ecosystem: str # A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`, package: str # A comma-separated list of package names. If specified, only alerts for these packages will be returned., epss_percentage: str # CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as: - An exact number (`n`) - Comparators such as `>n`, `<n`, `>=n`, `<=n` - A range like `n..n`, where `n` is a number from 0.0 to 1.0  Filters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned., has: any # Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned. Multiple `has` filters can be passed to filter for alerts that have all of the values. Currently, only `patch` is supported., scope: str(development/runtime) # The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned., sort: str(created/updated/epss_percentage)=created # The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed. `epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage., direction: str(asc/desc)=desc # The direction to sort the results by., before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /enterprises/{enterprise}/teams
@desc List enterprise teams
@required {enterprise: str # The slug version of the enterprise name.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {403: Forbidden}

@endpoint POST /enterprises/{enterprise}/teams
@desc Create an enterprise team
@required {enterprise: str # The slug version of the enterprise name., name: str # The name of the team.}
@optional {description: str # A description of the team., sync_to_organizations: str(all/disabled)=disabled # Retired: this field is no longer supported. Whether the enterprise team should be reflected in each organization. This value cannot be set., organization_selection_type: str(disabled/selected/all)=disabled # Specifies which organizations in the enterprise should have access to this team. Can be one of `disabled`, `selected`, or `all`. `disabled`: The team is not assigned to any organizations. This is the default when you create a new team. `selected`: The team is assigned to specific organizations. You can then use the [add organization assignments API](https://docs.github.com/rest/enterprise-teams/enterprise-team-organizations#add-organization-assignments) endpoint. `all`: The team is assigned to all current and future organizations in the enterprise., group_id: str # The ID of the IdP group to assign team membership with. You can get this value from the [REST API endpoints for SCIM](https://docs.github.com/rest/scim#list-provisioned-scim-groups-for-an-enterprise).}
@returns(201) {id: int(int64), name: str, description: str, slug: str, url: str(uri), sync_to_organizations: str, organization_selection_type: str, group_id: str?, group_name: str?, html_url: str(uri), members_url: str, created_at: str(date-time), updated_at: str(date-time)} # Response
@example_request {"name":"Justice League","description":"A great team.","group_id":"62ab9291-fae2-468e-974b-7e45096d5021"}

@endpoint GET /enterprises/{enterprise}/teams/{enterprise-team}/memberships
@desc List members in an enterprise team
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint POST /enterprises/{enterprise}/teams/{enterprise-team}/memberships/add
@desc Bulk add team members
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., usernames: [str] # The GitHub user handles to add to the team.}
@returns(200) Successfully added team members.
@example_request {"usernames":["monalisa","octocat"]}

@endpoint POST /enterprises/{enterprise}/teams/{enterprise-team}/memberships/remove
@desc Bulk remove team members
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., usernames: [str] # The GitHub user handles to be removed from the team.}
@returns(200) Successfully removed team members.
@example_request {"usernames":["monalisa","octocat"]}

@endpoint GET /enterprises/{enterprise}/teams/{enterprise-team}/memberships/{username}
@desc Get enterprise team membership
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., username: str # The handle for the GitHub user account.}
@returns(200) {name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str} # User is a member of the enterprise team.

@endpoint PUT /enterprises/{enterprise}/teams/{enterprise-team}/memberships/{username}
@desc Add team member
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., username: str # The handle for the GitHub user account.}
@returns(201) {name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str} # Successfully added team member

@endpoint DELETE /enterprises/{enterprise}/teams/{enterprise-team}/memberships/{username}
@desc Remove team membership
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {403: Forbidden}

@endpoint GET /enterprises/{enterprise}/teams/{enterprise-team}/organizations
@desc Get organization assignments
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) An array of organizations the team is assigned to

@endpoint POST /enterprises/{enterprise}/teams/{enterprise-team}/organizations/add
@desc Add organization assignments
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., organization_slugs: [str] # Organization slug to assign the team to.}
@returns(200) Successfully assigned the enterprise team to organizations.
@example_request {"organization_slugs":["github"]}

@endpoint POST /enterprises/{enterprise}/teams/{enterprise-team}/organizations/remove
@desc Remove organization assignments
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., organization_slugs: [str] # Organization slug to unassign the team from.}
@returns(204) Successfully unassigned the enterprise team from organizations.
@example_request {"organization_slugs":["github"]}

@endpoint GET /enterprises/{enterprise}/teams/{enterprise-team}/organizations/{org}
@desc Get organization assignment
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., org: str # The organization name. The name is not case sensitive.}
@returns(200) {login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?} # The team is assigned to the organization
@errors {404: The team is not assigned to the organization}

@endpoint PUT /enterprises/{enterprise}/teams/{enterprise-team}/organizations/{org}
@desc Add an organization assignment
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., org: str # The organization name. The name is not case sensitive.}
@returns(201) {login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?} # Successfully assigned the enterprise team to the organization.

@endpoint DELETE /enterprises/{enterprise}/teams/{enterprise-team}/organizations/{org}
@desc Delete an organization assignment
@required {enterprise: str # The slug version of the enterprise name., enterprise-team: str # The slug version of the enterprise team name. You can also substitute this value with the enterprise team id., org: str # The organization name. The name is not case sensitive.}
@returns(204) Successfully unassigned the enterprise team from the organization.

@endpoint GET /enterprises/{enterprise}/teams/{team_slug}
@desc Get an enterprise team
@required {enterprise: str # The slug version of the enterprise name., team_slug: str # The slug of the team name.}
@returns(200) {id: int(int64), name: str, description: str, slug: str, url: str(uri), sync_to_organizations: str, organization_selection_type: str, group_id: str?, group_name: str?, html_url: str(uri), members_url: str, created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {403: Forbidden}

@endpoint PATCH /enterprises/{enterprise}/teams/{team_slug}
@desc Update an enterprise team
@required {enterprise: str # The slug version of the enterprise name., team_slug: str # The slug of the team name.}
@optional {name: str # A new name for the team., description: str # A new description for the team., sync_to_organizations: str(all/disabled)=disabled # Retired: this field is no longer supported. Whether the enterprise team should be reflected in each organization. This value cannot be changed., organization_selection_type: str(disabled/selected/all)=disabled # Specifies which organizations in the enterprise should have access to this team. Can be one of `disabled`, `selected`, or `all`. `disabled`: The team is not assigned to any organizations. This is the default when you create a new team. `selected`: The team is assigned to specific organizations. You can then use the [add organization assignments API](https://docs.github.com/rest/enterprise-teams/enterprise-team-organizations#add-organization-assignments). `all`: The team is assigned to all current and future organizations in the enterprise., group_id: str # The ID of the IdP group to assign team membership with. The new IdP group will replace the existing one, or replace existing direct members if the team isn't currently linked to an IdP group.}
@returns(200) {id: int(int64), name: str, description: str, slug: str, url: str(uri), sync_to_organizations: str, organization_selection_type: str, group_id: str?, group_name: str?, html_url: str(uri), members_url: str, created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {403: Forbidden}
@example_request {"name":"Justice League","description":"A great team.","group_id":"62ab9291-fae2-468e-974b-7e45096d5021"}

@endpoint DELETE /enterprises/{enterprise}/teams/{team_slug}
@desc Delete an enterprise team
@required {enterprise: str # The slug version of the enterprise name., team_slug: str # The slug of the team name.}
@returns(204) Response
@errors {403: Forbidden}

@endgroup

@group events
@endpoint GET /events
@desc List public events
@optional {per_page: int=15 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 503: Service unavailable}

@endgroup

@group feeds
@endpoint GET /feeds
@desc Get feeds
@returns(200) {timeline_url: str, user_url: str, current_user_public_url: str, current_user_url: str, current_user_actor_url: str, current_user_organization_url: str, current_user_organization_urls: [str(uri)], security_advisories_url: str, repository_discussions_url: str, repository_discussions_category_url: str, _links: map{timeline: map{href: str, type: str}, user: map{href: str, type: str}, security_advisories: map{href: str, type: str}, current_user: map{href: str, type: str}, current_user_public: map{href: str, type: str}, current_user_actor: map{href: str, type: str}, current_user_organization: map{href: str, type: str}, current_user_organizations: [map], repository_discussions: map{href: str, type: str}, repository_discussions_category: map{href: str, type: str}}} # Response

@endgroup

@group gists
@endpoint GET /gists
@desc List gists for the authenticated user
@optional {since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden}

@endpoint POST /gists
@desc Create a gist
@required {files: map # Names and content for the files that make up the gist}
@optional {description: str # Description of the gist, public: any}
@returns(201) {forks: [map]?, history: [map]?, fork_of: map?{url: str(uri), forks_url: str(uri), commits_url: str(uri), id: str, node_id: str, git_pull_url: str(uri), git_push_url: str(uri), html_url: str(uri), files: map, public: bool, created_at: str(date-time), updated_at: str(date-time), description: str?, comments: int, comments_enabled: bool, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, comments_url: str(uri), owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, truncated: bool, forks: [any], history: [any]}, url: str, forks_url: str, commits_url: str, id: str, node_id: str, git_pull_url: str, git_push_url: str, html_url: str, files: map, public: bool, created_at: str, updated_at: str, description: str?, comments: int, comments_enabled: bool, user: str?, comments_url: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, truncated: bool} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 404: Resource not found, 403: Forbidden}
@example_request {"description":"Example of a gist","public":false,"files":{"README.md":{"content":"Hello World"}}}

@endpoint GET /gists/public
@desc List public gists
@optional {since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 403: Forbidden}

@endpoint GET /gists/starred
@desc List starred gists
@optional {since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {401: Requires authentication, 304: Not modified, 403: Forbidden}

@endpoint GET /gists/{gist_id}
@desc Get a gist
@required {gist_id: str # The unique identifier of the gist.}
@returns(200) {forks: [map]?, history: [map]?, fork_of: map?{url: str(uri), forks_url: str(uri), commits_url: str(uri), id: str, node_id: str, git_pull_url: str(uri), git_push_url: str(uri), html_url: str(uri), files: map, public: bool, created_at: str(date-time), updated_at: str(date-time), description: str?, comments: int, comments_enabled: bool, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, comments_url: str(uri), owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, truncated: bool, forks: [any], history: [any]}, url: str, forks_url: str, commits_url: str, id: str, node_id: str, git_pull_url: str, git_push_url: str, html_url: str, files: map, public: bool, created_at: str, updated_at: str, description: str?, comments: int, comments_enabled: bool, user: str?, comments_url: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, truncated: bool} # Response
@errors {403: Forbidden Gist, 404: Resource not found, 304: Not modified}

@endpoint PATCH /gists/{gist_id}
@desc Update a gist
@required {gist_id: str # The unique identifier of the gist.}
@optional {description: str # The description of the gist., files: map # The gist files to be updated, renamed, or deleted. Each `key` must match the current filename (including extension) of the targeted gist file. For example: `hello.py`.  To delete a file, set the whole file to null. For example: `hello.py : null`. The file will also be deleted if the specified object does not contain at least one of `content` or `filename`.}
@returns(200) {forks: [map]?, history: [map]?, fork_of: map?{url: str(uri), forks_url: str(uri), commits_url: str(uri), id: str, node_id: str, git_pull_url: str(uri), git_push_url: str(uri), html_url: str(uri), files: map, public: bool, created_at: str(date-time), updated_at: str(date-time), description: str?, comments: int, comments_enabled: bool, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, comments_url: str(uri), owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, truncated: bool, forks: [any], history: [any]}, url: str, forks_url: str, commits_url: str, id: str, node_id: str, git_pull_url: str, git_push_url: str, html_url: str, files: map, public: bool, created_at: str, updated_at: str, description: str?, comments: int, comments_enabled: bool, user: str?, comments_url: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, truncated: bool} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"description":"An updated gist description","files":{"README.md":{"content":"Hello World from GitHub"}}}

@endpoint DELETE /gists/{gist_id}
@desc Delete a gist
@required {gist_id: str # The unique identifier of the gist.}
@returns(204) Response
@errors {404: Resource not found, 304: Not modified, 403: Forbidden}

@endpoint GET /gists/{gist_id}/comments
@desc List gist comments
@required {gist_id: str # The unique identifier of the gist.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden}

@endpoint POST /gists/{gist_id}/comments
@desc Create a gist comment
@required {gist_id: str # The unique identifier of the gist., body: str # The comment text.}
@returns(201) {id: int, node_id: str, url: str(uri), body: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), author_association: str} # Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden}
@example_request {"body":"This is a comment to a gist"}

@endpoint GET /gists/{gist_id}/comments/{comment_id}
@desc Get a gist comment
@required {gist_id: str # The unique identifier of the gist., comment_id: int(int64) # The unique identifier of the comment.}
@returns(200) {id: int, node_id: str, url: str(uri), body: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), author_association: str} # Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden Gist}

@endpoint PATCH /gists/{gist_id}/comments/{comment_id}
@desc Update a gist comment
@required {gist_id: str # The unique identifier of the gist., comment_id: int(int64) # The unique identifier of the comment., body: str # The comment text.}
@returns(200) {id: int, node_id: str, url: str(uri), body: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), author_association: str} # Response
@errors {404: Resource not found}
@example_request {"body":"This is an update to a comment in a gist"}

@endpoint DELETE /gists/{gist_id}/comments/{comment_id}
@desc Delete a gist comment
@required {gist_id: str # The unique identifier of the gist., comment_id: int(int64) # The unique identifier of the comment.}
@returns(204) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden}

@endpoint GET /gists/{gist_id}/commits
@desc List gist commits
@required {gist_id: str # The unique identifier of the gist.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 304: Not modified, 403: Forbidden}

@endpoint GET /gists/{gist_id}/forks
@desc List gist forks
@required {gist_id: str # The unique identifier of the gist.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 304: Not modified, 403: Forbidden}

@endpoint POST /gists/{gist_id}/forks
@desc Fork a gist
@required {gist_id: str # The unique identifier of the gist.}
@returns(201) {url: str(uri), forks_url: str(uri), commits_url: str(uri), id: str, node_id: str, git_pull_url: str(uri), git_push_url: str(uri), html_url: str(uri), files: map, public: bool, created_at: str(date-time), updated_at: str(date-time), description: str?, comments: int, comments_enabled: bool, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, comments_url: str(uri), owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, truncated: bool, forks: [any], history: [any]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 304: Not modified, 403: Forbidden}

@endpoint GET /gists/{gist_id}/star
@desc Check if a gist is starred
@required {gist_id: str # The unique identifier of the gist.}
@returns(204) Response if gist is starred
@errors {404: Not Found if gist is not starred, 304: Not modified, 403: Forbidden}

@endpoint PUT /gists/{gist_id}/star
@desc Star a gist
@required {gist_id: str # The unique identifier of the gist.}
@returns(204) Response
@errors {404: Resource not found, 304: Not modified, 403: Forbidden}

@endpoint DELETE /gists/{gist_id}/star
@desc Unstar a gist
@required {gist_id: str # The unique identifier of the gist.}
@returns(204) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden}

@endpoint GET /gists/{gist_id}/{sha}
@desc Get a gist revision
@required {gist_id: str # The unique identifier of the gist., sha: str}
@returns(200) {forks: [map]?, history: [map]?, fork_of: map?{url: str(uri), forks_url: str(uri), commits_url: str(uri), id: str, node_id: str, git_pull_url: str(uri), git_push_url: str(uri), html_url: str(uri), files: map, public: bool, created_at: str(date-time), updated_at: str(date-time), description: str?, comments: int, comments_enabled: bool, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, comments_url: str(uri), owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, truncated: bool, forks: [any], history: [any]}, url: str, forks_url: str, commits_url: str, id: str, node_id: str, git_pull_url: str, git_push_url: str, html_url: str, files: map, public: bool, created_at: str, updated_at: str, description: str?, comments: int, comments_enabled: bool, user: str?, comments_url: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, truncated: bool} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 403: Forbidden}

@endgroup

@group gitignore
@endpoint GET /gitignore/templates
@desc Get all gitignore templates
@returns(200) Response
@errors {304: Not modified}

@endpoint GET /gitignore/templates/{name}
@desc Get a gitignore template
@required {name: str}
@returns(200) {name: str, source: str} # Response
@errors {304: Not modified}

@endgroup

@group installation
@endpoint GET /installation/repositories
@desc List repositories accessible to the app installation
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, repositories: [any], repository_selection: str} # Response
@errors {403: Forbidden, 304: Not modified, 401: Requires authentication}

@endpoint DELETE /installation/token
@desc Revoke an installation access token
@returns(204) Response

@endgroup

@group issues
@endpoint GET /issues
@desc List issues assigned to the authenticated user
@optional {filter: str(assigned/created/mentioned/subscribed/repos/all)=assigned # Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation., state: str(open/closed/all)=open # Indicates the state of the issues to return., labels: str # A list of comma separated label names. Example: `bug,ui,@high`, sort: str(created/updated/comments)=created # What to sort results by., direction: str(asc/desc)=desc # The direction to sort the results by., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., collab: bool, orgs: bool, owned: bool, pulls: bool, per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 404: Resource not found}

@endgroup

@group licenses
@endpoint GET /licenses
@desc Get all commonly used licenses
@optional {featured: bool, per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified}

@endpoint GET /licenses/{license}
@desc Get a license
@required {license: str}
@returns(200) {key: str, name: str, spdx_id: str?, url: str(uri)?, node_id: str, html_url: str(uri), description: str, implementation: str, permissions: [str], conditions: [str], limitations: [str], body: str, featured: bool} # Response
@errors {403: Forbidden, 404: Resource not found, 304: Not modified}

@endgroup

@group markdown
@endpoint POST /markdown
@desc Render a Markdown document
@required {text: str # The Markdown text to render in HTML.}
@optional {mode: str(markdown/gfm)=markdown # The rendering mode., context: str # The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository.}
@returns(200) Response
@errors {304: Not modified}
@example_request {"text":"Hello **world**"}

@endpoint POST /markdown/raw
@desc Render a Markdown document in raw mode
@returns(200) Response
@errors {304: Not modified}

@endgroup

@group marketplace_listing
@endpoint GET /marketplace_listing/accounts/{account_id}
@desc Get a subscription plan for an account
@required {account_id: int # account_id parameter}
@returns(200) {url: str, type: str, id: int, login: str, organization_billing_email: str, email: str?, marketplace_pending_change: map?{is_installed: bool, effective_date: str, unit_count: int?, id: int, plan: map{url: str(uri), accounts_url: str(uri), id: int, number: int, name: str, description: str, monthly_price_in_cents: int, yearly_price_in_cents: int, price_model: str, has_free_trial: bool, unit_name: str?, state: str, bullets: [str]}}, marketplace_purchase: map{billing_cycle: str, next_billing_date: str?, is_installed: bool, unit_count: int?, on_free_trial: bool, free_trial_ends_on: str?, updated_at: str, plan: map{url: str(uri), accounts_url: str(uri), id: int, number: int, name: str, description: str, monthly_price_in_cents: int, yearly_price_in_cents: int, price_model: str, has_free_trial: bool, unit_name: str?, state: str, bullets: [str]}}} # Response
@errors {404: Not Found when the account has not purchased the listing, 401: Requires authentication}

@endpoint GET /marketplace_listing/plans
@desc List plans
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 401: Requires authentication}

@endpoint GET /marketplace_listing/plans/{plan_id}/accounts
@desc List accounts for a plan
@required {plan_id: int # The unique identifier of the plan.}
@optional {sort: str(created/updated)=created # The property to sort the results by., direction: str(asc/desc) # To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 401: Requires authentication}

@endpoint GET /marketplace_listing/stubbed/accounts/{account_id}
@desc Get a subscription plan for an account (stubbed)
@required {account_id: int # account_id parameter}
@returns(200) {url: str, type: str, id: int, login: str, organization_billing_email: str, email: str?, marketplace_pending_change: map?{is_installed: bool, effective_date: str, unit_count: int?, id: int, plan: map{url: str(uri), accounts_url: str(uri), id: int, number: int, name: str, description: str, monthly_price_in_cents: int, yearly_price_in_cents: int, price_model: str, has_free_trial: bool, unit_name: str?, state: str, bullets: [str]}}, marketplace_purchase: map{billing_cycle: str, next_billing_date: str?, is_installed: bool, unit_count: int?, on_free_trial: bool, free_trial_ends_on: str?, updated_at: str, plan: map{url: str(uri), accounts_url: str(uri), id: int, number: int, name: str, description: str, monthly_price_in_cents: int, yearly_price_in_cents: int, price_model: str, has_free_trial: bool, unit_name: str?, state: str, bullets: [str]}}} # Response
@errors {404: Not Found when the account has not purchased the listing, 401: Requires authentication}

@endpoint GET /marketplace_listing/stubbed/plans
@desc List plans (stubbed)
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {401: Requires authentication}

@endpoint GET /marketplace_listing/stubbed/plans/{plan_id}/accounts
@desc List accounts for a plan (stubbed)
@required {plan_id: int # The unique identifier of the plan.}
@optional {sort: str(created/updated)=created # The property to sort the results by., direction: str(asc/desc) # To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {401: Requires authentication}

@endgroup

@group meta
@endpoint GET /meta
@desc Get GitHub meta information
@returns(200) {verifiable_password_authentication: bool, ssh_key_fingerprints: map{SHA256_RSA: str, SHA256_DSA: str, SHA256_ECDSA: str, SHA256_ED25519: str}, ssh_keys: [str], hooks: [str], github_enterprise_importer: [str], web: [str], api: [str], git: [str], packages: [str], pages: [str], importer: [str], actions: [str], actions_macos: [str], codespaces: [str], dependabot: [str], copilot: [str], domains: map{website: [str], codespaces: [str], copilot: [str], packages: [str], actions: [str], actions_inbound: map{full_domains: [str], wildcard_domains: [str]}, artifact_attestations: map{trust_domain: str, services: [str]}}} # Response
@errors {304: Not modified}

@endgroup

@group networks
@endpoint GET /networks/{owner}/{repo}/events
@desc List public events for a network of repositories
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 403: Forbidden, 304: Not modified, 301: Moved permanently}

@endgroup

@group notifications
@endpoint GET /notifications
@desc List notifications for the authenticated user
@optional {all: bool=False # If `true`, show notifications marked as read., participating: bool=False # If `true`, only shows notifications in which the user is directly participating or mentioned., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., before: str(date-time) # Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=50 # The number of results per page (max 50). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication, 422: Validation failed, or the endpoint has been spammed.}

@endpoint PUT /notifications
@desc Mark notifications as read
@optional {last_read_at: str(date-time) # Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp., read: bool # Whether the notification has been read.}
@returns(202) {message: str} # Response
@returns(205) Reset Content
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}
@example_request {"last_read_at":"2022-06-10T00:00:00Z","read":true}

@endpoint GET /notifications/threads/{thread_id}
@desc Get a thread
@required {thread_id: int # The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).}
@returns(200) {id: str, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, subject: map{title: str, url: str, latest_comment_url: str, type: str}, reason: str, unread: bool, updated_at: str, last_read_at: str?, url: str, subscription_url: str} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint PATCH /notifications/threads/{thread_id}
@desc Mark a thread as read
@required {thread_id: int # The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).}
@returns(205) Reset Content
@errors {304: Not modified, 403: Forbidden}

@endpoint DELETE /notifications/threads/{thread_id}
@desc Mark a thread as done
@required {thread_id: int # The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).}
@returns(204) No content

@endpoint GET /notifications/threads/{thread_id}/subscription
@desc Get a thread subscription for the authenticated user
@required {thread_id: int # The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).}
@returns(200) {subscribed: bool, ignored: bool, reason: str?, created_at: str(date-time)?, url: str(uri), thread_url: str(uri), repository_url: str(uri)} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint PUT /notifications/threads/{thread_id}/subscription
@desc Set a thread subscription
@required {thread_id: int # The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).}
@optional {ignored: bool=False # Whether to block all notifications from a thread.}
@returns(200) {subscribed: bool, ignored: bool, reason: str?, created_at: str(date-time)?, url: str(uri), thread_url: str(uri), repository_url: str(uri)} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}
@example_request {"ignored":false}

@endpoint DELETE /notifications/threads/{thread_id}/subscription
@desc Delete a thread subscription
@required {thread_id: int # The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)).}
@returns(204) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endgroup

@group octocat
@endpoint GET /octocat
@desc Get Octocat
@optional {s: str # The words to show in Octocat's speech bubble}
@returns(200) Response

@endgroup

@group organizations
@endpoint GET /organizations
@desc List organizations
@optional {since: int # An organization ID. Only return organizations with an ID greater than this ID., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified}

@endpoint GET /organizations/{org}/actions/cache/retention-limit
@desc Get GitHub Actions cache retention limit for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {max_cache_retention_days: int} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /organizations/{org}/actions/cache/retention-limit
@desc Set GitHub Actions cache retention limit for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {max_cache_retention_days: int # For repositories in this organization, the maximum duration, in days, for which caches in a repository may be retained.}
@returns(204) Response
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found}
@example_request {"max_cache_retention_days":80}

@endpoint GET /organizations/{org}/actions/cache/storage-limit
@desc Get GitHub Actions cache storage limit for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {max_cache_size_gb: int} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /organizations/{org}/actions/cache/storage-limit
@desc Set GitHub Actions cache storage limit for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {max_cache_size_gb: int # For repositories in the organization, the maximum size limit for the sum of all caches in a repository, in gigabytes.}
@returns(204) Response
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found}
@example_request {"max_cache_size_gb":150}

@endpoint GET /organizations/{org}/dependabot/repository-access
@desc Lists the repositories Dependabot can access in an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {page: int=1 # The page number of results to fetch., per_page: int=30 # Number of results per page.}
@returns(200) {default_level: str?, accessible_repositories: [map]} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PATCH /organizations/{org}/dependabot/repository-access
@desc Updates Dependabot's repository access list for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {repository_ids_to_add: [int] # List of repository IDs to add., repository_ids_to_remove: [int] # List of repository IDs to remove.}
@returns(204) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /organizations/{org}/dependabot/repository-access/default-level
@desc Set the default repository access level for Dependabot
@required {org: str # The organization name. The name is not case sensitive., default_level: str(public/internal) # The default repository access level for Dependabot updates.}
@returns(204) Response
@errors {403: Forbidden, 404: Resource not found}
@example_request {"default_level":"public"}

@endpoint GET /organizations/{org}/settings/billing/budgets
@desc Get all budgets for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {budgets: [map], has_next_page: bool, total_count: int} # Response when getting all budgets
@errors {404: Resource not found, 403: Forbidden, 500: Internal Error}

@endpoint GET /organizations/{org}/settings/billing/budgets/{budget_id}
@desc Get a budget by ID for an organization
@required {org: str # The organization name. The name is not case sensitive., budget_id: str # The ID corresponding to the budget.}
@returns(200) {id: str, budget_scope: str, budget_entity_name: str, budget_amount: int, prevent_further_usage: bool, budget_product_sku: str, budget_type: str, budget_alerting: map{will_alert: bool, alert_recipients: [str]}} # Response when updating a budget
@errors {400: Bad Request, 404: Resource not found, 403: Forbidden, 500: Internal Error, 503: Service unavailable}

@endpoint PATCH /organizations/{org}/settings/billing/budgets/{budget_id}
@desc Update a budget for an organization
@required {org: str # The organization name. The name is not case sensitive., budget_id: str # The ID corresponding to the budget.}
@optional {budget_amount: int # The budget amount in whole dollars. For license-based products, this represents the number of licenses., prevent_further_usage: bool # Whether to prevent additional spending once the budget is exceeded, budget_alerting: map{will_alert: bool, alert_recipients: [str]}, budget_scope: str(enterprise/organization/repository/cost_center) # The scope of the budget, budget_entity_name: str # The name of the entity to apply the budget to, budget_type: str(ProductPricing/SkuPricing) # The type of pricing for the budget, budget_product_sku: str # A single product or SKU that will be covered in the budget}
@returns(200) {message: str, budget: map{id: str, budget_amount: num(float), prevent_further_usage: bool, budget_alerting: map{will_alert: bool, alert_recipients: [str]}, budget_scope: str, budget_entity_name: str, budget_type: str, budget_product_sku: str}} # Budget updated successfully
@errors {400: Bad Request, 401: Requires authentication, 403: Forbidden, 404: Budget not found or feature not enabled, 422: Validation failed, or the endpoint has been spammed., 500: Internal server error}
@example_request {"prevent_further_usage":false,"budget_amount":10,"budget_alerting":{"will_alert":false,"alert_recipients":[]}}

@endpoint DELETE /organizations/{org}/settings/billing/budgets/{budget_id}
@desc Delete a budget for an organization
@required {org: str # The organization name. The name is not case sensitive., budget_id: str # The ID corresponding to the budget.}
@returns(200) {message: str, id: str} # Response when deleting a budget
@errors {400: Bad Request, 404: Resource not found, 403: Forbidden, 500: Internal Error, 503: Service unavailable}

@endpoint GET /organizations/{org}/settings/billing/premium_request/usage
@desc Get billing premium request usage report for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {year: int # If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year., month: int # If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. Default value is the current month. If no year is specified the default `year` is used., day: int # If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used., user: str # The user name to query usage for. The name is not case sensitive., model: str # The model name to query usage for. The name is not case sensitive., product: str # The product name to query usage for. The name is not case sensitive.}
@returns(200) {timePeriod: map{year: int, month: int, day: int}, organization: str, user: str, product: str, model: str, usageItems: [map]} # Response when getting a billing premium request usage report
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found, 500: Internal Error, 503: Service unavailable}

@endpoint GET /organizations/{org}/settings/billing/usage
@desc Get billing usage report for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {year: int # If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year., month: int # If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used., day: int # If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.}
@returns(200) {usageItems: [map]} # Billing usage report response for an organization
@errors {400: Bad Request, 403: Forbidden, 500: Internal Error, 503: Service unavailable}

@endpoint GET /organizations/{org}/settings/billing/usage/summary
@desc Get billing usage summary for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {year: int # If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year., month: int # If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. Default value is the current month. If no year is specified the default `year` is used., day: int # If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used., repository: str # The repository name to query for usage in the format owner/repository., product: str # The product name to query usage for. The name is not case sensitive., sku: str # The SKU to query for usage.}
@returns(200) {timePeriod: map{year: int, month: int, day: int}, organization: str, repository: str, product: str, sku: str, usageItems: [map]} # Response when getting a billing usage summary
@errors {400: Bad Request, 403: Forbidden, 500: Internal Error, 503: Service unavailable}

@endgroup

@group orgs
@endpoint GET /orgs/{org}
@desc Get an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?, name: str, company: str, blog: str(uri), location: str, email: str(email), twitter_username: str?, is_verified: bool, has_organization_projects: bool, has_repository_projects: bool, public_repos: int, public_gists: int, followers: int, following: int, html_url: str(uri), type: str, total_private_repos: int, owned_private_repos: int, private_gists: int?, disk_usage: int?, collaborators: int?, billing_email: str(email)?, plan: map{name: str, space: int, private_repos: int, filled_seats: int, seats: int}, default_repository_permission: str?, default_repository_branch: str?, members_can_create_repositories: bool?, two_factor_requirement_enabled: bool?, members_allowed_repository_creation_type: str, members_can_create_public_repositories: bool, members_can_create_private_repositories: bool, members_can_create_internal_repositories: bool, members_can_create_pages: bool, members_can_create_public_pages: bool, members_can_create_private_pages: bool, members_can_delete_repositories: bool, members_can_change_repo_visibility: bool, members_can_invite_outside_collaborators: bool, members_can_delete_issues: bool, display_commenter_full_name_setting_enabled: bool, readers_can_create_discussions: bool, members_can_create_teams: bool, members_can_view_dependency_insights: bool, members_can_fork_private_repositories: bool?, web_commit_signoff_required: bool, advanced_security_enabled_for_new_repositories: bool, dependabot_alerts_enabled_for_new_repositories: bool, dependabot_security_updates_enabled_for_new_repositories: bool, dependency_graph_enabled_for_new_repositories: bool, secret_scanning_enabled_for_new_repositories: bool, secret_scanning_push_protection_enabled_for_new_repositories: bool, secret_scanning_push_protection_custom_link_enabled: bool, secret_scanning_push_protection_custom_link: str?, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, deploy_keys_enabled_for_repositories: bool} # Response
@errors {404: Resource not found}

@endpoint PATCH /orgs/{org}
@desc Update an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {billing_email: str # Billing email address. This address is not publicized., company: str # The company name., email: str # The publicly visible email address., twitter_username: str # The Twitter username of the company., location: str # The location., name: str # The shorthand name of the company., description: str # The description of the company. The maximum size is 160 characters., has_organization_projects: bool # Whether an organization can use organization projects., has_repository_projects: bool # Whether repositories that belong to the organization can use repository projects., default_repository_permission: str(read/write/admin/none)=read # Default permission level members have for organization repositories., members_can_create_repositories: bool=True # Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details., members_can_create_internal_repositories: bool # Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation., members_can_create_private_repositories: bool # Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation., members_can_create_public_repositories: bool # Whether organization members can create public repositories, which are visible to anyone. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation., members_allowed_repository_creation_type: str(all/private/none) # Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud.  **Note:** This parameter is closing down and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details., members_can_create_pages: bool=True # Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted., members_can_create_public_pages: bool=True # Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted., members_can_create_private_pages: bool=True # Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted., members_can_fork_private_repositories: bool=False # Whether organization members can fork private organization repositories., web_commit_signoff_required: bool=False # Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface., blog: str, advanced_security_enabled_for_new_repositories: bool # **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether GitHub Advanced Security is automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request., dependabot_alerts_enabled_for_new_repositories: bool # **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request., dependabot_security_updates_enabled_for_new_repositories: bool # **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request., dependency_graph_enabled_for_new_repositories: bool # **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request., secret_scanning_enabled_for_new_repositories: bool # **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request., secret_scanning_push_protection_enabled_for_new_repositories: bool # **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request., secret_scanning_push_protection_custom_link_enabled: bool # Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection., secret_scanning_push_protection_custom_link: str # If `secret_scanning_push_protection_custom_link_enabled` is true, the URL that will be displayed to contributors who are blocked from pushing a secret., deploy_keys_enabled_for_repositories: bool # Controls whether or not deploy keys may be added and used for repositories in the organization.}
@returns(200) {login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?, name: str, company: str, blog: str(uri), location: str, email: str(email), twitter_username: str?, is_verified: bool, has_organization_projects: bool, has_repository_projects: bool, public_repos: int, public_gists: int, followers: int, following: int, html_url: str(uri), type: str, total_private_repos: int, owned_private_repos: int, private_gists: int?, disk_usage: int?, collaborators: int?, billing_email: str(email)?, plan: map{name: str, space: int, private_repos: int, filled_seats: int, seats: int}, default_repository_permission: str?, default_repository_branch: str?, members_can_create_repositories: bool?, two_factor_requirement_enabled: bool?, members_allowed_repository_creation_type: str, members_can_create_public_repositories: bool, members_can_create_private_repositories: bool, members_can_create_internal_repositories: bool, members_can_create_pages: bool, members_can_create_public_pages: bool, members_can_create_private_pages: bool, members_can_delete_repositories: bool, members_can_change_repo_visibility: bool, members_can_invite_outside_collaborators: bool, members_can_delete_issues: bool, display_commenter_full_name_setting_enabled: bool, readers_can_create_discussions: bool, members_can_create_teams: bool, members_can_view_dependency_insights: bool, members_can_fork_private_repositories: bool?, web_commit_signoff_required: bool, advanced_security_enabled_for_new_repositories: bool, dependabot_alerts_enabled_for_new_repositories: bool, dependabot_security_updates_enabled_for_new_repositories: bool, dependency_graph_enabled_for_new_repositories: bool, secret_scanning_enabled_for_new_repositories: bool, secret_scanning_push_protection_enabled_for_new_repositories: bool, secret_scanning_push_protection_custom_link_enabled: bool, secret_scanning_push_protection_custom_link: str?, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, deploy_keys_enabled_for_repositories: bool} # Response
@errors {422: Validation failed, 409: Conflict}
@example_request {"billing_email":"mona@github.com","company":"GitHub","email":"mona@github.com","twitter_username":"github","location":"San Francisco","name":"github","description":"GitHub, the company.","default_repository_permission":"read","members_can_create_repositories":true,"members_allowed_repository_creation_type":"all"}

@endpoint DELETE /orgs/{org}
@desc Delete an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(202) Accepted
@errors {404: Resource not found, 403: Forbidden}

@endpoint GET /orgs/{org}/actions/cache/usage
@desc Get GitHub Actions cache usage for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {total_active_caches_count: int, total_active_caches_size_in_bytes: int} # Response

@endpoint GET /orgs/{org}/actions/cache/usage-by-repository
@desc List repositories with GitHub Actions cache usage for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, repository_cache_usages: [map]} # Response

@endpoint GET /orgs/{org}/actions/hosted-runners
@desc List GitHub-hosted runners for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, runners: [map]} # Response

@endpoint POST /orgs/{org}/actions/hosted-runners
@desc Create a GitHub-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., name: str # Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'., image: map{id: str, source: str, version: str} # The image of runner. To list all available images, use `GET /actions/hosted-runners/images/github-owned` or `GET /actions/hosted-runners/images/partner`., size: str # The machine size of the runner. To list available sizes, use `GET actions/hosted-runners/machine-sizes`, runner_group_id: int # The existing runner group to add this runner to.}
@optional {maximum_runners: int # The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost., enable_static_ip: bool # Whether this runner should be created with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`, image_gen: bool=False # Whether this runner should be used to generate custom images.}
@returns(201) {id: int, name: str, runner_group_id: int, image_details: map?{id: str, size_gb: int, display_name: str, source: str, version: str}, machine_size_details: map{id: str, cpu_cores: int, memory_gb: int, storage_gb: int}, status: str, platform: str, maximum_runners: int, public_ip_enabled: bool, public_ips: [map], last_active_on: str(date-time)?, image_gen: bool} # Response
@example_request {"name":"My Hosted runner","image":{"id":"ubuntu-latest","source":"github"},"runner_group_id":1,"size":"4-core","maximum_runners":50,"enable_static_ip":false}

@endpoint GET /orgs/{org}/actions/hosted-runners/images/custom
@desc List custom images for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {total_count: int, images: [map]} # Response

@endpoint GET /orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}
@desc Get a custom image definition for GitHub Actions Hosted Runners
@required {org: str # The organization name. The name is not case sensitive., image_definition_id: int # Image definition ID of custom image}
@returns(200) {id: int, platform: str, total_versions_size: int, name: str, source: str, versions_count: int, latest_version: str, state: str} # Response

@endpoint DELETE /orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}
@desc Delete a custom image from the organization
@required {org: str # The organization name. The name is not case sensitive., image_definition_id: int # Image definition ID of custom image}
@returns(204) Response

@endpoint GET /orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}/versions
@desc List image versions of a custom image for an organization
@required {image_definition_id: int # Image definition ID of custom image, org: str # The organization name. The name is not case sensitive.}
@returns(200) {total_count: int, image_versions: [map]} # Response

@endpoint GET /orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}/versions/{version}
@desc Get an image version of a custom image for GitHub Actions Hosted Runners
@required {org: str # The organization name. The name is not case sensitive., image_definition_id: int # Image definition ID of custom image, version: str # Version of a custom image}
@returns(200) {version: str, state: str, size_gb: int, created_on: str, state_details: str} # Response

@endpoint DELETE /orgs/{org}/actions/hosted-runners/images/custom/{image_definition_id}/versions/{version}
@desc Delete an image version of custom image from the organization
@required {org: str # The organization name. The name is not case sensitive., image_definition_id: int # Image definition ID of custom image, version: str # Version of a custom image}
@returns(204) Response

@endpoint GET /orgs/{org}/actions/hosted-runners/images/github-owned
@desc Get GitHub-owned images for GitHub-hosted runners in an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {total_count: int, images: [map]} # Response

@endpoint GET /orgs/{org}/actions/hosted-runners/images/partner
@desc Get partner images for GitHub-hosted runners in an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {total_count: int, images: [map]} # Response

@endpoint GET /orgs/{org}/actions/hosted-runners/limits
@desc Get limits on GitHub-hosted runners for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {public_ips: map{maximum: int, current_usage: int}} # Response

@endpoint GET /orgs/{org}/actions/hosted-runners/machine-sizes
@desc Get GitHub-hosted runners machine specs for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {total_count: int, machine_specs: [map]} # Response

@endpoint GET /orgs/{org}/actions/hosted-runners/platforms
@desc Get platforms for GitHub-hosted runners in an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {total_count: int, platforms: [str]} # Response

@endpoint GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}
@desc Get a GitHub-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., hosted_runner_id: int # Unique identifier of the GitHub-hosted runner.}
@returns(200) {id: int, name: str, runner_group_id: int, image_details: map?{id: str, size_gb: int, display_name: str, source: str, version: str}, machine_size_details: map{id: str, cpu_cores: int, memory_gb: int, storage_gb: int}, status: str, platform: str, maximum_runners: int, public_ip_enabled: bool, public_ips: [map], last_active_on: str(date-time)?, image_gen: bool} # Response

@endpoint PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}
@desc Update a GitHub-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., hosted_runner_id: int # Unique identifier of the GitHub-hosted runner.}
@optional {name: str # Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'., runner_group_id: int # The existing runner group to add this runner to., maximum_runners: int # The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost., enable_static_ip: bool # Whether this runner should be updated with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`, size: str # The machine size of the runner. To list available sizes, use `GET actions/hosted-runners/machine-sizes`, image_id: str # The unique identifier of the runner image. To list all available images, use `GET /actions/hosted-runners/images/github-owned` or `GET /actions/hosted-runners/images/partner`., image_version: str # The version of the runner image to deploy. This is relevant only for runners using custom images.}
@returns(200) {id: int, name: str, runner_group_id: int, image_details: map?{id: str, size_gb: int, display_name: str, source: str, version: str}, machine_size_details: map{id: str, cpu_cores: int, memory_gb: int, storage_gb: int}, status: str, platform: str, maximum_runners: int, public_ip_enabled: bool, public_ips: [map], last_active_on: str(date-time)?, image_gen: bool} # Response
@example_request {"name":"My larger runner","runner_group_id":1,"maximum_runners":50,"enable_static_ip":false}

@endpoint DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}
@desc Delete a GitHub-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., hosted_runner_id: int # Unique identifier of the GitHub-hosted runner.}
@returns(202) {id: int, name: str, runner_group_id: int, image_details: map?{id: str, size_gb: int, display_name: str, source: str, version: str}, machine_size_details: map{id: str, cpu_cores: int, memory_gb: int, storage_gb: int}, status: str, platform: str, maximum_runners: int, public_ip_enabled: bool, public_ips: [map], last_active_on: str(date-time)?, image_gen: bool} # Response

@endpoint GET /orgs/{org}/actions/oidc/customization/sub
@desc Get the customization template for an OIDC subject claim for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {include_claim_keys: [str]} # A JSON serialized template for OIDC subject claim customization

@endpoint PUT /orgs/{org}/actions/oidc/customization/sub
@desc Set the customization template for an OIDC subject claim for an organization
@required {org: str # The organization name. The name is not case sensitive., include_claim_keys: [str] # Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.}
@returns(201) Empty response
@errors {404: Resource not found, 403: Forbidden}
@example_request {"include_claim_keys":["repo","context"]}

@endpoint GET /orgs/{org}/actions/permissions
@desc Get GitHub Actions permissions for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {enabled_repositories: str, selected_repositories_url: str, allowed_actions: str, selected_actions_url: str, sha_pinning_required: bool} # Response

@endpoint PUT /orgs/{org}/actions/permissions
@desc Set GitHub Actions permissions for an organization
@required {org: str # The organization name. The name is not case sensitive., enabled_repositories: str(all/none/selected) # The policy that controls the repositories in the organization that are allowed to run GitHub Actions.}
@optional {allowed_actions: str(all/local_only/selected) # The permissions policy that controls the actions and reusable workflows that are allowed to run., sha_pinning_required: bool # Whether actions must be pinned to a full-length commit SHA.}
@returns(204) Response
@example_request {"enabled_repositories":"all","allowed_actions":"selected","sha_pinning_required":true}

@endpoint GET /orgs/{org}/actions/permissions/artifact-and-log-retention
@desc Get artifact and log retention settings for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {days: int, maximum_allowed_days: int} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /orgs/{org}/actions/permissions/artifact-and-log-retention
@desc Set artifact and log retention settings for an organization
@required {org: str # The organization name. The name is not case sensitive., days: int # The number of days to retain artifacts and logs}
@returns(204) No content
@errors {403: Forbidden, 404: Resource not found, 409: Conflict, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"days":100}

@endpoint GET /orgs/{org}/actions/permissions/fork-pr-contributor-approval
@desc Get fork PR contributor approval permissions for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {approval_policy: str} # Response
@errors {404: Resource not found}

@endpoint PUT /orgs/{org}/actions/permissions/fork-pr-contributor-approval
@desc Set fork PR contributor approval permissions for an organization
@required {org: str # The organization name. The name is not case sensitive., approval_policy: str(first_time_contributors_new_to_github/first_time_contributors/all_external_contributors) # The policy that controls when fork PR workflows require approval from a maintainer.}
@returns(204) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"approval_policy":"first_time_contributors"}

@endpoint GET /orgs/{org}/actions/permissions/fork-pr-workflows-private-repos
@desc Get private repo fork PR workflow settings for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {run_workflows_from_fork_pull_requests: bool, send_write_tokens_to_workflows: bool, send_secrets_and_variables: bool, require_approval_for_fork_pr_workflows: bool} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /orgs/{org}/actions/permissions/fork-pr-workflows-private-repos
@desc Set private repo fork PR workflow settings for an organization
@required {org: str # The organization name. The name is not case sensitive., run_workflows_from_fork_pull_requests: bool # Whether workflows triggered by pull requests from forks are allowed to run on private repositories.}
@optional {send_write_tokens_to_workflows: bool # Whether GitHub Actions can create pull requests or submit approving pull request reviews from a workflow triggered by a fork pull request., send_secrets_and_variables: bool # Whether to make secrets and variables available to workflows triggered by pull requests from forks., require_approval_for_fork_pr_workflows: bool # Whether workflows triggered by pull requests from forks require approval from a repository administrator to run.}
@returns(204) Empty response for successful settings update
@errors {403: Forbidden - Fork PR workflow settings for private repositories are managed by the enterprise owner, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"run_workflows_from_fork_pull_requests":true,"send_write_tokens_to_workflows":false,"send_secrets_and_variables":false,"require_approval_for_fork_pr_workflows":true}

@endpoint GET /orgs/{org}/actions/permissions/repositories
@desc List selected repositories enabled for GitHub Actions in an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: num, repositories: [map]} # Response

@endpoint PUT /orgs/{org}/actions/permissions/repositories
@desc Set selected repositories enabled for GitHub Actions in an organization
@required {org: str # The organization name. The name is not case sensitive., selected_repository_ids: [int] # List of repository IDs to enable for GitHub Actions.}
@returns(204) Response
@example_request {"selected_repository_ids":[32,42]}

@endpoint PUT /orgs/{org}/actions/permissions/repositories/{repository_id}
@desc Enable a selected repository for GitHub Actions in an organization
@required {org: str # The organization name. The name is not case sensitive., repository_id: int # The unique identifier of the repository.}
@returns(204) Response

@endpoint DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}
@desc Disable a selected repository for GitHub Actions in an organization
@required {org: str # The organization name. The name is not case sensitive., repository_id: int # The unique identifier of the repository.}
@returns(204) Response

@endpoint GET /orgs/{org}/actions/permissions/selected-actions
@desc Get allowed actions and reusable workflows for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {github_owned_allowed: bool, verified_allowed: bool, patterns_allowed: [str]} # Response

@endpoint PUT /orgs/{org}/actions/permissions/selected-actions
@desc Set allowed actions and reusable workflows for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {github_owned_allowed: bool # Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization., verified_allowed: bool # Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators., patterns_allowed: [str] # Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.  > [!NOTE] > The `patterns_allowed` setting only applies to public repositories.}
@returns(204) Response
@example_request {"github_owned_allowed":true,"verified_allowed":false,"patterns_allowed":["monalisa/octocat@*","docker/*"]}

@endpoint GET /orgs/{org}/actions/permissions/self-hosted-runners
@desc Get self-hosted runners settings for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {enabled_repositories: str, selected_repositories_url: str} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /orgs/{org}/actions/permissions/self-hosted-runners
@desc Set self-hosted runners settings for an organization
@required {org: str # The organization name. The name is not case sensitive., enabled_repositories: str(all/selected/none) # The policy that controls whether self-hosted runners can be used in the organization}
@returns(204) No content
@errors {403: Forbidden, 404: Resource not found, 409: Conflict, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"enabled_repositories":"all"}

@endpoint GET /orgs/{org}/actions/permissions/self-hosted-runners/repositories
@desc List repositories allowed to use self-hosted runners in an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, repositories: [map]} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /orgs/{org}/actions/permissions/self-hosted-runners/repositories
@desc Set repositories allowed to use self-hosted runners in an organization
@required {org: str # The organization name. The name is not case sensitive., selected_repository_ids: [int] # IDs of repositories that can use repository-level self-hosted runners}
@returns(204) No content
@errors {403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"selected_repository_ids":[1,2,3]}

@endpoint PUT /orgs/{org}/actions/permissions/self-hosted-runners/repositories/{repository_id}
@desc Add a repository to the list of repositories allowed to use self-hosted runners in an organization
@required {org: str # The organization name. The name is not case sensitive., repository_id: int # The unique identifier of the repository.}
@returns(204) No content
@errors {403: Forbidden, 404: Resource not found, 409: Conflict, 422: Validation failed, or the endpoint has been spammed.}

@endpoint DELETE /orgs/{org}/actions/permissions/self-hosted-runners/repositories/{repository_id}
@desc Remove a repository from the list of repositories allowed to use self-hosted runners in an organization
@required {org: str # The organization name. The name is not case sensitive., repository_id: int # The unique identifier of the repository.}
@returns(204) No content
@errors {403: Forbidden, 404: Resource not found, 409: Conflict, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /orgs/{org}/actions/permissions/workflow
@desc Get default workflow permissions for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {default_workflow_permissions: str, can_approve_pull_request_reviews: bool} # Response

@endpoint PUT /orgs/{org}/actions/permissions/workflow
@desc Set default workflow permissions for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {default_workflow_permissions: str(read/write) # The default workflow permissions granted to the GITHUB_TOKEN when running workflows., can_approve_pull_request_reviews: bool # Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.}
@returns(204) Success response
@example_request {"default_workflow_permissions":"read","can_approve_pull_request_reviews":true}

@endpoint GET /orgs/{org}/actions/runner-groups
@desc List self-hosted runner groups for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", visible_to_repository: str # Only return runner groups that are allowed to be used by this repository.}
@returns(200) {total_count: num, runner_groups: [map]} # Response

@endpoint POST /orgs/{org}/actions/runner-groups
@desc Create a self-hosted runner group for an organization
@required {org: str # The organization name. The name is not case sensitive., name: str # Name of the runner group.}
@optional {visibility: str(selected/all/private)=all # Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories., selected_repository_ids: [int] # List of repository IDs that can access the runner group., runners: [int] # List of runner IDs to add to the runner group., allows_public_repositories: bool=False # Whether the runner group can be used by `public` repositories., restricted_to_workflows: bool=False # If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array., selected_workflows: [str] # List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`., network_configuration_id: str # The identifier of a hosted compute network configuration.}
@returns(201) {id: num, name: str, visibility: str, default: bool, selected_repositories_url: str, runners_url: str, hosted_runners_url: str, network_configuration_id: str, inherited: bool, inherited_allows_public_repositories: bool, allows_public_repositories: bool, workflow_restrictions_read_only: bool, restricted_to_workflows: bool, selected_workflows: [str]} # Response
@example_request {"name":"Expensive hardware runners","visibility":"selected","selected_repository_ids":[32,91],"runners":[9,2]}

@endpoint GET /orgs/{org}/actions/runner-groups/{runner_group_id}
@desc Get a self-hosted runner group for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group.}
@returns(200) {id: num, name: str, visibility: str, default: bool, selected_repositories_url: str, runners_url: str, hosted_runners_url: str, network_configuration_id: str, inherited: bool, inherited_allows_public_repositories: bool, allows_public_repositories: bool, workflow_restrictions_read_only: bool, restricted_to_workflows: bool, selected_workflows: [str]} # Response

@endpoint PATCH /orgs/{org}/actions/runner-groups/{runner_group_id}
@desc Update a self-hosted runner group for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group., name: str # Name of the runner group.}
@optional {visibility: str(selected/all/private) # Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories., allows_public_repositories: bool=False # Whether the runner group can be used by `public` repositories., restricted_to_workflows: bool=False # If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array., selected_workflows: [str] # List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`., network_configuration_id: str # The identifier of a hosted compute network configuration.}
@returns(200) {id: num, name: str, visibility: str, default: bool, selected_repositories_url: str, runners_url: str, hosted_runners_url: str, network_configuration_id: str, inherited: bool, inherited_allows_public_repositories: bool, allows_public_repositories: bool, workflow_restrictions_read_only: bool, restricted_to_workflows: bool, selected_workflows: [str]} # Response
@example_request {"name":"Expensive hardware runners","visibility":"selected"}

@endpoint DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}
@desc Delete a self-hosted runner group from an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group.}
@returns(204) Response

@endpoint GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners
@desc List GitHub-hosted runners in a group for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: num, runners: [map]} # Response

@endpoint GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
@desc List repository access to a self-hosted runner group in an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: num, repositories: [map]} # Response

@endpoint PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
@desc Set repository access for a self-hosted runner group in an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group., selected_repository_ids: [int] # List of repository IDs that can access the runner group.}
@returns(204) Response
@example_request {"selected_repository_ids":[32,91]}

@endpoint PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
@desc Add repository access to a self-hosted runner group in an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group., repository_id: int # The unique identifier of the repository.}
@returns(204) Response

@endpoint DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
@desc Remove repository access to a self-hosted runner group in an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group., repository_id: int # The unique identifier of the repository.}
@returns(204) Response

@endpoint GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
@desc List self-hosted runners in a group for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: num, runners: [map]} # Response

@endpoint PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
@desc Set self-hosted runners in a group for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group., runners: [int] # List of runner IDs to add to the runner group.}
@returns(204) Response
@example_request {"runners":[9,2]}

@endpoint PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
@desc Add a self-hosted runner to a group for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(204) Response

@endpoint DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
@desc Remove a self-hosted runner from a group for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_group_id: int # Unique identifier of the self-hosted runner group., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(204) Response

@endpoint GET /orgs/{org}/actions/runners
@desc List self-hosted runners for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {name: str # The name of a self-hosted runner., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, runners: [map]} # Response

@endpoint GET /orgs/{org}/actions/runners/downloads
@desc List runner applications for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) Response

@endpoint POST /orgs/{org}/actions/runners/generate-jitconfig
@desc Create configuration for a just-in-time runner for an organization
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the new runner., runner_group_id: int # The ID of the runner group to register the runner to., labels: [str] # The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.}
@optional {work_folder: str=_work # The working directory to be used for job execution, relative to the runner install directory.}
@returns(201) {runner: map{id: int, runner_group_id: int, name: str, os: str, status: str, busy: bool, labels: [map], ephemeral: bool}, encoded_jit_config: str} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 409: Conflict}
@example_request {"name":"New runner","runner_group_id":1,"labels":["self-hosted","X64","macOS","no-gpu"],"work_folder":"_work"}

@endpoint POST /orgs/{org}/actions/runners/registration-token
@desc Create a registration token for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(201) {token: str, expires_at: str(date-time), permissions: map, repositories: [map], single_file: str?, repository_selection: str} # Response

@endpoint POST /orgs/{org}/actions/runners/remove-token
@desc Create a remove token for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(201) {token: str, expires_at: str(date-time), permissions: map, repositories: [map], single_file: str?, repository_selection: str} # Response

@endpoint GET /orgs/{org}/actions/runners/{runner_id}
@desc Get a self-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(200) {id: int, runner_group_id: int, name: str, os: str, status: str, busy: bool, labels: [map], ephemeral: bool} # Response

@endpoint DELETE /orgs/{org}/actions/runners/{runner_id}
@desc Delete a self-hosted runner from an organization
@required {org: str # The organization name. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /orgs/{org}/actions/runners/{runner_id}/labels
@desc List labels for a self-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found}

@endpoint POST /orgs/{org}/actions/runners/{runner_id}/labels
@desc Add custom labels to a self-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner., labels: [str] # The names of the custom labels to add to the runner.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"labels":["gpu","accelerated"]}

@endpoint PUT /orgs/{org}/actions/runners/{runner_id}/labels
@desc Set custom labels for a self-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner., labels: [str] # The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"labels":["gpu","accelerated"]}

@endpoint DELETE /orgs/{org}/actions/runners/{runner_id}/labels
@desc Remove all custom labels from a self-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found}

@endpoint DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}
@desc Remove a custom label from a self-hosted runner for an organization
@required {org: str # The organization name. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner., name: str # The name of a self-hosted runner's custom label.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /orgs/{org}/actions/secrets
@desc List organization secrets
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, secrets: [map]} # Response

@endpoint GET /orgs/{org}/actions/secrets/public-key
@desc Get an organization public key
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {key_id: str, key: str, id: int, url: str, title: str, created_at: str} # Response

@endpoint GET /orgs/{org}/actions/secrets/{secret_name}
@desc Get an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(200) {name: str, created_at: str(date-time), updated_at: str(date-time), visibility: str, selected_repositories_url: str(uri)} # Response

@endpoint PUT /orgs/{org}/actions/secrets/{secret_name}
@desc Create or update an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., encrypted_value: str # Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/actions/secrets#get-an-organization-public-key) endpoint., key_id: str # ID of the key you used to encrypt the secret., visibility: str(all/private/selected) # Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.}
@optional {selected_repository_ids: [int] # An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.}
@returns(201) Response when creating a secret
@returns(204) Response when updating a secret
@example_request {"encrypted_value":"c2VjcmV0","key_id":"012345678912345678","visibility":"selected","selected_repository_ids":[1296269,1296280]}

@endpoint DELETE /orgs/{org}/actions/secrets/{secret_name}
@desc Delete an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(204) Response

@endpoint GET /orgs/{org}/actions/secrets/{secret_name}/repositories
@desc List selected repositories for an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, repositories: [map]} # Response

@endpoint PUT /orgs/{org}/actions/secrets/{secret_name}/repositories
@desc Set selected repositories for an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., selected_repository_ids: [int] # An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.}
@returns(204) Response
@example_request {"selected_repository_ids":[64780797]}

@endpoint PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
@desc Add selected repository to an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., repository_id: int}
@returns(204) No Content when repository was added to the selected list
@errors {409: Conflict when visibility type is not set to selected}

@endpoint DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
@desc Remove selected repository from an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., repository_id: int}
@returns(204) Response when repository was removed from the selected list
@errors {409: Conflict when visibility type not set to selected}

@endpoint GET /orgs/{org}/actions/variables
@desc List organization variables
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=10 # The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, variables: [map]} # Response

@endpoint POST /orgs/{org}/actions/variables
@desc Create an organization variable
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the variable., value: str # The value of the variable., visibility: str(all/private/selected) # The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.}
@optional {selected_repository_ids: [int] # An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.}
@returns(201) Response when creating a variable
@example_request {"name":"USERNAME","value":"octocat","visibility":"selected","selected_repository_ids":[1296269,1296280]}

@endpoint GET /orgs/{org}/actions/variables/{name}
@desc Get an organization variable
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the variable.}
@returns(200) {name: str, value: str, created_at: str(date-time), updated_at: str(date-time), visibility: str, selected_repositories_url: str(uri)} # Response

@endpoint PATCH /orgs/{org}/actions/variables/{name}
@desc Update an organization variable
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the variable.}
@optional {name: str # The name of the variable., value: str # The value of the variable., visibility: str(all/private/selected) # The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable., selected_repository_ids: [int] # An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.}
@returns(204) Response
@example_request {"name":"USERNAME","value":"octocat","visibility":"selected","selected_repository_ids":[1296269,1296280]}

@endpoint DELETE /orgs/{org}/actions/variables/{name}
@desc Delete an organization variable
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the variable.}
@returns(204) Response

@endpoint GET /orgs/{org}/actions/variables/{name}/repositories
@desc List selected repositories for an organization variable
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the variable.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, repositories: [map]} # Response
@errors {409: Response when the visibility of the variable is not set to `selected`}

@endpoint PUT /orgs/{org}/actions/variables/{name}/repositories
@desc Set selected repositories for an organization variable
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the variable., selected_repository_ids: [int] # The IDs of the repositories that can access the organization variable.}
@returns(204) Response
@errors {409: Response when the visibility of the variable is not set to `selected`}
@example_request {"selected_repository_ids":[64780797]}

@endpoint PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}
@desc Add selected repository to an organization variable
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the variable., repository_id: int}
@returns(204) Response
@errors {409: Response when the visibility of the variable is not set to `selected`}

@endpoint DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}
@desc Remove selected repository from an organization variable
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the variable., repository_id: int}
@returns(204) Response
@errors {409: Response when the visibility of the variable is not set to `selected`}

@endpoint POST /orgs/{org}/artifacts/metadata/deployment-record
@desc Create an artifact deployment record
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the artifact., digest: str # The hex encoded digest of the artifact., status: str(deployed/decommissioned) # The status of the artifact. Can be either deployed or decommissioned., logical_environment: str # The stage of the deployment., deployment_name: str # The unique identifier for the deployment represented by the new record. To accommodate differing containers and namespaces within a cluster, the following format is recommended: {namespaceName}-{deploymentName}-{containerName}.}
@optional {version: str # The artifact version., physical_environment: str # The physical region of the deployment., cluster: str # The deployment cluster., tags: map # The tags associated with the deployment., runtime_risks: [str] # A list of runtime risks associated with the deployment., github_repository: str # The name of the GitHub repository associated with the artifact. This should be used when there are no provenance attestations available for the artifact. The repository must belong to the organization specified in the path parameter.  If a provenance attestation is available for the artifact, the API will use the repository information from the attestation instead of this parameter.}
@returns(200) {total_count: int, deployment_records: [map]} # Artifact deployment record stored successfully.
@example_request {"name":"awesome-image","digest":"sha256:1bb1e949e55dcefc6353e7b36c8897d2a107d8e8dca49d4e3c0ea8493fc0bc72","status":"deployed","logical_environment":"prod","physical_environment":"pacific-east","cluster":"moda-1","deployment_name":"deployment-pod","tags":{"data-access":"sensitive"}}

@endpoint POST /orgs/{org}/artifacts/metadata/deployment-record/cluster/{cluster}
@desc Set cluster deployment records
@required {org: str # The organization name. The name is not case sensitive., cluster: str # The cluster name., logical_environment: str # The stage of the deployment., deployments: [map{name!: str, digest!: str, version: str, status: str, deployment_name!: str, github_repository: str, tags: map, runtime_risks: [str]}] # The list of deployments to record.}
@optional {physical_environment: str # The physical region of the deployment.}
@returns(200) {total_count: int, deployment_records: [map]} # Deployment records created or updated successfully.
@example_request {"logical_environment":"prod","physical_environment":"pacific-east","deployments":[{"name":"awesome-image","digest":"sha256:1bb1e949e55dcefc6353e7b36c8897d2a107d8e8dca49d4e3c0ea8493fc0bc72","version":"2.1.0","status":"deployed","deployment_name":"deployment-pod","tags":{"runtime-risk":"sensitive-data"}}]}

@endpoint POST /orgs/{org}/artifacts/metadata/storage-record
@desc Create artifact metadata storage record
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the artifact., digest: str # The digest of the artifact (algorithm:hex-encoded-digest)., registry_url: str(uri) # The base URL of the artifact registry.}
@optional {version: str # The artifact version., artifact_url: str(uri) # The URL where the artifact is stored., path: str(uri) # The path of the artifact., repository: str # The repository name within the registry., status: str(active/eol/deleted)=active # The status of the artifact (e.g., active, inactive)., github_repository: str # The name of the GitHub repository associated with the artifact. This should be used when there are no provenance attestations available for the artifact. The repository must belong to the organization specified in the path parameter.  If a provenance attestation is available for the artifact, the API will use the repository information from the attestation instead of this parameter.}
@returns(200) {total_count: int, storage_records: [map]} # Artifact metadata storage record stored successfully.
@example_request {"name":"libfoo","version":"1.2.3","digest":"sha256:1bb1e949e55dcefc6353e7b36c8897d2a107d8e8dca49d4e3c0ea8493fc0bc72","artifact_url":"https://reg.example.com/artifactory/bar/libfoo-1.2.3","registry_url":"https://reg.example.com/artifactory/","repository":"bar","status":"active"}

@endpoint GET /orgs/{org}/artifacts/{subject_digest}/metadata/deployment-records
@desc List artifact deployment records
@required {org: str # The organization name. The name is not case sensitive., subject_digest: str # The SHA256 digest of the artifact, in the form `sha256:HEX_DIGEST`.}
@returns(200) {total_count: int, deployment_records: [map]} # Successful response

@endpoint GET /orgs/{org}/artifacts/{subject_digest}/metadata/storage-records
@desc List artifact storage records
@required {org: str # The organization name. The name is not case sensitive., subject_digest: str # The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.}
@returns(200) {total_count: int, storage_records: [map]} # Response

@endpoint POST /orgs/{org}/attestations/bulk-list
@desc List attestations by bulk subject digests
@required {org: str # The organization name. The name is not case sensitive., subject_digests: [str] # List of subject digests to fetch attestations for.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", predicate_type: str # Optional filter for fetching attestations with a given predicate type. This option accepts `provenance`, `sbom`, `release`, or freeform text for custom predicate types.}
@returns(200) {attestations_subject_digests: map, page_info: map{has_next: bool, has_previous: bool, next: str, previous: str}} # Response
@example_request {"subject_digests":["sha256:abc123","sha512:def456"]}

@endpoint POST /orgs/{org}/attestations/delete-request
@desc Delete attestations in bulk
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) Response
@errors {404: Resource not found}
@example_request {"subject_digests":["sha256:abc123","sha512:def456"]}

@endpoint DELETE /orgs/{org}/attestations/digest/{subject_digest}
@desc Delete attestations by subject digest
@required {org: str # The organization name. The name is not case sensitive., subject_digest: str # Subject Digest}
@returns(200) Response
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/attestations/repositories
@desc List attestation repositories
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", predicate_type: str # Optional filter for fetching attestations with a given predicate type. This option accepts `provenance`, `sbom`, `release`, or freeform text for custom predicate types.}
@returns(200) Response

@endpoint DELETE /orgs/{org}/attestations/{attestation_id}
@desc Delete attestations by ID
@required {org: str # The organization name. The name is not case sensitive., attestation_id: int # Attestation ID}
@returns(200) Response
@returns(204) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint GET /orgs/{org}/attestations/{subject_digest}
@desc List attestations
@required {org: str # The organization name. The name is not case sensitive., subject_digest: str # The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", predicate_type: str # Optional filter for fetching attestations with a given predicate type. This option accepts `provenance`, `sbom`, `release`, or freeform text for custom predicate types.}
@returns(200) {attestations: [map]} # Response

@endpoint GET /orgs/{org}/blocks
@desc List users blocked by an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /orgs/{org}/blocks/{username}
@desc Check if a user is blocked by an organization
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) If the user is blocked
@errors {404: If the user is not blocked}

@endpoint PUT /orgs/{org}/blocks/{username}
@desc Block a user from an organization
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed.}

@endpoint DELETE /orgs/{org}/blocks/{username}
@desc Unblock a user from an organization
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response

@endpoint GET /orgs/{org}/campaigns
@desc List campaigns for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", direction: str(asc/desc)=desc # The direction to sort the results by., state: str # If specified, only campaigns with this state will be returned., sort: str(created/updated/ends_at/published)=created # The property by which to sort the results.}
@returns(200) Response
@errors {404: Resource not found, 503: Service unavailable}

@endpoint POST /orgs/{org}/campaigns
@desc Create a campaign for an organization
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the campaign, description: str # A description for the campaign, ends_at: str(date-time) # The end date and time of the campaign. The date must be in the future.}
@optional {managers: [str] # The logins of the users to set as the campaign managers. At this time, only a single manager can be supplied., team_managers: [str] # The slugs of the teams to set as the campaign managers., contact_link: str(uri) # The contact link of the campaign. Must be a URI., code_scanning_alerts: [map{repository_id!: int, alert_numbers!: [int]}] # The code scanning alerts to include in this campaign, generate_issues: bool=False # If true, will automatically generate issues for the campaign. The default is false.}
@returns(200) {number: int, created_at: str(date-time), updated_at: str(date-time), name: str, description: str, managers: [map], team_managers: [map], published_at: str(date-time), ends_at: str(date-time), closed_at: str(date-time)?, state: str, contact_link: str(uri)?, alert_stats: map{open_count: int, closed_count: int, in_progress_count: int}} # Response
@errors {400: Bad Request, 404: Resource not found, 422: Unprocessable Entity, 429: Too Many Requests, 503: Service unavailable}
@example_request {"name":"Critical CodeQL alerts","description":"Address critical alerts before they are exploited to prevent breaches, protect sensitive data, and mitigate financial and reputational damage.","managers":["octocat"],"ends_at":"2024-03-14T00:00:00Z","code_scanning_alerts":[{"repository_id":1296269,"alert_numbers":[1,2]}]}

@endpoint GET /orgs/{org}/campaigns/{campaign_number}
@desc Get a campaign for an organization
@required {org: str # The organization name. The name is not case sensitive., campaign_number: int # The campaign number.}
@returns(200) {number: int, created_at: str(date-time), updated_at: str(date-time), name: str, description: str, managers: [map], team_managers: [map], published_at: str(date-time), ends_at: str(date-time), closed_at: str(date-time)?, state: str, contact_link: str(uri)?, alert_stats: map{open_count: int, closed_count: int, in_progress_count: int}} # Response
@errors {404: Resource not found, 422: Unprocessable Entity, 503: Service unavailable}

@endpoint PATCH /orgs/{org}/campaigns/{campaign_number}
@desc Update a campaign
@required {org: str # The organization name. The name is not case sensitive., campaign_number: int # The campaign number.}
@optional {name: str # The name of the campaign, description: str # A description for the campaign, managers: [str] # The logins of the users to set as the campaign managers. At this time, only a single manager can be supplied., team_managers: [str] # The slugs of the teams to set as the campaign managers., ends_at: str(date-time) # The end date and time of the campaign, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ., contact_link: str(uri) # The contact link of the campaign. Must be a URI., state: str(open/closed) # Indicates whether a campaign is open or closed}
@returns(200) {number: int, created_at: str(date-time), updated_at: str(date-time), name: str, description: str, managers: [map], team_managers: [map], published_at: str(date-time), ends_at: str(date-time), closed_at: str(date-time)?, state: str, contact_link: str(uri)?, alert_stats: map{open_count: int, closed_count: int, in_progress_count: int}} # Response
@errors {400: Bad Request, 404: Resource not found, 422: Unprocessable Entity, 503: Service unavailable}
@example_request {"name":"Critical CodeQL alerts"}

@endpoint DELETE /orgs/{org}/campaigns/{campaign_number}
@desc Delete a campaign for an organization
@required {org: str # The organization name. The name is not case sensitive., campaign_number: int # The campaign number.}
@returns(204) Deletion successful
@errors {404: Resource not found, 503: Service unavailable}

@endpoint GET /orgs/{org}/code-scanning/alerts
@desc List code scanning alerts for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {tool_name: str # The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both., tool_guid: str # The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both., before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", direction: str(asc/desc)=desc # The direction to sort the results by., state: str # If specified, only code scanning alerts with this state will be returned., sort: str(created/updated)=created # The property by which to sort the results., severity: str # If specified, only code scanning alerts with this severity will be returned., assignees: str # Filter alerts by assignees. Provide a comma-separated list of user handles (e.g., `octocat` or `octocat,hubot`). Use `*` to list alerts with at least one assignee or `none` to list alerts with no assignees.}
@returns(200) Response
@errors {404: Resource not found, 503: Service unavailable}

@endpoint GET /orgs/{org}/code-security/configurations
@desc Get code security configurations for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {target_type: str(global/all)=all # The target type of the code security configuration, per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint POST /orgs/{org}/code-security/configurations
@desc Create a code security configuration
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the code security configuration. Must be unique within the organization., description: str # A description of the code security configuration}
@optional {advanced_security: str(enabled/disabled/code_security/secret_protection)=disabled # The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.  > [!WARNING] > `code_security` and `secret_protection` are deprecated values for this field. Prefer the individual `code_security` and `secret_protection` fields to set the status of these features., code_security: str(enabled/disabled/not_set) # The enablement status of GitHub Code Security features., dependency_graph: str(enabled/disabled/not_set)=enabled # The enablement status of Dependency Graph, dependency_graph_autosubmit_action: str(enabled/disabled/not_set)=disabled # The enablement status of Automatic dependency submission, dependency_graph_autosubmit_action_options: map{labeled_runners: bool} # Feature options for Automatic dependency submission, dependabot_alerts: str(enabled/disabled/not_set)=disabled # The enablement status of Dependabot alerts, dependabot_security_updates: str(enabled/disabled/not_set)=disabled # The enablement status of Dependabot security updates, dependabot_delegated_alert_dismissal: str(enabled/disabled/not_set)=disabled # The enablement status of Dependabot delegated alert dismissal. Requires Dependabot alerts to be enabled., code_scanning_options: map{allow_advanced: bool} # Security Configuration feature options for code scanning, code_scanning_default_setup: str(enabled/disabled/not_set)=disabled # The enablement status of code scanning default setup, code_scanning_default_setup_options: map{runner_type: str, runner_label: str} # Feature options for code scanning default setup, code_scanning_delegated_alert_dismissal: str(enabled/disabled/not_set)=not_set # The enablement status of code scanning delegated alert dismissal, secret_protection: str(enabled/disabled/not_set) # The enablement status of GitHub Secret Protection features., secret_scanning: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning, secret_scanning_push_protection: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning push protection, secret_scanning_delegated_bypass: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning delegated bypass, secret_scanning_delegated_bypass_options: map{reviewers: [map]} # Feature options for secret scanning delegated bypass, secret_scanning_validity_checks: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning validity checks, secret_scanning_non_provider_patterns: str(enabled/disabled/not_set)=disabled # The enablement status of secret scanning non provider patterns, secret_scanning_generic_secrets: str(enabled/disabled/not_set)=disabled # The enablement status of Copilot secret scanning, secret_scanning_delegated_alert_dismissal: str(enabled/disabled/not_set) # The enablement status of secret scanning delegated alert dismissal, private_vulnerability_reporting: str(enabled/disabled/not_set)=disabled # The enablement status of private vulnerability reporting, enforcement: str(enforced/unenforced)=enforced # The enforcement status for a security configuration}
@returns(201) {id: int, name: str, target_type: str, description: str, advanced_security: str, dependency_graph: str, dependency_graph_autosubmit_action: str, dependency_graph_autosubmit_action_options: map{labeled_runners: bool}, dependabot_alerts: str, dependabot_security_updates: str, dependabot_delegated_alert_dismissal: str?, code_scanning_options: map?{allow_advanced: bool?}, code_scanning_default_setup: str, code_scanning_default_setup_options: map?{runner_type: str?, runner_label: str?}, code_scanning_delegated_alert_dismissal: str, secret_scanning: str, secret_scanning_push_protection: str, secret_scanning_delegated_bypass: str, secret_scanning_delegated_bypass_options: map{reviewers: [map]}, secret_scanning_validity_checks: str, secret_scanning_non_provider_patterns: str, secret_scanning_generic_secrets: str, secret_scanning_delegated_alert_dismissal: str, private_vulnerability_reporting: str, enforcement: str, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time)} # Successfully created code security configuration
@example_request {"name":"octo-org recommended settings","description":"This is a code security configuration for octo-org","advanced_security":"enabled","dependabot_alerts":"enabled","dependabot_security_updates":"not_set","secret_scanning":"enabled"}

@endpoint GET /orgs/{org}/code-security/configurations/defaults
@desc Get default code security configurations
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 404: Resource not found}

@endpoint DELETE /orgs/{org}/code-security/configurations/detach
@desc Detach configurations from repositories
@required {org: str # The organization name. The name is not case sensitive.}
@optional {selected_repository_ids: [int] # An array of repository IDs to detach from configurations. Up to 250 IDs can be provided.}
@returns(204) A header with no content is returned.
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found, 409: Conflict}
@example_request {"selected_repository_ids":[32,91]}

@endpoint GET /orgs/{org}/code-security/configurations/{configuration_id}
@desc Get a code security configuration
@required {org: str # The organization name. The name is not case sensitive., configuration_id: int # The unique identifier of the code security configuration.}
@returns(200) {id: int, name: str, target_type: str, description: str, advanced_security: str, dependency_graph: str, dependency_graph_autosubmit_action: str, dependency_graph_autosubmit_action_options: map{labeled_runners: bool}, dependabot_alerts: str, dependabot_security_updates: str, dependabot_delegated_alert_dismissal: str?, code_scanning_options: map?{allow_advanced: bool?}, code_scanning_default_setup: str, code_scanning_default_setup_options: map?{runner_type: str?, runner_label: str?}, code_scanning_delegated_alert_dismissal: str, secret_scanning: str, secret_scanning_push_protection: str, secret_scanning_delegated_bypass: str, secret_scanning_delegated_bypass_options: map{reviewers: [map]}, secret_scanning_validity_checks: str, secret_scanning_non_provider_patterns: str, secret_scanning_generic_secrets: str, secret_scanning_delegated_alert_dismissal: str, private_vulnerability_reporting: str, enforcement: str, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {304: Not modified, 403: Forbidden, 404: Resource not found}

@endpoint PATCH /orgs/{org}/code-security/configurations/{configuration_id}
@desc Update a code security configuration
@required {org: str # The organization name. The name is not case sensitive., configuration_id: int # The unique identifier of the code security configuration.}
@optional {name: str # The name of the code security configuration. Must be unique within the organization., description: str # A description of the code security configuration, advanced_security: str(enabled/disabled/code_security/secret_protection) # The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.  > [!WARNING] > `code_security` and `secret_protection` are deprecated values for this field. Prefer the individual `code_security` and `secret_protection` fields to set the status of these features., code_security: str(enabled/disabled/not_set) # The enablement status of GitHub Code Security features., dependency_graph: str(enabled/disabled/not_set) # The enablement status of Dependency Graph, dependency_graph_autosubmit_action: str(enabled/disabled/not_set) # The enablement status of Automatic dependency submission, dependency_graph_autosubmit_action_options: map{labeled_runners: bool} # Feature options for Automatic dependency submission, dependabot_alerts: str(enabled/disabled/not_set) # The enablement status of Dependabot alerts, dependabot_security_updates: str(enabled/disabled/not_set) # The enablement status of Dependabot security updates, dependabot_delegated_alert_dismissal: str(enabled/disabled/not_set) # The enablement status of Dependabot delegated alert dismissal. Requires Dependabot alerts to be enabled., code_scanning_default_setup: str(enabled/disabled/not_set) # The enablement status of code scanning default setup, code_scanning_default_setup_options: map{runner_type: str, runner_label: str} # Feature options for code scanning default setup, code_scanning_options: map{allow_advanced: bool} # Security Configuration feature options for code scanning, code_scanning_delegated_alert_dismissal: str(enabled/disabled/not_set)=disabled # The enablement status of code scanning delegated alert dismissal, secret_protection: str(enabled/disabled/not_set) # The enablement status of GitHub Secret Protection features., secret_scanning: str(enabled/disabled/not_set) # The enablement status of secret scanning, secret_scanning_push_protection: str(enabled/disabled/not_set) # The enablement status of secret scanning push protection, secret_scanning_delegated_bypass: str(enabled/disabled/not_set) # The enablement status of secret scanning delegated bypass, secret_scanning_delegated_bypass_options: map{reviewers: [map]} # Feature options for secret scanning delegated bypass, secret_scanning_validity_checks: str(enabled/disabled/not_set) # The enablement status of secret scanning validity checks, secret_scanning_non_provider_patterns: str(enabled/disabled/not_set) # The enablement status of secret scanning non-provider patterns, secret_scanning_generic_secrets: str(enabled/disabled/not_set) # The enablement status of Copilot secret scanning, secret_scanning_delegated_alert_dismissal: str(enabled/disabled/not_set) # The enablement status of secret scanning delegated alert dismissal, private_vulnerability_reporting: str(enabled/disabled/not_set) # The enablement status of private vulnerability reporting, enforcement: str(enforced/unenforced) # The enforcement status for a security configuration}
@returns(200) {id: int, name: str, target_type: str, description: str, advanced_security: str, dependency_graph: str, dependency_graph_autosubmit_action: str, dependency_graph_autosubmit_action_options: map{labeled_runners: bool}, dependabot_alerts: str, dependabot_security_updates: str, dependabot_delegated_alert_dismissal: str?, code_scanning_options: map?{allow_advanced: bool?}, code_scanning_default_setup: str, code_scanning_default_setup_options: map?{runner_type: str?, runner_label: str?}, code_scanning_delegated_alert_dismissal: str, secret_scanning: str, secret_scanning_push_protection: str, secret_scanning_delegated_bypass: str, secret_scanning_delegated_bypass_options: map{reviewers: [map]}, secret_scanning_validity_checks: str, secret_scanning_non_provider_patterns: str, secret_scanning_generic_secrets: str, secret_scanning_delegated_alert_dismissal: str, private_vulnerability_reporting: str, enforcement: str, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time)} # Response when a configuration is updated
@returns(204) Response when no new updates are made
@example_request {"name":"octo-org recommended settings v2","secret_scanning":"disabled","code_scanning_default_setup":"enabled"}

@endpoint DELETE /orgs/{org}/code-security/configurations/{configuration_id}
@desc Delete a code security configuration
@required {org: str # The organization name. The name is not case sensitive., configuration_id: int # The unique identifier of the code security configuration.}
@returns(204) A header with no content is returned.
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found, 409: Conflict}

@endpoint POST /orgs/{org}/code-security/configurations/{configuration_id}/attach
@desc Attach a configuration to repositories
@required {org: str # The organization name. The name is not case sensitive., configuration_id: int # The unique identifier of the code security configuration., scope: str(all/all_without_configurations/public/private_or_internal/selected) # The type of repositories to attach the configuration to. `selected` means the configuration will be attached to only the repositories specified by `selected_repository_ids`}
@optional {selected_repository_ids: [int] # An array of repository IDs to attach the configuration to. You can only provide a list of repository ids when the `scope` is set to `selected`.}
@returns(202) Accepted
@example_request {"scope":"selected","selected_repository_ids":[32,91]}

@endpoint PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults
@desc Set a code security configuration as a default for an organization
@required {org: str # The organization name. The name is not case sensitive., configuration_id: int # The unique identifier of the code security configuration.}
@optional {default_for_new_repos: str(all/none/private_and_internal/public) # Specify which types of repository this security configuration should be applied to by default.}
@returns(200) {default_for_new_repos: str, configuration: map{id: int, name: str, target_type: str, description: str, advanced_security: str, dependency_graph: str, dependency_graph_autosubmit_action: str, dependency_graph_autosubmit_action_options: map{labeled_runners: bool}, dependabot_alerts: str, dependabot_security_updates: str, dependabot_delegated_alert_dismissal: str?, code_scanning_options: map?{allow_advanced: bool?}, code_scanning_default_setup: str, code_scanning_default_setup_options: map?{runner_type: str?, runner_label: str?}, code_scanning_delegated_alert_dismissal: str, secret_scanning: str, secret_scanning_push_protection: str, secret_scanning_delegated_bypass: str, secret_scanning_delegated_bypass_options: map{reviewers: [map]}, secret_scanning_validity_checks: str, secret_scanning_non_provider_patterns: str, secret_scanning_generic_secrets: str, secret_scanning_delegated_alert_dismissal: str, private_vulnerability_reporting: str, enforcement: str, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time)}} # Default successfully changed.
@errors {403: Forbidden, 404: Resource not found}
@example_request {"default_for_new_repos":"all"}

@endpoint GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories
@desc Get repositories associated with a code security configuration
@required {org: str # The organization name. The name is not case sensitive., configuration_id: int # The unique identifier of the code security configuration.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", status: str=all # A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned.  Can be: `all`, `attached`, `attaching`, `detached`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`}
@returns(200) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint GET /orgs/{org}/codespaces
@desc List codespaces for the organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, codespaces: [map]} # Response
@errors {304: Not modified, 500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint PUT /orgs/{org}/codespaces/access
@desc Manage access control for organization codespaces
@required {org: str # The organization name. The name is not case sensitive., visibility: str(disabled/selected_members/all_members/all_members_and_outside_collaborators) # Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization.}
@optional {selected_usernames: [str] # The usernames of the organization members who should have access to codespaces in the organization. Required when `visibility` is `selected_members`. The provided list of usernames will replace any existing value.}
@returns(204) Response when successfully modifying permissions.
@errors {304: Not modified, 400: Users are neither members nor collaborators of this organization., 404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 500: Internal Error}
@example_request {"visibility":"selected_members","selected_usernames":["johnDoe","atomIO"]}

@endpoint POST /orgs/{org}/codespaces/access/selected_users
@desc Add users to Codespaces access for an organization
@required {org: str # The organization name. The name is not case sensitive., selected_usernames: [str] # The usernames of the organization members whose codespaces be billed to the organization.}
@returns(204) Response when successfully modifying permissions.
@errors {304: Not modified, 400: Users are neither members nor collaborators of this organization., 404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 500: Internal Error}
@example_request {"selected_usernames":["johnDoe","atomIO"]}

@endpoint DELETE /orgs/{org}/codespaces/access/selected_users
@desc Remove users from Codespaces access for an organization
@required {org: str # The organization name. The name is not case sensitive., selected_usernames: [str] # The usernames of the organization members whose codespaces should not be billed to the organization.}
@returns(204) Response when successfully modifying permissions.
@errors {304: Not modified, 400: Users are neither members nor collaborators of this organization., 404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 500: Internal Error}
@example_request {"selected_usernames":["johnDoe","atomIO"]}

@endpoint GET /orgs/{org}/codespaces/secrets
@desc List organization secrets
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, secrets: [map]} # Response

@endpoint GET /orgs/{org}/codespaces/secrets/public-key
@desc Get an organization public key
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {key_id: str, key: str, id: int, url: str, title: str, created_at: str} # Response

@endpoint GET /orgs/{org}/codespaces/secrets/{secret_name}
@desc Get an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(200) {name: str, created_at: str(date-time), updated_at: str(date-time), visibility: str, selected_repositories_url: str(uri)} # Response

@endpoint PUT /orgs/{org}/codespaces/secrets/{secret_name}
@desc Create or update an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., visibility: str(all/private/selected) # Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.}
@optional {encrypted_value: str # The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key) endpoint., key_id: str # The ID of the key you used to encrypt the secret., selected_repository_ids: [int] # An array of repository IDs that can access the organization secret. You can only provide a list of repository IDs when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.}
@returns(201) Response when creating a secret
@returns(204) Response when updating a secret
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"encrypted_value":"c2VjcmV0","key_id":"012345678912345678","visibility":"selected","selected_repository_ids":[1296269,1296280]}

@endpoint DELETE /orgs/{org}/codespaces/secrets/{secret_name}
@desc Delete an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories
@desc List selected repositories for an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, repositories: [map]} # Response
@errors {404: Resource not found}

@endpoint PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories
@desc Set selected repositories for an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., selected_repository_ids: [int] # An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.}
@returns(204) Response
@errors {404: Resource not found, 409: Conflict when visibility type not set to selected}
@example_request {"selected_repository_ids":[64780797]}

@endpoint PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}
@desc Add selected repository to an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., repository_id: int}
@returns(204) No Content when repository was added to the selected list
@errors {404: Resource not found, 409: Conflict when visibility type is not set to selected, 422: Validation failed, or the endpoint has been spammed.}

@endpoint DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}
@desc Remove selected repository from an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., repository_id: int}
@returns(204) Response when repository was removed from the selected list
@errors {404: Resource not found, 409: Conflict when visibility type not set to selected, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /orgs/{org}/copilot/billing
@desc Get Copilot seat information and settings for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {seat_breakdown: map{total: int, added_this_cycle: int, pending_cancellation: int, pending_invitation: int, active_this_cycle: int, inactive_this_cycle: int}, public_code_suggestions: str, ide_chat: str, platform_chat: str, cli: str, seat_management_setting: str, plan_type: str} # OK
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: There is a problem with your account's associated payment method.}

@endpoint GET /orgs/{org}/copilot/billing/seats
@desc List all Copilot seat assignments for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=50 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_seats: int, seats: [map]} # Response
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint POST /orgs/{org}/copilot/billing/selected_teams
@desc Add teams to the Copilot subscription for an organization
@required {org: str # The organization name. The name is not case sensitive., selected_teams: [str] # List of team names within the organization to which to grant access to GitHub Copilot.}
@returns(201) {seats_created: int} # OK
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Copilot Business or Enterprise is not enabled for this organization, billing has not been set up for this organization, a public code suggestions policy has not been set for this organization, or the organization's Copilot access setting is set to enable Copilot for all users or is unconfigured.}
@example_request {"selected_teams":["engteam1","engteam2","engteam3"]}

@endpoint DELETE /orgs/{org}/copilot/billing/selected_teams
@desc Remove teams from the Copilot subscription for an organization
@required {org: str # The organization name. The name is not case sensitive., selected_teams: [str] # The names of teams from which to revoke access to GitHub Copilot.}
@returns(200) {seats_cancelled: int} # OK
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Copilot Business or Enterprise is not enabled for this organization, billing has not been set up for this organization, a public code suggestions policy has not been set for this organization, or the organization's Copilot access setting is set to enable Copilot for all users or is unconfigured.}
@example_request {"selected_teams":["engteam1","engteam2","engteam3"]}

@endpoint POST /orgs/{org}/copilot/billing/selected_users
@desc Add users to the Copilot subscription for an organization
@required {org: str # The organization name. The name is not case sensitive., selected_usernames: [str] # The usernames of the organization members to be granted access to GitHub Copilot.}
@returns(201) {seats_created: int} # OK
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Copilot Business or Enterprise is not enabled for this organization, billing has not been set up for this organization, a public code suggestions policy has not been set for this organization, or the organization's Copilot access setting is set to enable Copilot for all users or is unconfigured.}
@example_request {"selected_usernames":["cooluser1","hacker2","octocat"]}

@endpoint DELETE /orgs/{org}/copilot/billing/selected_users
@desc Remove users from the Copilot subscription for an organization
@required {org: str # The organization name. The name is not case sensitive., selected_usernames: [str] # The usernames of the organization members for which to revoke access to GitHub Copilot.}
@returns(200) {seats_cancelled: int} # OK
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Copilot Business or Enterprise is not enabled for this organization, billing has not been set up for this organization, a public code suggestions policy has not been set for this organization, the seat management setting is set to enable Copilot for all users or is unconfigured, or a user's seat cannot be cancelled because it was assigned to them via a team.}
@example_request {"selected_usernames":["cooluser1","hacker2","octocat"]}

@endpoint GET /orgs/{org}/copilot/metrics
@desc Get Copilot metrics for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {since: str # Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 100 days ago., until: str # Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=100 # The number of days of metrics to display per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {500: Internal Error, 403: Forbidden, 404: Resource not found, 422: Copilot Usage Merics API setting is disabled at the organization or enterprise level.}

@endpoint GET /orgs/{org}/dependabot/alerts
@desc List Dependabot alerts for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {state: str # A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`, severity: str # A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`, ecosystem: str # A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`, package: str # A comma-separated list of package names. If specified, only alerts for these packages will be returned., epss_percentage: str # CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as: - An exact number (`n`) - Comparators such as `>n`, `<n`, `>=n`, `<=n` - A range like `n..n`, where `n` is a number from 0.0 to 1.0  Filters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned., artifact_registry_url: str # A comma-separated list of artifact registry URLs. If specified, only alerts for repositories with storage records matching these URLs will be returned., artifact_registry: str # A comma-separated list of Artifact Registry name strings. If specified, only alerts for repositories with storage records matching these registries will be returned.  Can be: `jfrog-artifactory`, has: any # Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned. Multiple `has` filters can be passed to filter for alerts that have all of the values., runtime_risk: str # A comma-separated list of runtime risk strings. If specified, only alerts for repositories with deployment records matching these risks will be returned.  Can be: `critical-resource`, `internet-exposed`, `sensitive-data`, `lateral-movement`, scope: str(development/runtime) # The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned., sort: str(created/updated/epss_percentage)=created # The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed. `epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage., direction: str(asc/desc)=desc # The direction to sort the results by., before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 400: Bad Request, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /orgs/{org}/dependabot/secrets
@desc List organization secrets
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, secrets: [map]} # Response

@endpoint GET /orgs/{org}/dependabot/secrets/public-key
@desc Get an organization public key
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {key_id: str, key: str} # Response

@endpoint GET /orgs/{org}/dependabot/secrets/{secret_name}
@desc Get an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(200) {name: str, created_at: str(date-time), updated_at: str(date-time), visibility: str, selected_repositories_url: str(uri)} # Response

@endpoint PUT /orgs/{org}/dependabot/secrets/{secret_name}
@desc Create or update an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., visibility: str(all/private/selected) # Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.}
@optional {encrypted_value: str # Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key) endpoint., key_id: str # ID of the key you used to encrypt the secret., selected_repository_ids: [any] # An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints. Use integers when possible, as strings are supported only to maintain backwards compatibility and may be removed in the future.}
@returns(201) Response when creating a secret
@returns(204) Response when updating a secret
@example_request {"encrypted_value":"c2VjcmV0","key_id":"012345678912345678","visibility":"selected","selected_repository_ids":[1296269,1296280]}

@endpoint DELETE /orgs/{org}/dependabot/secrets/{secret_name}
@desc Delete an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(204) Response

@endpoint GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories
@desc List selected repositories for an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, repositories: [map]} # Response

@endpoint PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories
@desc Set selected repositories for an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., selected_repository_ids: [int] # An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.}
@returns(204) Response
@example_request {"selected_repository_ids":[64780797]}

@endpoint PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}
@desc Add selected repository to an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., repository_id: int}
@returns(204) No Content when repository was added to the selected list
@errors {409: Conflict when visibility type is not set to selected}

@endpoint DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}
@desc Remove selected repository from an organization secret
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret., repository_id: int}
@returns(204) Response when repository was removed from the selected list
@errors {409: Conflict when visibility type not set to selected}

@endpoint GET /orgs/{org}/docker/conflicts
@desc Get list of conflicting packages during Docker migration for organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) Response
@errors {403: Forbidden, 401: Requires authentication}

@endpoint GET /orgs/{org}/events
@desc List public organization events
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /orgs/{org}/failed_invitations
@desc List failed organization invitations
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/hooks
@desc List organization webhooks
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /orgs/{org}/hooks
@desc Create an organization webhook
@required {org: str # The organization name. The name is not case sensitive., name: str # Must be passed as "web"., config: map{url!: str(uri), content_type: str, secret: str, insecure_ssl: any, username: str, password: str} # Key/value pairs to provide settings for this webhook.}
@optional {events: [str]=['push'] # Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `["*"]` to receive all possible events., active: bool=True # Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.}
@returns(201) {id: int, url: str(uri), ping_url: str(uri), deliveries_url: str(uri), name: str, events: [str], active: bool, config: map{url: str, insecure_ssl: str, content_type: str, secret: str}, updated_at: str(date-time), created_at: str(date-time), type: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"name":"web","active":true,"events":["push","pull_request"],"config":{"url":"http://example.com/webhook","content_type":"json"}}

@endpoint GET /orgs/{org}/hooks/{hook_id}
@desc Get an organization webhook
@required {org: str # The organization name. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@returns(200) {id: int, url: str(uri), ping_url: str(uri), deliveries_url: str(uri), name: str, events: [str], active: bool, config: map{url: str, insecure_ssl: str, content_type: str, secret: str}, updated_at: str(date-time), created_at: str(date-time), type: str} # Response
@errors {404: Resource not found}

@endpoint PATCH /orgs/{org}/hooks/{hook_id}
@desc Update an organization webhook
@required {org: str # The organization name. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@optional {config: map{url!: str(uri), content_type: str, secret: str, insecure_ssl: any} # Key/value pairs to provide settings for this webhook., events: [str]=['push'] # Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for., active: bool=True # Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications., name: str}
@returns(200) {id: int, url: str(uri), ping_url: str(uri), deliveries_url: str(uri), name: str, events: [str], active: bool, config: map{url: str, insecure_ssl: str, content_type: str, secret: str}, updated_at: str(date-time), created_at: str(date-time), type: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"active":true,"events":["pull_request"]}

@endpoint DELETE /orgs/{org}/hooks/{hook_id}
@desc Delete an organization webhook
@required {org: str # The organization name. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/hooks/{hook_id}/config
@desc Get a webhook configuration for an organization
@required {org: str # The organization name. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@returns(200) {url: str(uri), content_type: str, secret: str, insecure_ssl: any} # Response

@endpoint PATCH /orgs/{org}/hooks/{hook_id}/config
@desc Update a webhook configuration for an organization
@required {org: str # The organization name. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@optional {url: str(uri) # The URL to which the payloads will be delivered., content_type: str # The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`., secret: str # If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers)., insecure_ssl: any}
@returns(200) {url: str(uri), content_type: str, secret: str, insecure_ssl: any} # Response
@example_request {"url":"http://example.com/webhook","content_type":"json","insecure_ssl":"0","secret":"********"}

@endpoint GET /orgs/{org}/hooks/{hook_id}/deliveries
@desc List deliveries for an organization webhook
@required {org: str # The organization name. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", cursor: str # Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.}
@returns(200) Response
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}
@desc Get a webhook delivery for an organization webhook
@required {org: str # The organization name. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery., delivery_id: int}
@returns(200) {id: int, guid: str, delivered_at: str(date-time), redelivery: bool, duration: num, status: str, status_code: int, event: str, action: str?, installation_id: int?, repository_id: int?, throttled_at: str(date-time)?, url: str, request: map{headers: map?, payload: map?}, response: map{headers: map?, payload: str?}} # Response
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}

@endpoint POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
@desc Redeliver a delivery for an organization webhook
@required {org: str # The organization name. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery., delivery_id: int}
@returns(202) Accepted
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}

@endpoint POST /orgs/{org}/hooks/{hook_id}/pings
@desc Ping an organization webhook
@required {org: str # The organization name. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/insights/api/route-stats/{actor_type}/{actor_id}
@desc Get route stats by actor
@required {org: str # The organization name. The name is not case sensitive., actor_type: str(installation/classic_pat/fine_grained_pat/oauth_app/github_app_user_to_server) # The type of the actor, actor_id: int # The ID of the actor, min_timestamp: str # The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@optional {max_timestamp: str # The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", direction: str(asc/desc)=desc # The direction to sort the results by., sort: [str] # The property to sort the results by., api_route_substring: str # Providing a substring will filter results where the API route contains the substring. This is a case-insensitive search.}
@returns(200) Response

@endpoint GET /orgs/{org}/insights/api/subject-stats
@desc Get subject stats
@required {org: str # The organization name. The name is not case sensitive., min_timestamp: str # The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@optional {max_timestamp: str # The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", direction: str(asc/desc)=desc # The direction to sort the results by., sort: [str] # The property to sort the results by., subject_name_substring: str # Providing a substring will filter results where the subject name contains the substring. This is a case-insensitive search.}
@returns(200) Response

@endpoint GET /orgs/{org}/insights/api/summary-stats
@desc Get summary stats
@required {org: str # The organization name. The name is not case sensitive., min_timestamp: str # The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@optional {max_timestamp: str # The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@returns(200) {total_request_count: int(int64), rate_limited_request_count: int(int64)} # Response

@endpoint GET /orgs/{org}/insights/api/summary-stats/users/{user_id}
@desc Get summary stats by user
@required {org: str # The organization name. The name is not case sensitive., user_id: str # The ID of the user to query for stats, min_timestamp: str # The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@optional {max_timestamp: str # The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@returns(200) {total_request_count: int(int64), rate_limited_request_count: int(int64)} # Response

@endpoint GET /orgs/{org}/insights/api/summary-stats/{actor_type}/{actor_id}
@desc Get summary stats by actor
@required {org: str # The organization name. The name is not case sensitive., min_timestamp: str # The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., actor_type: str(installation/classic_pat/fine_grained_pat/oauth_app/github_app_user_to_server) # The type of the actor, actor_id: int # The ID of the actor}
@optional {max_timestamp: str # The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@returns(200) {total_request_count: int(int64), rate_limited_request_count: int(int64)} # Response

@endpoint GET /orgs/{org}/insights/api/time-stats
@desc Get time stats
@required {org: str # The organization name. The name is not case sensitive., min_timestamp: str # The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., timestamp_increment: str # The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)}
@optional {max_timestamp: str # The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@returns(200) Response

@endpoint GET /orgs/{org}/insights/api/time-stats/users/{user_id}
@desc Get time stats by user
@required {org: str # The organization name. The name is not case sensitive., user_id: str # The ID of the user to query for stats, min_timestamp: str # The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., timestamp_increment: str # The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)}
@optional {max_timestamp: str # The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@returns(200) Response

@endpoint GET /orgs/{org}/insights/api/time-stats/{actor_type}/{actor_id}
@desc Get time stats by actor
@required {org: str # The organization name. The name is not case sensitive., actor_type: str(installation/classic_pat/fine_grained_pat/oauth_app/github_app_user_to_server) # The type of the actor, actor_id: int # The ID of the actor, min_timestamp: str # The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., timestamp_increment: str # The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)}
@optional {max_timestamp: str # The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@returns(200) Response

@endpoint GET /orgs/{org}/insights/api/user-stats/{user_id}
@desc Get user stats
@required {org: str # The organization name. The name is not case sensitive., user_id: str # The ID of the user to query for stats, min_timestamp: str # The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@optional {max_timestamp: str # The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", direction: str(asc/desc)=desc # The direction to sort the results by., sort: [str] # The property to sort the results by., actor_name_substring: str # Providing a substring will filter results where the actor name contains the substring. This is a case-insensitive search.}
@returns(200) Response

@endpoint GET /orgs/{org}/installation
@desc Get an organization installation for the authenticated app
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {id: int, account: any?, repository_selection: str, access_tokens_url: str(uri), repositories_url: str(uri), html_url: str(uri), app_id: int, client_id: str, target_id: int, target_type: str, permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str}, events: [str], created_at: str(date-time), updated_at: str(date-time), single_file_name: str?, has_multiple_single_files: bool, single_file_paths: [str], app_slug: str, suspended_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, suspended_at: str(date-time)?, contact_email: str?} # Response

@endpoint GET /orgs/{org}/installations
@desc List app installations for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, installations: [map]} # Response

@endpoint GET /orgs/{org}/interaction-limits
@desc Get interaction restrictions for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) Response

@endpoint PUT /orgs/{org}/interaction-limits
@desc Set interaction restrictions for an organization
@required {org: str # The organization name. The name is not case sensitive., limit: str(existing_users/contributors_only/collaborators_only) # The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.}
@optional {expiry: str(one_day/three_days/one_week/one_month/six_months) # The duration of the interaction restriction. Default: `one_day`.}
@returns(200) {limit: str, origin: str, expires_at: str(date-time)} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"limit":"collaborators_only","expiry":"one_month"}

@endpoint DELETE /orgs/{org}/interaction-limits
@desc Remove interaction restrictions for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(204) Response

@endpoint GET /orgs/{org}/invitations
@desc List pending organization invitations
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", role: str(all/admin/direct_member/billing_manager/hiring_manager)=all # Filter invitations by their member role., invitation_source: str(all/member/scim)=all # Filter invitations by their invitation source.}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /orgs/{org}/invitations
@desc Create an organization invitation
@required {org: str # The organization name. The name is not case sensitive.}
@optional {invitee_id: int # **Required unless you provide `email`**. GitHub user ID for the person you are inviting., email: str # **Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user., role: str(admin/direct_member/billing_manager/reinstate)=direct_member # The role for the new member.   * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.    * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.    * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.   * `reinstate` - The previous role assigned to the invitee before they were removed from your organization. Can be one of the roles listed above. Only works if the invitee was previously part of your organization., team_ids: [int] # Specify IDs for the teams you want to invite new members to.}
@returns(201) {id: int(int64), login: str?, email: str?, role: str, created_at: str, failed_at: str?, failed_reason: str?, inviter: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, team_count: int, node_id: str, invitation_teams_url: str, invitation_source: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"email":"octocat@github.com","role":"direct_member","team_ids":[12,26]}

@endpoint DELETE /orgs/{org}/invitations/{invitation_id}
@desc Cancel an organization invitation
@required {org: str # The organization name. The name is not case sensitive., invitation_id: int # The unique identifier of the invitation.}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}

@endpoint GET /orgs/{org}/invitations/{invitation_id}/teams
@desc List organization invitation teams
@required {org: str # The organization name. The name is not case sensitive., invitation_id: int # The unique identifier of the invitation.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/issue-types
@desc List issue types for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /orgs/{org}/issue-types
@desc Create issue type for an organization
@required {org: str # The organization name. The name is not case sensitive., name: str # Name of the issue type., is_enabled: bool # Whether or not the issue type is enabled at the organization level.}
@optional {description: str # Description of the issue type., color: str(gray/blue/green/yellow/orange/red/pink/purple) # Color for the issue type.}
@returns(200) {id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"name":"Epic","description":"An issue type for a multi-week tracking of work","is_enabled":true,"color":"green"}

@endpoint PUT /orgs/{org}/issue-types/{issue_type_id}
@desc Update issue type for an organization
@required {org: str # The organization name. The name is not case sensitive., issue_type_id: int # The unique identifier of the issue type., name: str # Name of the issue type., is_enabled: bool # Whether or not the issue type is enabled at the organization level.}
@optional {description: str # Description of the issue type., color: str(gray/blue/green/yellow/orange/red/pink/purple) # Color for the issue type.}
@returns(200) {id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"name":"Epic","description":"An issue type for a multi-week tracking of work","is_enabled":true,"color":"green"}

@endpoint DELETE /orgs/{org}/issue-types/{issue_type_id}
@desc Delete issue type for an organization
@required {org: str # The organization name. The name is not case sensitive., issue_type_id: int # The unique identifier of the issue type.}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}

@endpoint GET /orgs/{org}/issues
@desc List organization issues assigned to the authenticated user
@required {org: str # The organization name. The name is not case sensitive.}
@optional {filter: str(assigned/created/mentioned/subscribed/repos/all)=assigned # Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation., state: str(open/closed/all)=open # Indicates the state of the issues to return., labels: str # A list of comma separated label names. Example: `bug,ui,@high`, type: str # Can be the name of an issue type., sort: str(created/updated/comments)=created # What to sort results by., direction: str(asc/desc)=desc # The direction to sort the results by., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/members
@desc List organization members
@required {org: str # The organization name. The name is not case sensitive.}
@optional {filter: str(2fa_disabled/2fa_insecure/all)=all # Filter members returned in the list. `2fa_disabled` means that only members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. `2fa_insecure` means that only members with [insecure 2FA methods](https://docs.github.com/organizations/keeping-your-organization-secure/managing-two-factor-authentication-for-your-organization/requiring-two-factor-authentication-in-your-organization#requiring-secure-methods-of-two-factor-authentication-in-your-organization) will be returned. These options are only available for organization owners., role: str(all/admin/member)=all # Filter members returned by their role., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /orgs/{org}/members/{username}
@desc Check organization membership for a user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response if requester is an organization member and user is a member
@errors {302: Response if requester is not an organization member, 404: Not Found if requester is an organization member and user is not a member}

@endpoint DELETE /orgs/{org}/members/{username}
@desc Remove an organization member
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {403: Forbidden}

@endpoint GET /orgs/{org}/members/{username}/codespaces
@desc List codespaces for a user in organization
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, codespaces: [map]} # Response
@errors {304: Not modified, 500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}
@desc Delete a codespace from the organization
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account., codespace_name: str # The name of the codespace.}
@returns(202) Accepted
@errors {304: Not modified, 500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop
@desc Stop a codespace for an organization user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account., codespace_name: str # The name of the codespace.}
@returns(200) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response
@errors {304: Not modified, 500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint GET /orgs/{org}/members/{username}/copilot
@desc Get Copilot seat assignment details for a user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(200) {assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, organization: map?{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?}, assigning_team: any?, pending_cancellation_date: str(date)?, last_activity_at: str(date-time)?, last_activity_editor: str?, last_authenticated_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), plan_type: str} # The user's GitHub Copilot seat details, including usage.
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Copilot Business or Enterprise is not enabled for this organization or the user has a pending organization invitation.}

@endpoint GET /orgs/{org}/memberships/{username}
@desc Get organization membership for a user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(200) {url: str(uri), state: str, role: str, direct_membership: bool, enterprise_teams_providing_indirect_membership: [str], organization_url: str(uri), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?}, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, permissions: map{can_create_repository: bool}} # Response
@errors {404: Resource not found, 403: Forbidden}

@endpoint PUT /orgs/{org}/memberships/{username}
@desc Set organization membership for a user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@optional {role: str(admin/member)=member # The role to give the user in the organization. Can be one of:    * `admin` - The user will become an owner of the organization.    * `member` - The user will become a non-owner member of the organization.}
@returns(200) {url: str(uri), state: str, role: str, direct_membership: bool, enterprise_teams_providing_indirect_membership: [str], organization_url: str(uri), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?}, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, permissions: map{can_create_repository: bool}} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"role":"member"}

@endpoint DELETE /orgs/{org}/memberships/{username}
@desc Remove organization membership for a user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint GET /orgs/{org}/migrations
@desc List organization migrations
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", exclude: [str] # Exclude attributes from the API response to improve performance}
@returns(200) Response

@endpoint POST /orgs/{org}/migrations
@desc Start an organization migration
@required {org: str # The organization name. The name is not case sensitive., repositories: [str] # A list of arrays indicating which repositories should be migrated.}
@optional {lock_repositories: bool=False # Indicates whether repositories should be locked (to prevent manipulation) while migrating data., exclude_metadata: bool=False # Indicates whether metadata should be excluded and only git source should be included for the migration., exclude_git_data: bool=False # Indicates whether the repository git data should be excluded from the migration., exclude_attachments: bool=False # Indicates whether attachments should be excluded from the migration (to reduce migration archive file size)., exclude_releases: bool=False # Indicates whether releases should be excluded from the migration (to reduce migration archive file size)., exclude_owner_projects: bool=False # Indicates whether projects owned by the organization or users should be excluded. from the migration., org_metadata_only: bool=False # Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags)., exclude: [str] # Exclude related items from being returned in the response in order to improve performance of the request.}
@returns(201) {id: int(int64), owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, guid: str, state: str, lock_repositories: bool, exclude_metadata: bool, exclude_git_data: bool, exclude_attachments: bool, exclude_releases: bool, exclude_owner_projects: bool, org_metadata_only: bool, repositories: [map], url: str(uri), created_at: str(date-time), updated_at: str(date-time), node_id: str, archive_url: str(uri), exclude: [str]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"repositories":["github/Hello-World"],"lock_repositories":true}

@endpoint GET /orgs/{org}/migrations/{migration_id}
@desc Get an organization migration status
@required {org: str # The organization name. The name is not case sensitive., migration_id: int # The unique identifier of the migration.}
@optional {exclude: [str] # Exclude attributes from the API response to improve performance}
@returns(200) {id: int(int64), owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, guid: str, state: str, lock_repositories: bool, exclude_metadata: bool, exclude_git_data: bool, exclude_attachments: bool, exclude_releases: bool, exclude_owner_projects: bool, org_metadata_only: bool, repositories: [map], url: str(uri), created_at: str(date-time), updated_at: str(date-time), node_id: str, archive_url: str(uri), exclude: [str]} # *   `pending`, which means the migration hasn't started yet. *   `exporting`, which means the migration is in progress. *   `exported`, which means the migration finished successfully. *   `failed`, which means the migration failed.
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/migrations/{migration_id}/archive
@desc Download an organization migration archive
@required {org: str # The organization name. The name is not case sensitive., migration_id: int # The unique identifier of the migration.}
@errors {302: Response, 404: Resource not found}

@endpoint DELETE /orgs/{org}/migrations/{migration_id}/archive
@desc Delete an organization migration archive
@required {org: str # The organization name. The name is not case sensitive., migration_id: int # The unique identifier of the migration.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
@desc Unlock an organization repository
@required {org: str # The organization name. The name is not case sensitive., migration_id: int # The unique identifier of the migration., repo_name: str # repo_name parameter}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/migrations/{migration_id}/repositories
@desc List repositories in an organization migration
@required {org: str # The organization name. The name is not case sensitive., migration_id: int # The unique identifier of the migration.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/organization-roles
@desc Get all organization roles for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {total_count: int, roles: [map]} # Response - list of organization roles
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint DELETE /orgs/{org}/organization-roles/teams/{team_slug}
@desc Remove all organization roles for a team
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@returns(204) Response

@endpoint PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}
@desc Assign an organization role to a team
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name., role_id: int # The unique identifier of the role.}
@returns(204) Response
@errors {404: Response if the organization, team or role does not exist., 422: Response if the organization roles feature is not enabled for the organization, or validation failed.}

@endpoint DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}
@desc Remove an organization role from a team
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name., role_id: int # The unique identifier of the role.}
@returns(204) Response

@endpoint DELETE /orgs/{org}/organization-roles/users/{username}
@desc Remove all organization roles for a user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response

@endpoint PUT /orgs/{org}/organization-roles/users/{username}/{role_id}
@desc Assign an organization role to a user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account., role_id: int # The unique identifier of the role.}
@returns(204) Response
@errors {404: Response if the organization, user or role does not exist., 422: Response if the organization roles feature is not enabled enabled for the organization, the validation failed, or the user is not an organization member.}

@endpoint DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}
@desc Remove an organization role from a user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account., role_id: int # The unique identifier of the role.}
@returns(204) Response

@endpoint GET /orgs/{org}/organization-roles/{role_id}
@desc Get an organization role
@required {org: str # The organization name. The name is not case sensitive., role_id: int # The unique identifier of the role.}
@returns(200) {id: int(int64), name: str, description: str?, base_role: str?, source: str?, permissions: [str], organization: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /orgs/{org}/organization-roles/{role_id}/teams
@desc List teams that are assigned to an organization role
@required {org: str # The organization name. The name is not case sensitive., role_id: int # The unique identifier of the role.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response - List of assigned teams
@errors {404: Response if the organization or role does not exist., 422: Response if the organization roles feature is not enabled or validation failed.}

@endpoint GET /orgs/{org}/organization-roles/{role_id}/users
@desc List users that are assigned to an organization role
@required {org: str # The organization name. The name is not case sensitive., role_id: int # The unique identifier of the role.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response - List of assigned users
@errors {404: Response if the organization or role does not exist., 422: Response if the organization roles feature is not enabled or validation failed.}

@endpoint GET /orgs/{org}/outside_collaborators
@desc List outside collaborators for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {filter: str(2fa_disabled/2fa_insecure/all)=all # Filter the list of outside collaborators. `2fa_disabled` means that only outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. `2fa_insecure` means that only outside collaborators with [insecure 2FA methods](https://docs.github.com/organizations/keeping-your-organization-secure/managing-two-factor-authentication-for-your-organization/requiring-two-factor-authentication-in-your-organization#requiring-secure-methods-of-two-factor-authentication-in-your-organization) will be returned., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint PUT /orgs/{org}/outside_collaborators/{username}
@desc Convert an organization member to outside collaborator
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@optional {async: bool=False # When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.}
@returns(202) User is getting converted asynchronously
@returns(204) User was converted
@errors {403: Forbidden if user is the last owner of the organization, not a member of the organization, or if the enterprise enforces a policy for inviting outside collaborators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories).", 404: Resource not found}
@example_request {"async":true}

@endpoint DELETE /orgs/{org}/outside_collaborators/{username}
@desc Remove outside collaborator from an organization
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {422: Unprocessable Entity if user is a member of the organization}

@endpoint GET /orgs/{org}/packages
@desc List packages for an organization
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., org: str # The organization name. The name is not case sensitive.}
@optional {visibility: str(public/private/internal) # The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`. For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {403: Forbidden, 401: Requires authentication, 400: The value of `per_page` multiplied by `page` cannot be greater than 10000.}

@endpoint GET /orgs/{org}/packages/{package_type}/{package_name}
@desc Get a package for an organization
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., org: str # The organization name. The name is not case sensitive.}
@returns(200) {id: int, name: str, package_type: str, url: str, html_url: str, version_count: int, visibility: str, owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map?{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint DELETE /orgs/{org}/packages/{package_type}/{package_name}
@desc Delete a package for an organization
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., org: str # The organization name. The name is not case sensitive.}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /orgs/{org}/packages/{package_type}/{package_name}/restore
@desc Restore a package for an organization
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., org: str # The organization name. The name is not case sensitive.}
@optional {token: str # package token}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /orgs/{org}/packages/{package_type}/{package_name}/versions
@desc List package versions for a package owned by an organization
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., org: str # The organization name. The name is not case sensitive.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", state: str(active/deleted)=active # The state of the package, either active or deleted.}
@returns(200) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
@desc Get a package version for an organization
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., org: str # The organization name. The name is not case sensitive., package_version_id: int # Unique identifier of the package version.}
@returns(200) {id: int, name: str, url: str, package_html_url: str, html_url: str, license: str, description: str, created_at: str(date-time), updated_at: str(date-time), deleted_at: str(date-time), metadata: map{package_type: str, container: map{tags: [str]}, docker: map{tag: [str]}}} # Response

@endpoint DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
@desc Delete package version for an organization
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., org: str # The organization name. The name is not case sensitive., package_version_id: int # Unique identifier of the package version.}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
@desc Restore package version for an organization
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., org: str # The organization name. The name is not case sensitive., package_version_id: int # Unique identifier of the package version.}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /orgs/{org}/personal-access-token-requests
@desc List requests to access organization resources with fine-grained personal access tokens
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", sort: str=created_at # The property by which to sort the results., direction: str(asc/desc)=desc # The direction to sort the results by., owner: [str] # A list of owner usernames to use to filter the results., repository: str # The name of the repository to use to filter the results., permission: str # The permission to use to filter the results., last_used_before: str(date-time) # Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., last_used_after: str(date-time) # Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., token_id: [str] # The ID of the token}
@returns(200) Response
@errors {500: Internal Error, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 403: Forbidden}

@endpoint POST /orgs/{org}/personal-access-token-requests
@desc Review requests to access organization resources with fine-grained personal access tokens
@required {org: str # The organization name. The name is not case sensitive., action: str(approve/deny) # Action to apply to the requests.}
@optional {pat_request_ids: [int] # Unique identifiers of the requests for access via fine-grained personal access token. Must be formed of between 1 and 100 `pat_request_id` values., reason: str # Reason for approving or denying the requests. Max 1024 characters.}
@returns(202) Accepted
@errors {500: Internal Error, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 403: Forbidden}
@example_request {"pat_request_ids":[42,73],"action":"deny","reason":"Access is too broad."}

@endpoint POST /orgs/{org}/personal-access-token-requests/{pat_request_id}
@desc Review a request to access organization resources with a fine-grained personal access token
@required {org: str # The organization name. The name is not case sensitive., pat_request_id: int # Unique identifier of the request for access via fine-grained personal access token., action: str(approve/deny) # Action to apply to the request.}
@optional {reason: str # Reason for approving or denying the request. Max 1024 characters.}
@returns(204) A header with no content is returned.
@errors {500: Internal Error, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 403: Forbidden}
@example_request {"action":"deny","reason":"This request is denied because the access is too broad."}

@endpoint GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories
@desc List repositories requested to be accessed by a fine-grained personal access token
@required {org: str # The organization name. The name is not case sensitive., pat_request_id: int # Unique identifier of the request for access via fine-grained personal access token.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {500: Internal Error, 404: Resource not found, 403: Forbidden}

@endpoint GET /orgs/{org}/personal-access-tokens
@desc List fine-grained personal access tokens with access to organization resources
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", sort: str=created_at # The property by which to sort the results., direction: str(asc/desc)=desc # The direction to sort the results by., owner: [str] # A list of owner usernames to use to filter the results., repository: str # The name of the repository to use to filter the results., permission: str # The permission to use to filter the results., last_used_before: str(date-time) # Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., last_used_after: str(date-time) # Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., token_id: [str] # The ID of the token}
@returns(200) Response
@errors {500: Internal Error, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 403: Forbidden}

@endpoint POST /orgs/{org}/personal-access-tokens
@desc Update the access to organization resources via fine-grained personal access tokens
@required {org: str # The organization name. The name is not case sensitive., action: str # Action to apply to the fine-grained personal access token., pat_ids: [int] # The IDs of the fine-grained personal access tokens.}
@returns(202) Accepted
@errors {500: Internal Error, 404: Resource not found, 403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"action":"revoke","pat_ids":[1296269,1296280]}

@endpoint POST /orgs/{org}/personal-access-tokens/{pat_id}
@desc Update the access a fine-grained personal access token has to organization resources
@required {org: str # The organization name. The name is not case sensitive., pat_id: int # The unique identifier of the fine-grained personal access token., action: str # Action to apply to the fine-grained personal access token.}
@returns(204) A header with no content is returned.
@errors {500: Internal Error, 404: Resource not found, 403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"action":"revoke"}

@endpoint GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories
@desc List repositories a fine-grained personal access token has access to
@required {org: str # The organization name. The name is not case sensitive., pat_id: int # Unique identifier of the fine-grained personal access token.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {500: Internal Error, 404: Resource not found, 403: Forbidden}

@endpoint GET /orgs/{org}/private-registries
@desc List private registries for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, configurations: [map]} # Response
@errors {400: Bad Request, 404: Resource not found}

@endpoint POST /orgs/{org}/private-registries
@desc Create a private registry for an organization
@required {org: str # The organization name. The name is not case sensitive., registry_type: str(maven_repository/nuget_feed/goproxy_server/npm_registry/rubygems_server/cargo_registry/composer_repository/docker_registry/git_source/helm_registry/hex_organization/hex_repository/pub_repository/python_index/terraform_registry) # The registry type., url: str(uri) # The URL of the private registry., encrypted_value: str # The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint., key_id: str # The ID of the key you used to encrypt the secret., visibility: str(all/private/selected) # Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.}
@optional {username: str # The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication., replaces_base: bool=False # Whether this private registry should replace the base registry (e.g., npmjs.org for npm, rubygems.org for rubygems). When set to `true`, Dependabot will only use this registry and will not fall back to the public registry. When set to `false` (default), Dependabot will use this registry for scoped packages but may fall back to the public registry for other packages., selected_repository_ids: [int] # An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. You can manage the list of selected repositories using the [Update a private registry for an organization](https://docs.github.com/rest/private-registries/organization-configurations#update-a-private-registry-for-an-organization) endpoint. This field should be omitted if `visibility` is set to `all` or `private`.}
@returns(201) {name: str, registry_type: str, url: str(uri), username: str, replaces_base: bool, visibility: str, selected_repository_ids: [int], created_at: str(date-time), updated_at: str(date-time)} # The organization private registry configuration
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"registry_type":"maven_repository","url":"https://maven.pkg.github.com/organization/","username":"monalisa","replaces_base":true,"encrypted_value":"c2VjcmV0","key_id":"012345678912345678","visibility":"private"}

@endpoint GET /orgs/{org}/private-registries/public-key
@desc Get private registries public key for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {key_id: str, key: str} # Response
@errors {404: Resource not found}

@endpoint GET /orgs/{org}/private-registries/{secret_name}
@desc Get a private registry for an organization
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(200) {name: str, registry_type: str, url: str(uri), username: str?, replaces_base: bool, visibility: str, created_at: str(date-time), updated_at: str(date-time)} # The specified private registry configuration for the organization
@errors {404: Resource not found}

@endpoint PATCH /orgs/{org}/private-registries/{secret_name}
@desc Update a private registry for an organization
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@optional {registry_type: str(maven_repository/nuget_feed/goproxy_server/npm_registry/rubygems_server/cargo_registry/composer_repository/docker_registry/git_source/helm_registry/hex_organization/hex_repository/pub_repository/python_index/terraform_registry) # The registry type., url: str(uri) # The URL of the private registry., username: str # The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication., replaces_base: bool=False # Whether this private registry should replace the base registry (e.g., npmjs.org for npm, rubygems.org for rubygems). When set to `true`, Dependabot will only use this registry and will not fall back to the public registry. When set to `false` (default), Dependabot will use this registry for scoped packages but may fall back to the public registry for other packages., encrypted_value: str # The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint., key_id: str # The ID of the key you used to encrypt the secret., visibility: str(all/private/selected) # Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry., selected_repository_ids: [int] # An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. This field should be omitted if `visibility` is set to `all` or `private`.}
@returns(204) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"username":"monalisa","encrypted_value":"c2VjcmV0","key_id":"012345678912345678"}

@endpoint DELETE /orgs/{org}/private-registries/{secret_name}
@desc Delete a private registry for an organization
@required {org: str # The organization name. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(204) Response
@errors {400: Bad Request, 404: Resource not found}

@endpoint GET /orgs/{org}/projectsV2
@desc List projects for organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {q: str # Limit results to projects of the specified type., before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /orgs/{org}/projectsV2/{project_number}
@desc Get project for organization
@required {project_number: int # The project's number., org: str # The organization name. The name is not case sensitive.}
@returns(200) {id: num, node_id: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, title: str, description: str?, public: bool, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), number: int, short_description: str?, deleted_at: str(date-time)?, deleted_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, state: str, latest_status_update: map?{id: num, node_id: str, project_node_id: str, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), status: str?, start_date: str(date), target_date: str(date), body: str?}, is_template: bool} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint POST /orgs/{org}/projectsV2/{project_number}/drafts
@desc Create draft item for organization owned project
@required {org: str # The organization name. The name is not case sensitive., project_number: int # The project's number., title: str # The title of the draft issue item to create in the project.}
@optional {body: str # The body content of the draft issue item to create in the project.}
@returns(201) {id: num, node_id: str, content: any, content_type: str, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, project_url: str(uri), item_url: str(uri)} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}
@example_request {"title":"Sample Draft Issue Title"}

@endpoint GET /orgs/{org}/projectsV2/{project_number}/fields
@desc List project fields for organization
@required {project_number: int # The project's number., org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint POST /orgs/{org}/projectsV2/{project_number}/fields
@desc Add a field to an organization-owned project.
@required {project_number: int # The project's number., org: str # The organization name. The name is not case sensitive.}
@returns(201) {id: int, node_id: str, project_url: str, name: str, data_type: str, options: [map], configuration: map{start_day: int, duration: int, iterations: [map]}, created_at: str(date-time), updated_at: str(date-time)} # Response for adding a field to an organization-owned project.
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"name":"Team notes","data_type":"text"}

@endpoint GET /orgs/{org}/projectsV2/{project_number}/fields/{field_id}
@desc Get project field for organization
@required {project_number: int # The project's number., field_id: int # The unique identifier of the field., org: str # The organization name. The name is not case sensitive.}
@returns(200) {id: int, node_id: str, project_url: str, name: str, data_type: str, options: [map], configuration: map{start_day: int, duration: int, iterations: [map]}, created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /orgs/{org}/projectsV2/{project_number}/items
@desc List items for an organization owned project
@required {project_number: int # The project's number., org: str # The organization name. The name is not case sensitive.}
@optional {q: str # Search query to filter items, see [Filtering projects](https://docs.github.com/issues/planning-and-tracking-with-projects/customizing-views-in-your-project/filtering-projects) for more information., fields: any # Limit results to specific fields, by their IDs. If not specified, the title field will be returned.  Example: `fields[]=123&fields[]=456&fields[]=789` or `fields=123,456,789`, before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint POST /orgs/{org}/projectsV2/{project_number}/items
@desc Add item to organization owned project
@required {org: str # The organization name. The name is not case sensitive., project_number: int # The project's number., type: str(Issue/PullRequest) # The type of item to add to the project. Must be either Issue or PullRequest.}
@optional {id: int # The unique identifier of the issue or pull request to add to the project., owner: str # The repository owner login., repo: str # The repository name., number: int # The issue or pull request number.}
@returns(201) {id: num, node_id: str, content: any, content_type: str, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, project_url: str(uri), item_url: str(uri)} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}
@example_request {"type":"Issue","id":3}

@endpoint GET /orgs/{org}/projectsV2/{project_number}/items/{item_id}
@desc Get an item for an organization owned project
@required {project_number: int # The project's number., org: str # The organization name. The name is not case sensitive., item_id: int # The unique identifier of the project item.}
@optional {fields: any # Limit results to specific fields, by their IDs. If not specified, the title field will be returned.  Example: fields[]=123&fields[]=456&fields[]=789 or fields=123,456,789}
@returns(200) {id: num, node_id: str, project_url: str(uri), content_type: str, content: map?, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, item_url: str(uri)?, fields: [map]} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint PATCH /orgs/{org}/projectsV2/{project_number}/items/{item_id}
@desc Update project item for organization
@required {project_number: int # The project's number., org: str # The organization name. The name is not case sensitive., item_id: int # The unique identifier of the project item., fields: [map{id!: int, value!: any}] # A list of field updates to apply.}
@returns(200) {id: num, node_id: str, project_url: str(uri), content_type: str, content: map?, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, item_url: str(uri)?, fields: [map]} # Response
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"fields":[{"id":123,"value":"Updated text value"}]}

@endpoint DELETE /orgs/{org}/projectsV2/{project_number}/items/{item_id}
@desc Delete project item for organization
@required {project_number: int # The project's number., org: str # The organization name. The name is not case sensitive., item_id: int # The unique identifier of the project item.}
@returns(204) Response
@errors {403: Forbidden, 401: Requires authentication}

@endpoint POST /orgs/{org}/projectsV2/{project_number}/views
@desc Create a view for an organization-owned project
@required {org: str # The organization name. The name is not case sensitive., project_number: int # The project's number., name: str # The name of the view., layout: str(table/board/roadmap) # The layout of the view.}
@optional {filter: str # The filter query for the view. See [Filtering projects](https://docs.github.com/issues/planning-and-tracking-with-projects/customizing-views-in-your-project/filtering-projects) for more information., visible_fields: [int] # `visible_fields` is not applicable to `roadmap` layout views. For `table` and `board` layouts, this represents the field IDs that should be visible in the view. If not provided, the default visible fields will be used.}
@returns(201) {id: int, number: int, name: str, layout: str, node_id: str, project_url: str, html_url: str(uri), creator: any, created_at: str(date-time), updated_at: str(date-time), filter: str?, visible_fields: [int], sort_by: [[any]], group_by: [int], vertical_group_by: [int]} # Response for creating a view in an organization-owned project.
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 503: Service unavailable}
@example_request {"name":"All Issues","layout":"table","filter":"is:issue","visible_fields":[123,456,789]}

@endpoint GET /orgs/{org}/projectsV2/{project_number}/views/{view_number}/items
@desc List items for an organization project view
@required {project_number: int # The project's number., org: str # The organization name. The name is not case sensitive., view_number: int # The number that identifies the project view.}
@optional {fields: any # Limit results to specific fields, by their IDs. If not specified, the title field will be returned.  Example: `fields[]=123&fields[]=456&fields[]=789` or `fields=123,456,789`, before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication, 404: Resource not found}

@endpoint GET /orgs/{org}/properties/schema
@desc Get all custom properties for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PATCH /orgs/{org}/properties/schema
@desc Create or update custom properties for an organization
@required {org: str # The organization name. The name is not case sensitive., properties: [map{property_name!: str, url: str(uri), source_type: str, value_type!: str, required: bool, default_value: any, description: str, allowed_values: [str], values_editable_by: str}] # The array of custom properties to create or update.}
@returns(200) Response
@errors {403: Forbidden, 404: Resource not found}
@example_request {"properties":[{"property_name":"environment","value_type":"single_select","required":true,"default_value":"production","description":"Prod or dev environment","allowed_values":["production","development"],"values_editable_by":"org_actors"},{"property_name":"service","value_type":"string"},{"property_name":"team","value_type":"string","description":"Team owning the repository"}]}

@endpoint GET /orgs/{org}/properties/schema/{custom_property_name}
@desc Get a custom property for an organization
@required {org: str # The organization name. The name is not case sensitive., custom_property_name: str # The custom property name}
@returns(200) {property_name: str, url: str(uri), source_type: str, value_type: str, required: bool, default_value: any?, description: str?, allowed_values: [str]?, values_editable_by: str?} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /orgs/{org}/properties/schema/{custom_property_name}
@desc Create or update a custom property for an organization
@required {org: str # The organization name. The name is not case sensitive., custom_property_name: str # The custom property name, value_type: str(string/single_select/multi_select/true_false/url) # The type of the value for the property}
@optional {required: bool # Whether the property is required., default_value: any # Default value of the property, description: str # Short description of the property, allowed_values: [str] # An ordered list of the allowed values of the property. The property can have up to 200 allowed values., values_editable_by: str(org_actors/org_and_repo_actors) # Who can edit the values of the property}
@returns(200) {property_name: str, url: str(uri), source_type: str, value_type: str, required: bool, default_value: any?, description: str?, allowed_values: [str]?, values_editable_by: str?} # Response
@errors {403: Forbidden, 404: Resource not found}
@example_request {"value_type":"single_select","required":true,"default_value":"production","description":"Prod or dev environment","allowed_values":["production","development"]}

@endpoint DELETE /orgs/{org}/properties/schema/{custom_property_name}
@desc Remove a custom property for an organization
@required {org: str # The organization name. The name is not case sensitive., custom_property_name: str # The custom property name}
@returns(204) A header with no content is returned.
@errors {403: Forbidden, 404: Resource not found}

@endpoint GET /orgs/{org}/properties/values
@desc List custom property values for organization repositories
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", repository_query: str # Finds repositories in the organization with a query containing one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.}
@returns(200) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PATCH /orgs/{org}/properties/values
@desc Create or update custom property values for organization repositories
@required {org: str # The organization name. The name is not case sensitive., repository_names: [str] # The names of repositories that the custom property values will be applied to., properties: [map{property_name!: str, value!: any}] # List of custom property names and associated values to apply to the repositories.}
@returns(204) No Content when custom property values are successfully created or updated
@errors {403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"repository_names":["Hello-World","octo-repo"],"properties":[{"property_name":"environment","value":"production"},{"property_name":"service","value":"web"},{"property_name":"team","value":"octocat"}]}

@endpoint GET /orgs/{org}/public_members
@desc List public organization members
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /orgs/{org}/public_members/{username}
@desc Check public organization membership for a user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response if user is a public member
@errors {404: Not Found if user is not a public member}

@endpoint PUT /orgs/{org}/public_members/{username}
@desc Set public organization membership for the authenticated user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {403: Forbidden}

@endpoint DELETE /orgs/{org}/public_members/{username}
@desc Remove public organization membership for the authenticated user
@required {org: str # The organization name. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response

@endpoint GET /orgs/{org}/repos
@desc List organization repositories
@required {org: str # The organization name. The name is not case sensitive.}
@optional {type: str(all/public/private/forks/sources/member)=all # Specifies the types of repositories you want returned., sort: str(created/updated/pushed/full_name)=created # The property to sort the results by., direction: str(asc/desc) # The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint POST /orgs/{org}/repos
@desc Create an organization repository
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the repository.}
@optional {description: str # A short description of the repository., homepage: str # A URL with more information about the repository., private: bool=False # Whether the repository is private., visibility: str(public/private) # The visibility of the repository., has_issues: bool=True # Either `true` to enable issues for this repository or `false` to disable them., has_projects: bool=True # Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error., has_wiki: bool=True # Either `true` to enable the wiki for this repository or `false` to disable it., has_downloads: bool=True # Whether downloads are enabled., is_template: bool=False # Either `true` to make this repo available as a template repository or `false` to prevent it., team_id: int # The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization., auto_init: bool=False # Pass `true` to create an initial commit with empty README., gitignore_template: str # Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell"., license_template: str # Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0"., allow_squash_merge: bool=True # Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging., allow_merge_commit: bool=True # Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits., allow_rebase_merge: bool=True # Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging., allow_auto_merge: bool=False # Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge., delete_branch_on_merge: bool=False # Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**, use_squash_pr_title_as_default: bool=False # Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead., squash_merge_commit_title: str(PR_TITLE/COMMIT_OR_PR_TITLE) # Required when using `squash_merge_commit_message`.  The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)., squash_merge_commit_message: str(PR_BODY/COMMIT_MESSAGES/BLANK) # The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message., merge_commit_title: str(PR_TITLE/MERGE_MESSAGE) # Required when using `merge_commit_message`.  The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)., merge_commit_message: str(PR_BODY/PR_TITLE/BLANK) # The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message., custom_properties: map # The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.}
@returns(201) {id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time), created_at: str(date-time), updated_at: str(date-time), permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, allow_rebase_merge: bool, template_repository: map?{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, temp_clone_token: str?, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, organization: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, parent: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, source: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, forks: int, master_branch: str, open_issues: int, watchers: int, anonymous_access_enabled: bool, code_of_conduct: map{url: str(uri), key: str, name: str, html_url: str(uri)?}, security_and_analysis: map?{advanced_security: map{status: str}, code_security: map{status: str}, dependabot_security_updates: map{status: str}, secret_scanning: map{status: str}, secret_scanning_push_protection: map{status: str}, secret_scanning_non_provider_patterns: map{status: str}, secret_scanning_ai_detection: map{status: str}, secret_scanning_delegated_alert_dismissal: map{status: str}}, custom_properties: map} # Response
@errors {403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"name":"Hello-World","description":"This is your first repository","homepage":"https://github.com","private":false,"has_issues":true,"has_projects":true,"has_wiki":true}

@endpoint GET /orgs/{org}/rulesets
@desc Get all organization repository rulesets
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", targets: str # A comma-separated list of rule targets to filter by. If provided, only rulesets that apply to the specified targets will be returned. For example, `branch,tag,push`.}
@returns(200) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint POST /orgs/{org}/rulesets
@desc Create an organization repository ruleset
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the ruleset., enforcement: str(disabled/active/evaluate) # The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).}
@optional {target: str(branch/tag/push/repository)=branch # The target of the ruleset, bypass_actors: [map{actor_id: int, actor_type!: str, bypass_mode: str}] # The actors that can bypass the rules in this ruleset, conditions: map # Conditions for an organization ruleset. The branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties. The push rulesets conditions object does not require the `ref_name` property. For repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`., rules: [map] # An array of rules within the ruleset.}
@returns(201) {id: int, name: str, target: str, source_type: str, source: str, enforcement: str, bypass_actors: [map], current_user_can_bypass: str, node_id: str, _links: map{self: map{href: str}, html: map?{href: str}}, conditions: any?, rules: [map], created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {404: Resource not found, 500: Internal Error}
@example_request {"name":"super cool ruleset","target":"branch","enforcement":"active","bypass_actors":[{"actor_id":234,"actor_type":"Team","bypass_mode":"always"}],"conditions":{"ref_name":{"include":["refs/heads/main","refs/heads/master"],"exclude":["refs/heads/dev*"]},"repository_name":{"include":["important_repository","another_important_repository"],"exclude":["unimportant_repository"],"protected":true}},"rules":[{"type":"commit_author_email_pattern","parameters":{"operator":"contains","pattern":"github"}}]}

@endpoint GET /orgs/{org}/rulesets/rule-suites
@desc List organization rule suites
@required {org: str # The organization name. The name is not case sensitive.}
@optional {ref: str # The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned., repository_name: str # The name of the repository to filter on., time_period: str(hour/day/week/month)=day # The time period to filter by.  For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for rule suites that occurred in the past 7 days (168 hours)., actor_name: str # The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned., rule_suite_result: str(pass/fail/bypass/all)=all # The rule suite results to filter on. When specified, only suites with this result will be returned., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}
@desc Get an organization rule suite
@required {org: str # The organization name. The name is not case sensitive., rule_suite_id: int # The unique identifier of the rule suite result. To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites) for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites) for organizations.}
@returns(200) {id: int, actor_id: int?, actor_name: str?, before_sha: str, after_sha: str, ref: str, repository_id: int, repository_name: str, pushed_at: str(date-time), result: str, evaluation_result: str?, rule_evaluations: [map]} # Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /orgs/{org}/rulesets/{ruleset_id}
@desc Get an organization repository ruleset
@required {org: str # The organization name. The name is not case sensitive., ruleset_id: int # The ID of the ruleset.}
@returns(200) {id: int, name: str, target: str, source_type: str, source: str, enforcement: str, bypass_actors: [map], current_user_can_bypass: str, node_id: str, _links: map{self: map{href: str}, html: map?{href: str}}, conditions: any?, rules: [map], created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint PUT /orgs/{org}/rulesets/{ruleset_id}
@desc Update an organization repository ruleset
@required {org: str # The organization name. The name is not case sensitive., ruleset_id: int # The ID of the ruleset.}
@optional {name: str # The name of the ruleset., target: str(branch/tag/push/repository) # The target of the ruleset, enforcement: str(disabled/active/evaluate) # The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise)., bypass_actors: [map{actor_id: int, actor_type!: str, bypass_mode: str}] # The actors that can bypass the rules in this ruleset, conditions: map # Conditions for an organization ruleset. The branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties. The push rulesets conditions object does not require the `ref_name` property. For repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`., rules: [map] # An array of rules within the ruleset.}
@returns(200) {id: int, name: str, target: str, source_type: str, source: str, enforcement: str, bypass_actors: [map], current_user_can_bypass: str, node_id: str, _links: map{self: map{href: str}, html: map?{href: str}}, conditions: any?, rules: [map], created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {404: Resource not found, 500: Internal Error}
@example_request {"name":"super cool ruleset","target":"branch","enforcement":"active","bypass_actors":[{"actor_id":234,"actor_type":"Team","bypass_mode":"always"}],"conditions":{"ref_name":{"include":["refs/heads/main","refs/heads/master"],"exclude":["refs/heads/dev*"]},"repository_name":{"include":["important_repository","another_important_repository"],"exclude":["unimportant_repository"],"protected":true}},"rules":[{"type":"commit_author_email_pattern","parameters":{"operator":"contains","pattern":"github"}}]}

@endpoint DELETE /orgs/{org}/rulesets/{ruleset_id}
@desc Delete an organization repository ruleset
@required {org: str # The organization name. The name is not case sensitive., ruleset_id: int # The ID of the ruleset.}
@returns(204) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /orgs/{org}/rulesets/{ruleset_id}/history
@desc Get organization ruleset history
@required {org: str # The organization name. The name is not case sensitive., ruleset_id: int # The ID of the ruleset.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}
@desc Get organization ruleset version
@required {org: str # The organization name. The name is not case sensitive., ruleset_id: int # The ID of the ruleset., version_id: int # The ID of the version}
@returns(200) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /orgs/{org}/secret-scanning/alerts
@desc List secret scanning alerts for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {state: str(open/resolved) # Set to `open` or `resolved` to only list secret scanning alerts in a specific state., secret_type: str # A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types., resolution: str # A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`., assignee: str # Filters alerts by assignee. Use `*` to get all assigned alerts, `none` to get all unassigned alerts, or a GitHub username to get alerts assigned to a specific user., sort: str(created/updated)=created # The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved., direction: str(asc/desc)=desc # The direction to sort the results by., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string., after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string., validity: str # A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`., is_publicly_leaked: bool=False # A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present., is_multi_repo: bool=False # A boolean value representing whether or not to filter alerts by the multi-repo tag being present., hide_secret: bool=False # A boolean value representing whether or not to hide literal secrets in the results.}
@returns(200) Response
@errors {404: Resource not found, 503: Service unavailable}

@endpoint GET /orgs/{org}/secret-scanning/pattern-configurations
@desc List organization pattern configurations
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {pattern_config_version: str?, provider_pattern_overrides: [map], custom_pattern_overrides: [map]} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PATCH /orgs/{org}/secret-scanning/pattern-configurations
@desc Update organization pattern configurations
@required {org: str # The organization name. The name is not case sensitive.}
@optional {pattern_config_version: str # The version of the entity. This is used to confirm you're updating the current version of the entity and mitigate unintentionally overriding someone else's update., provider_pattern_settings: [map{token_type: str, push_protection_setting: str}] # Pattern settings for provider patterns., custom_pattern_settings: [map{token_type: str, custom_pattern_version: str, push_protection_setting: str}] # Pattern settings for custom patterns.}
@returns(200) {pattern_config_version: str} # Response
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found, 409: Conflict, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"pattern_config_version":"0ujsswThIGTUYm2K8FjOOfXtY1K","provider_pattern_settings":[{"token_type":"GITHUB_PERSONAL_ACCESS_TOKEN","push_protection_setting":"enabled"}],"custom_pattern_settings":[{"token_type":"cp_2","custom_pattern_version":"0ujsswThIGTUYm2K8FjOOfXtY1K","push_protection_setting":"enabled"}]}

@endpoint GET /orgs/{org}/security-advisories
@desc List repository security advisories for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {direction: str(asc/desc)=desc # The direction to sort the results by., sort: str(created/updated/published)=created # The property to sort the results by., before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of advisories to return per page. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", state: str(triage/draft/published/closed) # Filter by the state of the repository advisories. Only advisories of this state will be returned.}
@returns(200) Response
@errors {400: Bad Request, 404: Resource not found}

@endpoint GET /orgs/{org}/security-managers
@desc List security manager teams
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) Response

@endpoint PUT /orgs/{org}/security-managers/teams/{team_slug}
@desc Add a security manager team
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@returns(204) Response

@endpoint DELETE /orgs/{org}/security-managers/teams/{team_slug}
@desc Remove a security manager team
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@returns(204) Response

@endpoint GET /orgs/{org}/settings/immutable-releases
@desc Get immutable releases settings for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {enforced_repositories: str, selected_repositories_url: str} # Immutable releases settings response

@endpoint PUT /orgs/{org}/settings/immutable-releases
@desc Set immutable releases settings for an organization
@required {org: str # The organization name. The name is not case sensitive., enforced_repositories: str(all/none/selected) # The policy that controls how immutable releases are enforced in the organization.}
@optional {selected_repository_ids: [int] # An array of repository ids for which immutable releases enforcement should be applied. You can only provide a list of repository ids when the `enforced_repositories` is set to `selected`. You can add and remove individual repositories using the [Enable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#enable-a-selected-repository-for-immutable-releases-in-an-organization) and [Disable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#disable-a-selected-repository-for-immutable-releases-in-an-organization) endpoints.}
@returns(204) Response
@example_request {"enforced_repositories":"all"}

@endpoint GET /orgs/{org}/settings/immutable-releases/repositories
@desc List selected repositories for immutable releases enforcement
@required {org: str # The organization name. The name is not case sensitive.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, repositories: [map]} # Response

@endpoint PUT /orgs/{org}/settings/immutable-releases/repositories
@desc Set selected repositories for immutable releases enforcement
@required {org: str # The organization name. The name is not case sensitive., selected_repository_ids: [int] # An array of repository ids for which immutable releases enforcement should be applied. You can only provide a list of repository ids when the `enforced_repositories` is set to `selected`. You can add and remove individual repositories using the [Enable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#enable-a-selected-repository-for-immutable-releases-in-an-organization) and [Disable a selected repository for immutable releases in an organization](https://docs.github.com/rest/orgs/orgs#disable-a-selected-repository-for-immutable-releases-in-an-organization) endpoints.}
@returns(204) Response
@example_request {"selected_repository_ids":[64780797]}

@endpoint PUT /orgs/{org}/settings/immutable-releases/repositories/{repository_id}
@desc Enable a selected repository for immutable releases in an organization
@required {org: str # The organization name. The name is not case sensitive., repository_id: int # The unique identifier of the repository.}
@returns(204) Response

@endpoint DELETE /orgs/{org}/settings/immutable-releases/repositories/{repository_id}
@desc Disable a selected repository for immutable releases in an organization
@required {org: str # The organization name. The name is not case sensitive., repository_id: int # The unique identifier of the repository.}
@returns(204) Response

@endpoint GET /orgs/{org}/settings/network-configurations
@desc List hosted compute network configurations for an organization
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, network_configurations: [map]} # Response

@endpoint POST /orgs/{org}/settings/network-configurations
@desc Create a hosted compute network configuration for an organization
@required {org: str # The organization name. The name is not case sensitive., name: str # Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'., network_settings_ids: [str] # A list of identifiers of the network settings resources to use for the network configuration. Exactly one resource identifier must be specified in the list.}
@optional {compute_service: str(none/actions) # The hosted compute service to use for the network configuration.}
@returns(201) {id: str, name: str, compute_service: str, network_settings_ids: [str], failover_network_settings_ids: [str], failover_network_enabled: bool, created_on: str(date-time)?} # Response
@example_request {"name":"my-network-configuration","network_settings_ids":["23456789ABDCEF1"],"compute_service":"actions"}

@endpoint GET /orgs/{org}/settings/network-configurations/{network_configuration_id}
@desc Get a hosted compute network configuration for an organization
@required {org: str # The organization name. The name is not case sensitive., network_configuration_id: str # Unique identifier of the hosted compute network configuration.}
@returns(200) {id: str, name: str, compute_service: str, network_settings_ids: [str], failover_network_settings_ids: [str], failover_network_enabled: bool, created_on: str(date-time)?} # Response

@endpoint PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}
@desc Update a hosted compute network configuration for an organization
@required {org: str # The organization name. The name is not case sensitive., network_configuration_id: str # Unique identifier of the hosted compute network configuration.}
@optional {name: str # Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'., compute_service: str(none/actions) # The hosted compute service to use for the network configuration., network_settings_ids: [str] # A list of identifiers of the network settings resources to use for the network configuration. Exactly one resource identifier must be specified in the list.}
@returns(200) {id: str, name: str, compute_service: str, network_settings_ids: [str], failover_network_settings_ids: [str], failover_network_enabled: bool, created_on: str(date-time)?} # Response
@example_request {"name":"my-network-configuration","network_settings_ids":["23456789ABDCEF1"],"compute_service":"actions"}

@endpoint DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}
@desc Delete a hosted compute network configuration from an organization
@required {org: str # The organization name. The name is not case sensitive., network_configuration_id: str # Unique identifier of the hosted compute network configuration.}
@returns(204) Response

@endpoint GET /orgs/{org}/settings/network-settings/{network_settings_id}
@desc Get a hosted compute network settings resource for an organization
@required {org: str # The organization name. The name is not case sensitive., network_settings_id: str # Unique identifier of the hosted compute network settings.}
@returns(200) {id: str, network_configuration_id: str, name: str, subnet_id: str, region: str} # Response

@endpoint GET /orgs/{org}/team/{team_slug}/copilot/metrics
@desc Get Copilot metrics for a team
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@optional {since: str # Show usage metrics since this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 100 days ago., until: str # Show usage metrics until this date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=100 # The number of days of metrics to display per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {500: Internal Error, 403: Forbidden, 404: Resource not found, 422: Copilot Usage Merics API setting is disabled at the organization or enterprise level.}

@endpoint GET /orgs/{org}/teams
@desc List teams
@required {org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {403: Forbidden}

@endpoint POST /orgs/{org}/teams
@desc Create a team
@required {org: str # The organization name. The name is not case sensitive., name: str # The name of the team.}
@optional {description: str # The description of the team., maintainers: [str] # List GitHub usernames for organization members who will become team maintainers., repo_names: [str] # The full name (e.g., "organization-name/repository-name") of repositories to add the team to., privacy: str(secret/closed) # The level of privacy this team should have. The options are:   **For a non-nested team:**    * `secret` - only visible to organization owners and members of this team.    * `closed` - visible to all members of this organization.   Default: `secret`   **For a parent or child team:**    * `closed` - visible to all members of this organization.   Default for child team: `closed`, notification_setting: str(notifications_enabled/notifications_disabled) # The notification setting the team has chosen. The options are:    * `notifications_enabled` - team members receive notifications when the team is @mentioned.    * `notifications_disabled` - no one receives notifications.   Default: `notifications_enabled`, permission: str(pull/push)=pull # **Closing down notice**. The permission that new repositories will be added to the team with when none is specified., parent_team_id: int # The ID of a team to set as the parent team.}
@returns(201) {id: int, node_id: str, url: str(uri), html_url: str(uri), name: str, slug: str, description: str?, privacy: str, notification_setting: str, permission: str, members_url: str, repositories_url: str(uri), parent: map?{id: int, node_id: str, url: str(uri), members_url: str, name: str, description: str?, permission: str, privacy: str, notification_setting: str, html_url: str(uri), repositories_url: str(uri), slug: str, ldap_dn: str, type: str, organization_id: int, enterprise_id: int}, members_count: int, repos_count: int, created_at: str(date-time), updated_at: str(date-time), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?, name: str, company: str, blog: str(uri), location: str, email: str(email), twitter_username: str?, is_verified: bool, has_organization_projects: bool, has_repository_projects: bool, public_repos: int, public_gists: int, followers: int, following: int, html_url: str(uri), created_at: str(date-time), type: str, total_private_repos: int, owned_private_repos: int, private_gists: int?, disk_usage: int?, collaborators: int?, billing_email: str(email)?, plan: map{name: str, space: int, private_repos: int, filled_seats: int, seats: int}, default_repository_permission: str?, members_can_create_repositories: bool?, two_factor_requirement_enabled: bool?, members_allowed_repository_creation_type: str, members_can_create_public_repositories: bool, members_can_create_private_repositories: bool, members_can_create_internal_repositories: bool, members_can_create_pages: bool, members_can_create_public_pages: bool, members_can_create_private_pages: bool, members_can_fork_private_repositories: bool?, web_commit_signoff_required: bool, updated_at: str(date-time), archived_at: str(date-time)?}, ldap_dn: str, type: str, organization_id: int, enterprise_id: int} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"name":"Justice League","description":"A great team","permission":"push","notification_setting":"notifications_enabled","privacy":"closed"}

@endpoint GET /orgs/{org}/teams/{team_slug}
@desc Get a team by name
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@returns(200) {id: int, node_id: str, url: str(uri), html_url: str(uri), name: str, slug: str, description: str?, privacy: str, notification_setting: str, permission: str, members_url: str, repositories_url: str(uri), parent: map?{id: int, node_id: str, url: str(uri), members_url: str, name: str, description: str?, permission: str, privacy: str, notification_setting: str, html_url: str(uri), repositories_url: str(uri), slug: str, ldap_dn: str, type: str, organization_id: int, enterprise_id: int}, members_count: int, repos_count: int, created_at: str(date-time), updated_at: str(date-time), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?, name: str, company: str, blog: str(uri), location: str, email: str(email), twitter_username: str?, is_verified: bool, has_organization_projects: bool, has_repository_projects: bool, public_repos: int, public_gists: int, followers: int, following: int, html_url: str(uri), created_at: str(date-time), type: str, total_private_repos: int, owned_private_repos: int, private_gists: int?, disk_usage: int?, collaborators: int?, billing_email: str(email)?, plan: map{name: str, space: int, private_repos: int, filled_seats: int, seats: int}, default_repository_permission: str?, members_can_create_repositories: bool?, two_factor_requirement_enabled: bool?, members_allowed_repository_creation_type: str, members_can_create_public_repositories: bool, members_can_create_private_repositories: bool, members_can_create_internal_repositories: bool, members_can_create_pages: bool, members_can_create_public_pages: bool, members_can_create_private_pages: bool, members_can_fork_private_repositories: bool?, web_commit_signoff_required: bool, updated_at: str(date-time), archived_at: str(date-time)?}, ldap_dn: str, type: str, organization_id: int, enterprise_id: int} # Response
@errors {404: Resource not found}

@endpoint PATCH /orgs/{org}/teams/{team_slug}
@desc Update a team
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@optional {name: str # The name of the team., description: str # The description of the team., privacy: str(secret/closed) # The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:   **For a non-nested team:**    * `secret` - only visible to organization owners and members of this team.    * `closed` - visible to all members of this organization.   **For a parent or child team:**    * `closed` - visible to all members of this organization., notification_setting: str(notifications_enabled/notifications_disabled) # The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are:   * `notifications_enabled` - team members receive notifications when the team is @mentioned.    * `notifications_disabled` - no one receives notifications., permission: str(pull/push/admin)=pull # **Closing down notice**. The permission that new repositories will be added to the team with when none is specified., parent_team_id: int # The ID of a team to set as the parent team.}
@returns(200) {id: int, node_id: str, url: str(uri), html_url: str(uri), name: str, slug: str, description: str?, privacy: str, notification_setting: str, permission: str, members_url: str, repositories_url: str(uri), parent: map?{id: int, node_id: str, url: str(uri), members_url: str, name: str, description: str?, permission: str, privacy: str, notification_setting: str, html_url: str(uri), repositories_url: str(uri), slug: str, ldap_dn: str, type: str, organization_id: int, enterprise_id: int}, members_count: int, repos_count: int, created_at: str(date-time), updated_at: str(date-time), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?, name: str, company: str, blog: str(uri), location: str, email: str(email), twitter_username: str?, is_verified: bool, has_organization_projects: bool, has_repository_projects: bool, public_repos: int, public_gists: int, followers: int, following: int, html_url: str(uri), created_at: str(date-time), type: str, total_private_repos: int, owned_private_repos: int, private_gists: int?, disk_usage: int?, collaborators: int?, billing_email: str(email)?, plan: map{name: str, space: int, private_repos: int, filled_seats: int, seats: int}, default_repository_permission: str?, members_can_create_repositories: bool?, two_factor_requirement_enabled: bool?, members_allowed_repository_creation_type: str, members_can_create_public_repositories: bool, members_can_create_private_repositories: bool, members_can_create_internal_repositories: bool, members_can_create_pages: bool, members_can_create_public_pages: bool, members_can_create_private_pages: bool, members_can_fork_private_repositories: bool?, web_commit_signoff_required: bool, updated_at: str(date-time), archived_at: str(date-time)?}, ldap_dn: str, type: str, organization_id: int, enterprise_id: int} # Response when the updated information already exists
@returns(201) {id: int, node_id: str, url: str(uri), html_url: str(uri), name: str, slug: str, description: str?, privacy: str, notification_setting: str, permission: str, members_url: str, repositories_url: str(uri), parent: map?{id: int, node_id: str, url: str(uri), members_url: str, name: str, description: str?, permission: str, privacy: str, notification_setting: str, html_url: str(uri), repositories_url: str(uri), slug: str, ldap_dn: str, type: str, organization_id: int, enterprise_id: int}, members_count: int, repos_count: int, created_at: str(date-time), updated_at: str(date-time), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?, name: str, company: str, blog: str(uri), location: str, email: str(email), twitter_username: str?, is_verified: bool, has_organization_projects: bool, has_repository_projects: bool, public_repos: int, public_gists: int, followers: int, following: int, html_url: str(uri), created_at: str(date-time), type: str, total_private_repos: int, owned_private_repos: int, private_gists: int?, disk_usage: int?, collaborators: int?, billing_email: str(email)?, plan: map{name: str, space: int, private_repos: int, filled_seats: int, seats: int}, default_repository_permission: str?, members_can_create_repositories: bool?, two_factor_requirement_enabled: bool?, members_allowed_repository_creation_type: str, members_can_create_public_repositories: bool, members_can_create_private_repositories: bool, members_can_create_internal_repositories: bool, members_can_create_pages: bool, members_can_create_public_pages: bool, members_can_create_private_pages: bool, members_can_fork_private_repositories: bool?, web_commit_signoff_required: bool, updated_at: str(date-time), archived_at: str(date-time)?}, ldap_dn: str, type: str, organization_id: int, enterprise_id: int} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"name":"new team name","description":"new team description","privacy":"closed","notification_setting":"notifications_enabled"}

@endpoint DELETE /orgs/{org}/teams/{team_slug}
@desc Delete a team
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@returns(204) Response

@endpoint GET /orgs/{org}/teams/{team_slug}/invitations
@desc List pending team invitations
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /orgs/{org}/teams/{team_slug}/members
@desc List team members
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@optional {role: str(member/maintainer/all)=all # Filters members returned by their role in the team., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /orgs/{org}/teams/{team_slug}/memberships/{username}
@desc Get team membership for a user
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name., username: str # The handle for the GitHub user account.}
@returns(200) {url: str(uri), role: str, state: str} # Response
@errors {404: if user has no team membership}

@endpoint PUT /orgs/{org}/teams/{team_slug}/memberships/{username}
@desc Add or update team membership for a user
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name., username: str # The handle for the GitHub user account.}
@optional {role: str(member/maintainer)=member # The role that this user should have in the team.}
@returns(200) {url: str(uri), role: str, state: str} # Response
@errors {403: Forbidden if team synchronization is set up, 422: Unprocessable Entity if you attempt to add an organization to a team}
@example_request {"role":"maintainer"}

@endpoint DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}
@desc Remove team membership for a user
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {403: Forbidden if team synchronization is set up}

@endpoint GET /orgs/{org}/teams/{team_slug}/repos
@desc List team repositories
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
@desc Check team permissions for a repository
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name., owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {id: int, node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, role_name: str, owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, open_issues: int, watchers: int, master_branch: str} # Alternative response with repository permissions
@returns(204) Response if team has permission for the repository. This is the response when the repository media type hasn't been provded in the Accept header.
@errors {404: Not Found if team does not have permission for the repository}

@endpoint PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
@desc Add or update team repository permissions
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name., owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {permission: str # The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.}
@returns(204) Response
@example_request {"permission":"push"}

@endpoint DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
@desc Remove a repository from a team
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name., owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response

@endpoint GET /orgs/{org}/teams/{team_slug}/teams
@desc List child teams
@required {org: str # The organization name. The name is not case sensitive., team_slug: str # The slug of the team name.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) if child teams exist

@endpoint POST /orgs/{org}/{security_product}/{enablement}
@desc Enable or disable a security feature for an organization
@required {org: str # The organization name. The name is not case sensitive., security_product: str(dependency_graph/dependabot_alerts/dependabot_security_updates/advanced_security/code_scanning_default_setup/secret_scanning/secret_scanning_push_protection) # The security feature to enable or disable., enablement: str(enable_all/disable_all) # The action to take.  `enable_all` means to enable the specified security feature for all repositories in the organization. `disable_all` means to disable the specified security feature for all repositories in the organization.}
@optional {query_suite: str(default/extended) # CodeQL query suite to be used. If you specify the `query_suite` parameter, the default setup will be configured with this query suite only on all repositories that didn't have default setup already configured. It will not change the query suite on repositories that already have default setup configured. If you don't specify any `query_suite` in your request, the preferred query suite of the organization will be applied.}
@returns(204) Action started
@errors {422: The action could not be taken due to an in progress enablement, or a policy is preventing enablement}

@endgroup

@group rate_limit
@endpoint GET /rate_limit
@desc Get rate limit status for the authenticated user
@returns(200) {resources: map{core: map{limit: int, remaining: int, reset: int, used: int}, graphql: map{limit: int, remaining: int, reset: int, used: int}, search: map{limit: int, remaining: int, reset: int, used: int}, code_search: map{limit: int, remaining: int, reset: int, used: int}, source_import: map{limit: int, remaining: int, reset: int, used: int}, integration_manifest: map{limit: int, remaining: int, reset: int, used: int}, code_scanning_upload: map{limit: int, remaining: int, reset: int, used: int}, actions_runner_registration: map{limit: int, remaining: int, reset: int, used: int}, scim: map{limit: int, remaining: int, reset: int, used: int}, dependency_snapshots: map{limit: int, remaining: int, reset: int, used: int}, dependency_sbom: map{limit: int, remaining: int, reset: int, used: int}, code_scanning_autofix: map{limit: int, remaining: int, reset: int, used: int}}, rate: map{limit: int, remaining: int, reset: int, used: int}} # Response
@errors {304: Not modified, 404: Resource not found}

@endgroup

@group repos
@endpoint GET /repos/{owner}/{repo}
@desc Get a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time), created_at: str(date-time), updated_at: str(date-time), permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, allow_rebase_merge: bool, template_repository: map?{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, temp_clone_token: str?, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, organization: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, parent: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, source: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, forks: int, master_branch: str, open_issues: int, watchers: int, anonymous_access_enabled: bool, code_of_conduct: map{url: str(uri), key: str, name: str, html_url: str(uri)?}, security_and_analysis: map?{advanced_security: map{status: str}, code_security: map{status: str}, dependabot_security_updates: map{status: str}, secret_scanning: map{status: str}, secret_scanning_push_protection: map{status: str}, secret_scanning_non_provider_patterns: map{status: str}, secret_scanning_ai_detection: map{status: str}, secret_scanning_delegated_alert_dismissal: map{status: str}}, custom_properties: map} # Response
@errors {403: Forbidden, 404: Resource not found, 301: Moved permanently}

@endpoint PATCH /repos/{owner}/{repo}
@desc Update a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {name: str # The name of the repository., description: str # A short description of the repository., homepage: str # A URL with more information about the repository., private: bool=False # Either `true` to make the repository private or `false` to make it public. Default: `false`.   **Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private., visibility: str(public/private) # The visibility of the repository., security_and_analysis: map{advanced_security: map, code_security: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_ai_detection: map, secret_scanning_non_provider_patterns: map} # Specify which security and analysis features to enable or disable for the repository.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."  For example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request: `{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.  You can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request., has_issues: bool=True # Either `true` to enable issues for this repository or `false` to disable them., has_projects: bool=True # Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error., has_wiki: bool=True # Either `true` to enable the wiki for this repository or `false` to disable it., is_template: bool=False # Either `true` to make this repo available as a template repository or `false` to prevent it., default_branch: str # Updates the default branch for this repository., allow_squash_merge: bool=True # Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging., allow_merge_commit: bool=True # Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits., allow_rebase_merge: bool=True # Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging., allow_auto_merge: bool=False # Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge., delete_branch_on_merge: bool=False # Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion., allow_update_branch: bool=False # Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise., use_squash_pr_title_as_default: bool=False # Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead., squash_merge_commit_title: str(PR_TITLE/COMMIT_OR_PR_TITLE) # Required when using `squash_merge_commit_message`.  The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)., squash_merge_commit_message: str(PR_BODY/COMMIT_MESSAGES/BLANK) # The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message., merge_commit_title: str(PR_TITLE/MERGE_MESSAGE) # Required when using `merge_commit_message`.  The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)., merge_commit_message: str(PR_BODY/PR_TITLE/BLANK) # The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message., archived: bool=False # Whether to archive this repository. `false` will unarchive a previously archived repository., allow_forking: bool=False # Either `true` to allow private forks, or `false` to prevent private forks., web_commit_signoff_required: bool=False # Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.}
@returns(200) {id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time), created_at: str(date-time), updated_at: str(date-time), permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, allow_rebase_merge: bool, template_repository: map?{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, temp_clone_token: str?, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, organization: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, parent: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, source: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, forks: int, master_branch: str, open_issues: int, watchers: int, anonymous_access_enabled: bool, code_of_conduct: map{url: str(uri), key: str, name: str, html_url: str(uri)?}, security_and_analysis: map?{advanced_security: map{status: str}, code_security: map{status: str}, dependabot_security_updates: map{status: str}, secret_scanning: map{status: str}, secret_scanning_push_protection: map{status: str}, secret_scanning_non_provider_patterns: map{status: str}, secret_scanning_ai_detection: map{status: str}, secret_scanning_delegated_alert_dismissal: map{status: str}}, custom_properties: map} # Response
@errors {307: Temporary Redirect, 403: Forbidden, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"name":"Hello-World","description":"This is your first repository","homepage":"https://github.com","private":true,"has_issues":true,"has_projects":true,"has_wiki":true}

@endpoint DELETE /repos/{owner}/{repo}
@desc Delete a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response
@errors {403: If an organization owner has configured the organization to prevent members from deleting organization-owned repositories, a member will get this response:, 307: Temporary Redirect, 404: Resource not found, 409: Conflict}

@endpoint GET /repos/{owner}/{repo}/actions/artifacts
@desc List artifacts for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", name: str # The name field of an artifact. When specified, only artifacts with this name will be returned.}
@returns(200) {total_count: int, artifacts: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
@desc Get an artifact
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., artifact_id: int # The unique identifier of the artifact.}
@returns(200) {id: int, node_id: str, name: str, size_in_bytes: int, url: str, archive_download_url: str, expired: bool, created_at: str(date-time)?, expires_at: str(date-time)?, updated_at: str(date-time)?, digest: str?, workflow_run: map?{id: int, repository_id: int, head_repository_id: int, head_branch: str, head_sha: str}} # Response

@endpoint DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
@desc Delete an artifact
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., artifact_id: int # The unique identifier of the artifact.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
@desc Download an artifact
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., artifact_id: int # The unique identifier of the artifact., archive_format: str}
@errors {302: Response, 410: Gone}

@endpoint GET /repos/{owner}/{repo}/actions/cache/retention-limit
@desc Get GitHub Actions cache retention limit for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {max_cache_retention_days: int} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/actions/cache/retention-limit
@desc Set GitHub Actions cache retention limit for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {max_cache_retention_days: int # The maximum number of days to keep caches in this repository.}
@returns(204) Response
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found}
@example_request {"max_cache_retention_days":80}

@endpoint GET /repos/{owner}/{repo}/actions/cache/storage-limit
@desc Get GitHub Actions cache storage limit for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {max_cache_size_gb: int} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/actions/cache/storage-limit
@desc Set GitHub Actions cache storage limit for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {max_cache_size_gb: int # The maximum total cache size for this repository, in gigabytes.}
@returns(204) Response
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found}
@example_request {"max_cache_size_gb":150}

@endpoint GET /repos/{owner}/{repo}/actions/cache/usage
@desc Get GitHub Actions cache usage for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {full_name: str, active_caches_size_in_bytes: int, active_caches_count: int} # Response

@endpoint GET /repos/{owner}/{repo}/actions/caches
@desc List GitHub Actions caches for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", ref: str # The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`., key: str # An explicit key or prefix for identifying the cache, sort: str(created_at/last_accessed_at/size_in_bytes)=last_accessed_at # The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes., direction: str(asc/desc)=desc # The direction to sort the results by.}
@returns(200) {total_count: int, actions_caches: [map]} # Response

@endpoint DELETE /repos/{owner}/{repo}/actions/caches
@desc Delete GitHub Actions caches for a repository (using a cache key)
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., key: str # A key for identifying the cache.}
@optional {ref: str # The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.}
@returns(200) {total_count: int, actions_caches: [map]} # Response

@endpoint DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}
@desc Delete a GitHub Actions cache for a repository (using a cache ID)
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., cache_id: int # The unique identifier of the GitHub Actions cache.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/actions/jobs/{job_id}
@desc Get a job for a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., job_id: int # The unique identifier of the job.}
@returns(200) {id: int, run_id: int, run_url: str, run_attempt: int, node_id: str, head_sha: str, url: str, html_url: str?, status: str, conclusion: str?, created_at: str(date-time), started_at: str(date-time), completed_at: str(date-time)?, name: str, steps: [map], check_run_url: str, labels: [str], runner_id: int?, runner_name: str?, runner_group_id: int?, runner_group_name: str?, workflow_name: str?, head_branch: str?} # Response

@endpoint GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs
@desc Download job logs for a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., job_id: int # The unique identifier of the job.}
@errors {302: Response}

@endpoint POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun
@desc Re-run a job from a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., job_id: int # The unique identifier of the job.}
@optional {enable_debug_logging: bool=False # Whether to enable debug logging for the re-run.}
@returns(201) Response
@errors {403: Forbidden}

@endpoint GET /repos/{owner}/{repo}/actions/oidc/customization/sub
@desc Get the customization template for an OIDC subject claim for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {use_default: bool, include_claim_keys: [str]} # Status response
@errors {400: Bad Request, 404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/actions/oidc/customization/sub
@desc Set the customization template for an OIDC subject claim for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., use_default: bool # Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.}
@optional {include_claim_keys: [str] # Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.}
@returns(201) Empty response
@errors {404: Resource not found, 400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"use_default":false,"include_claim_keys":["repo","context"]}

@endpoint GET /repos/{owner}/{repo}/actions/organization-secrets
@desc List repository organization secrets
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, secrets: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/organization-variables
@desc List repository organization variables
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=10 # The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, variables: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/permissions
@desc Get GitHub Actions permissions for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {enabled: bool, allowed_actions: str, selected_actions_url: str, sha_pinning_required: bool} # Response

@endpoint PUT /repos/{owner}/{repo}/actions/permissions
@desc Set GitHub Actions permissions for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., enabled: bool # Whether GitHub Actions is enabled on the repository.}
@optional {allowed_actions: str(all/local_only/selected) # The permissions policy that controls the actions and reusable workflows that are allowed to run., sha_pinning_required: bool # Whether actions must be pinned to a full-length commit SHA.}
@returns(204) Response
@example_request {"enabled":true,"allowed_actions":"selected","sha_pinning_required":true}

@endpoint GET /repos/{owner}/{repo}/actions/permissions/access
@desc Get the level of access for workflows outside of the repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {access_level: str} # Response

@endpoint PUT /repos/{owner}/{repo}/actions/permissions/access
@desc Set the level of access for workflows outside of the repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., access_level: str(none/user/organization) # Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the repository.  `none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization.}
@returns(204) Response
@example_request {"access_level":"organization"}

@endpoint GET /repos/{owner}/{repo}/actions/permissions/artifact-and-log-retention
@desc Get artifact and log retention settings for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {days: int, maximum_allowed_days: int} # Response
@errors {404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/actions/permissions/artifact-and-log-retention
@desc Set artifact and log retention settings for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., days: int # The number of days to retain artifacts and logs}
@returns(204) Empty response for successful settings update
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"days":90}

@endpoint GET /repos/{owner}/{repo}/actions/permissions/fork-pr-contributor-approval
@desc Get fork PR contributor approval permissions for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {approval_policy: str} # Response
@errors {404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/actions/permissions/fork-pr-contributor-approval
@desc Set fork PR contributor approval permissions for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., approval_policy: str(first_time_contributors_new_to_github/first_time_contributors/all_external_contributors) # The policy that controls when fork PR workflows require approval from a maintainer.}
@returns(204) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"approval_policy":"first_time_contributors"}

@endpoint GET /repos/{owner}/{repo}/actions/permissions/fork-pr-workflows-private-repos
@desc Get private repo fork PR workflow settings for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {run_workflows_from_fork_pull_requests: bool, send_write_tokens_to_workflows: bool, send_secrets_and_variables: bool, require_approval_for_fork_pr_workflows: bool} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/actions/permissions/fork-pr-workflows-private-repos
@desc Set private repo fork PR workflow settings for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_workflows_from_fork_pull_requests: bool # Whether workflows triggered by pull requests from forks are allowed to run on private repositories.}
@optional {send_write_tokens_to_workflows: bool # Whether GitHub Actions can create pull requests or submit approving pull request reviews from a workflow triggered by a fork pull request., send_secrets_and_variables: bool # Whether to make secrets and variables available to workflows triggered by pull requests from forks., require_approval_for_fork_pr_workflows: bool # Whether workflows triggered by pull requests from forks require approval from a repository administrator to run.}
@returns(204) Empty response for successful settings update
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"run_workflows_from_fork_pull_requests":true,"send_write_tokens_to_workflows":false,"send_secrets_and_variables":false,"require_approval_for_fork_pr_workflows":true}

@endpoint GET /repos/{owner}/{repo}/actions/permissions/selected-actions
@desc Get allowed actions and reusable workflows for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {github_owned_allowed: bool, verified_allowed: bool, patterns_allowed: [str]} # Response

@endpoint PUT /repos/{owner}/{repo}/actions/permissions/selected-actions
@desc Set allowed actions and reusable workflows for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {github_owned_allowed: bool # Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization., verified_allowed: bool # Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators., patterns_allowed: [str] # Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.  > [!NOTE] > The `patterns_allowed` setting only applies to public repositories.}
@returns(204) Response
@example_request {"github_owned_allowed":true,"verified_allowed":false,"patterns_allowed":["monalisa/octocat@*","docker/*"]}

@endpoint GET /repos/{owner}/{repo}/actions/permissions/workflow
@desc Get default workflow permissions for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {default_workflow_permissions: str, can_approve_pull_request_reviews: bool} # Response

@endpoint PUT /repos/{owner}/{repo}/actions/permissions/workflow
@desc Set default workflow permissions for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {default_workflow_permissions: str(read/write) # The default workflow permissions granted to the GITHUB_TOKEN when running workflows., can_approve_pull_request_reviews: bool # Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.}
@returns(204) Success response
@errors {409: Conflict response when changing a setting is prevented by the owning organization}
@example_request {"default_workflow_permissions":"read","can_approve_pull_request_reviews":true}

@endpoint GET /repos/{owner}/{repo}/actions/runners
@desc List self-hosted runners for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {name: str # The name of a self-hosted runner., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, runners: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/runners/downloads
@desc List runner applications for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig
@desc Create configuration for a just-in-time runner for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the new runner., runner_group_id: int # The ID of the runner group to register the runner to., labels: [str] # The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.}
@optional {work_folder: str=_work # The working directory to be used for job execution, relative to the runner install directory.}
@returns(201) {runner: map{id: int, runner_group_id: int, name: str, os: str, status: str, busy: bool, labels: [map], ephemeral: bool}, encoded_jit_config: str} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 409: Conflict}
@example_request {"name":"New runner","runner_group_id":1,"labels":["self-hosted","X64","macOS","no-gpu"],"work_folder":"_work"}

@endpoint POST /repos/{owner}/{repo}/actions/runners/registration-token
@desc Create a registration token for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(201) {token: str, expires_at: str(date-time), permissions: map, repositories: [map], single_file: str?, repository_selection: str} # Response

@endpoint POST /repos/{owner}/{repo}/actions/runners/remove-token
@desc Create a remove token for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(201) {token: str, expires_at: str(date-time), permissions: map, repositories: [map], single_file: str?, repository_selection: str} # Response

@endpoint GET /repos/{owner}/{repo}/actions/runners/{runner_id}
@desc Get a self-hosted runner for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(200) {id: int, runner_group_id: int, name: str, os: str, status: str, busy: bool, labels: [map], ephemeral: bool} # Response

@endpoint DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}
@desc Delete a self-hosted runner from a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels
@desc List labels for a self-hosted runner for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels
@desc Add custom labels to a self-hosted runner for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner., labels: [str] # The names of the custom labels to add to the runner.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"labels":["gpu","accelerated"]}

@endpoint PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels
@desc Set custom labels for a self-hosted runner for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner., labels: [str] # The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"labels":["gpu","accelerated"]}

@endpoint DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels
@desc Remove all custom labels from a self-hosted runner for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found}

@endpoint DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}
@desc Remove a custom label from a self-hosted runner for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., runner_id: int # Unique identifier of the self-hosted runner., name: str # The name of a self-hosted runner's custom label.}
@returns(200) {total_count: int, labels: [map]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/actions/runs
@desc List workflow runs for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {actor: str # Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run., branch: str # Returns workflow runs associated with a branch. Use the name of the branch of the `push`., event: str # Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).", status: str(completed/action_required/cancelled/failure/neutral/skipped/stale/success/timed_out/in_progress/queued/requested/waiting/pending) # Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", created: str(date-time) # Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).", exclude_pull_requests: bool=False # If `true` pull requests are omitted from the response (empty array)., check_suite_id: int # Returns workflow runs with the `check_suite_id` that you specify., head_sha: str # Only returns workflow runs that are associated with the specified `head_sha`.}
@returns(200) {total_count: int, workflow_runs: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}
@desc Get a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@optional {exclude_pull_requests: bool=False # If `true` pull requests are omitted from the response (empty array).}
@returns(200) {id: int, name: str?, node_id: str, check_suite_id: int, check_suite_node_id: str, head_branch: str?, head_sha: str, path: str, run_number: int, run_attempt: int, referenced_workflows: [map]?, event: str, status: str?, conclusion: str?, workflow_id: int, url: str, html_url: str, pull_requests: [map]?, created_at: str(date-time), updated_at: str(date-time), actor: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, triggering_actor: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, run_started_at: str(date-time), jobs_url: str, logs_url: str, check_suite_url: str, artifacts_url: str, cancel_url: str, rerun_url: str, previous_attempt_url: str?, workflow_url: str, head_commit: map?{id: str, tree_id: str, message: str, timestamp: str(date-time), author: map?{name: str, email: str(email)}, committer: map?{name: str, email: str(email)}}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, head_repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, head_repository_id: int, display_title: str} # Response

@endpoint DELETE /repos/{owner}/{repo}/actions/runs/{run_id}
@desc Delete a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals
@desc Get the review history for a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve
@desc Approve a workflow run for a fork pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@returns(201) Response
@errors {404: Resource not found, 403: Forbidden}

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
@desc List workflow run artifacts
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", name: str # The name field of an artifact. When specified, only artifacts with this name will be returned.}
@returns(200) {total_count: int, artifacts: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}
@desc Get a workflow run attempt
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run., attempt_number: int # The attempt number of the workflow run.}
@optional {exclude_pull_requests: bool=False # If `true` pull requests are omitted from the response (empty array).}
@returns(200) {id: int, name: str?, node_id: str, check_suite_id: int, check_suite_node_id: str, head_branch: str?, head_sha: str, path: str, run_number: int, run_attempt: int, referenced_workflows: [map]?, event: str, status: str?, conclusion: str?, workflow_id: int, url: str, html_url: str, pull_requests: [map]?, created_at: str(date-time), updated_at: str(date-time), actor: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, triggering_actor: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, run_started_at: str(date-time), jobs_url: str, logs_url: str, check_suite_url: str, artifacts_url: str, cancel_url: str, rerun_url: str, previous_attempt_url: str?, workflow_url: str, head_commit: map?{id: str, tree_id: str, message: str, timestamp: str(date-time), author: map?{name: str, email: str(email)}, committer: map?{name: str, email: str(email)}}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, head_repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, head_repository_id: int, display_title: str} # Response

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs
@desc List jobs for a workflow run attempt
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run., attempt_number: int # The attempt number of the workflow run.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, jobs: [map]} # Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs
@desc Download workflow run attempt logs
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run., attempt_number: int # The attempt number of the workflow run.}
@errors {302: Response}

@endpoint POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel
@desc Cancel a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@returns(202) Response
@errors {409: Conflict}

@endpoint POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule
@desc Review custom deployment protection rules for a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@returns(204) Response
@example_request {"environment_name":"prod-eus","state":"approved","comment":"All health checks passed."}

@endpoint POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel
@desc Force cancel a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@returns(202) Response
@errors {409: Conflict}

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
@desc List jobs for a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@optional {filter: str(latest/all)=latest # Filters jobs by their `completed_at` timestamp. `latest` returns jobs from the most recent execution of the workflow run. `all` returns all jobs for a workflow run, including from old executions of the workflow run., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, jobs: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs
@desc Download workflow run logs
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@errors {302: Response}

@endpoint DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs
@desc Delete workflow run logs
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@returns(204) Response
@errors {403: Forbidden, 500: Internal Error}

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
@desc Get pending deployments for a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
@desc Review pending deployments for a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run., environment_ids: [int] # The list of environment ids to approve or reject, state: str(approved/rejected) # Whether to approve or reject deployment to the specified environments., comment: str # A comment to accompany the deployment review}
@returns(200) Response
@example_request {"environment_ids":[161171787],"state":"approved","comment":"Ship it!"}

@endpoint POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun
@desc Re-run a workflow
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@optional {enable_debug_logging: bool=False # Whether to enable debug logging for the re-run.}
@returns(201) Response

@endpoint POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs
@desc Re-run failed jobs from a workflow run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@optional {enable_debug_logging: bool=False # Whether to enable debug logging for the re-run.}
@returns(201) Response

@endpoint GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing
@desc Get workflow run usage
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., run_id: int # The unique identifier of the workflow run.}
@returns(200) {billable: map{UBUNTU: map{total_ms: int, jobs: int, job_runs: [map]}, MACOS: map{total_ms: int, jobs: int, job_runs: [map]}, WINDOWS: map{total_ms: int, jobs: int, job_runs: [map]}}, run_duration_ms: int} # Response

@endpoint GET /repos/{owner}/{repo}/actions/secrets
@desc List repository secrets
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, secrets: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/secrets/public-key
@desc Get a repository public key
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {key_id: str, key: str, id: int, url: str, title: str, created_at: str} # Response

@endpoint GET /repos/{owner}/{repo}/actions/secrets/{secret_name}
@desc Get a repository secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(200) {name: str, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}
@desc Create or update a repository secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., secret_name: str # The name of the secret., encrypted_value: str # Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/actions/secrets#get-a-repository-public-key) endpoint., key_id: str # ID of the key you used to encrypt the secret.}
@returns(201) Response when creating a secret
@returns(204) Response when updating a secret
@example_request {"encrypted_value":"c2VjcmV0","key_id":"012345678912345678"}

@endpoint DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}
@desc Delete a repository secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/actions/variables
@desc List repository variables
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=10 # The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, variables: [map]} # Response

@endpoint POST /repos/{owner}/{repo}/actions/variables
@desc Create a repository variable
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the variable., value: str # The value of the variable.}
@returns(201) Response
@example_request {"name":"USERNAME","value":"octocat"}

@endpoint GET /repos/{owner}/{repo}/actions/variables/{name}
@desc Get a repository variable
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the variable.}
@returns(200) {name: str, value: str, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint PATCH /repos/{owner}/{repo}/actions/variables/{name}
@desc Update a repository variable
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the variable.}
@optional {name: str # The name of the variable., value: str # The value of the variable.}
@returns(204) Response
@example_request {"name":"USERNAME","value":"octocat"}

@endpoint DELETE /repos/{owner}/{repo}/actions/variables/{name}
@desc Delete a repository variable
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the variable.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/actions/workflows
@desc List repository workflows
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, workflows: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}
@desc Get a workflow
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., workflow_id: any # The ID of the workflow. You can also pass the workflow file name as a string.}
@returns(200) {id: int, node_id: str, name: str, path: str, state: str, created_at: str(date-time), updated_at: str(date-time), url: str, html_url: str, badge_url: str, deleted_at: str(date-time)} # Response

@endpoint PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable
@desc Disable a workflow
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., workflow_id: any # The ID of the workflow. You can also pass the workflow file name as a string.}
@returns(204) Response

@endpoint POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches
@desc Create a workflow dispatch event
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., workflow_id: any # The ID of the workflow. You can also pass the workflow file name as a string., ref: str # The git reference for the workflow. The reference can be a branch or tag name.}
@optional {inputs: map # Input keys and values configured in the workflow file. The maximum number of properties is 25. Any default properties configured in the workflow file will be used when `inputs` are omitted.}
@returns(204) Response
@example_request {"ref":"topic-branch","inputs":{"name":"Mona the Octocat","home":"San Francisco, CA"}}

@endpoint PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable
@desc Enable a workflow
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., workflow_id: any # The ID of the workflow. You can also pass the workflow file name as a string.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs
@desc List workflow runs for a workflow
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., workflow_id: any # The ID of the workflow. You can also pass the workflow file name as a string.}
@optional {actor: str # Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run., branch: str # Returns workflow runs associated with a branch. Use the name of the branch of the `push`., event: str # Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).", status: str(completed/action_required/cancelled/failure/neutral/skipped/stale/success/timed_out/in_progress/queued/requested/waiting/pending) # Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", created: str(date-time) # Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).", exclude_pull_requests: bool=False # If `true` pull requests are omitted from the response (empty array)., check_suite_id: int # Returns workflow runs with the `check_suite_id` that you specify., head_sha: str # Only returns workflow runs that are associated with the specified `head_sha`.}
@returns(200) {total_count: int, workflow_runs: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing
@desc Get workflow usage
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., workflow_id: any # The ID of the workflow. You can also pass the workflow file name as a string.}
@returns(200) {billable: map{UBUNTU: map{total_ms: int}, MACOS: map{total_ms: int}, WINDOWS: map{total_ms: int}}} # Response

@endpoint GET /repos/{owner}/{repo}/activity
@desc List repository activities
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {direction: str(asc/desc)=desc # The direction to sort the results by., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", ref: str # The Git reference for the activities you want to list.  The `ref` for a branch can be formatted either as `refs/heads/BRANCH_NAME` or `BRANCH_NAME`, where `BRANCH_NAME` is the name of your branch., actor: str # The GitHub username to use to filter by the actor who performed the activity., time_period: str(day/week/month/quarter/year) # The time period to filter by.  For example, `day` will filter for activity that occurred in the past 24 hours, and `week` will filter for activity that occurred in the past 7 days (168 hours)., activity_type: str(push/force_push/branch_creation/branch_deletion/pr_merge/merge_queue_merge) # The activity type to filter by.  For example, you can choose to filter by "force_push", to see all force pushes to the repository.}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/assignees
@desc List assignees
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/assignees/{assignee}
@desc Check if a user can be assigned
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., assignee: str}
@returns(204) If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
@errors {404: Otherwise a `404` status code is returned.}

@endpoint POST /repos/{owner}/{repo}/attestations
@desc Create an attestation
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., bundle: map{mediaType: str, verificationMaterial: map, dsseEnvelope: map} # The attestation's Sigstore Bundle. Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.}
@returns(201) {id: int} # response
@errors {403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"$ref":"#/components/examples/attestation"}

@endpoint GET /repos/{owner}/{repo}/attestations/{subject_digest}
@desc List attestations
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., subject_digest: str # The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", predicate_type: str # Optional filter for fetching attestations with a given predicate type. This option accepts `provenance`, `sbom`, `release`, or freeform text for custom predicate types.}
@returns(200) {attestations: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/autolinks
@desc Get all autolinks of a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/autolinks
@desc Create an autolink reference for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., key_prefix: str # This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit., url_template: str # The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.}
@optional {is_alphanumeric: bool=True # Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.}
@returns(201) {id: int, key_prefix: str, url_template: str, is_alphanumeric: bool, updated_at: str(date-time)?} # response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"key_prefix":"TICKET-","url_template":"https://example.com/TICKET?query=<num>","is_alphanumeric":true}

@endpoint GET /repos/{owner}/{repo}/autolinks/{autolink_id}
@desc Get an autolink reference of a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., autolink_id: int # The unique identifier of the autolink.}
@returns(200) {id: int, key_prefix: str, url_template: str, is_alphanumeric: bool, updated_at: str(date-time)?} # Response
@errors {404: Resource not found}

@endpoint DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}
@desc Delete an autolink reference from a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., autolink_id: int # The unique identifier of the autolink.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/automated-security-fixes
@desc Check if Dependabot security updates are enabled for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {enabled: bool, paused: bool} # Response if Dependabot is enabled
@errors {404: Not Found if Dependabot is not enabled for the repository}

@endpoint PUT /repos/{owner}/{repo}/automated-security-fixes
@desc Enable Dependabot security updates
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response

@endpoint DELETE /repos/{owner}/{repo}/automated-security-fixes
@desc Disable Dependabot security updates
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/branches
@desc List branches
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {protected: bool # Setting to `true` returns only branches protected by branch protections or rulesets. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/branches/{branch}
@desc Get a branch
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) {name: str, commit: map{url: str(uri), sha: str, node_id: str, html_url: str(uri), comments_url: str(uri), commit: map{url: str(uri), author: map?, committer: map?, message: str, comment_count: int, tree: map, verification: map}, author: any?, committer: any?, parents: [map], stats: map{additions: int, deletions: int, total: int}, files: [map]}, _links: map{html: str, self: str(uri)}, protected: bool, protection: map{url: str, enabled: bool, required_status_checks: map{url: str, enforcement_level: str, contexts: [str], checks: [map], contexts_url: str, strict: bool}, enforce_admins: map{url: str(uri), enabled: bool}, required_pull_request_reviews: map{url: str(uri), dismissal_restrictions: map, bypass_pull_request_allowances: map, dismiss_stale_reviews: bool, require_code_owner_reviews: bool, required_approving_review_count: int, require_last_push_approval: bool}, restrictions: map{url: str(uri), users_url: str(uri), teams_url: str(uri), apps_url: str(uri), users: [map], teams: [map], apps: [map]}, required_linear_history: map{enabled: bool}, allow_force_pushes: map{enabled: bool}, allow_deletions: map{enabled: bool}, block_creations: map{enabled: bool}, required_conversation_resolution: map{enabled: bool}, name: str, protection_url: str, required_signatures: map{url: str(uri), enabled: bool}, lock_branch: map{enabled: bool}, allow_fork_syncing: map{enabled: bool}}, protection_url: str(uri), pattern: str, required_approving_review_count: int} # Response
@errors {301: Moved permanently, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection
@desc Get branch protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) {url: str, enabled: bool, required_status_checks: map{url: str, enforcement_level: str, contexts: [str], checks: [map], contexts_url: str, strict: bool}, enforce_admins: map{url: str(uri), enabled: bool}, required_pull_request_reviews: map{url: str(uri), dismissal_restrictions: map{users: [map], teams: [map], apps: [map], url: str, users_url: str, teams_url: str}, bypass_pull_request_allowances: map{users: [map], teams: [map], apps: [map]}, dismiss_stale_reviews: bool, require_code_owner_reviews: bool, required_approving_review_count: int, require_last_push_approval: bool}, restrictions: map{url: str(uri), users_url: str(uri), teams_url: str(uri), apps_url: str(uri), users: [map], teams: [map], apps: [map]}, required_linear_history: map{enabled: bool}, allow_force_pushes: map{enabled: bool}, allow_deletions: map{enabled: bool}, block_creations: map{enabled: bool}, required_conversation_resolution: map{enabled: bool}, name: str, protection_url: str, required_signatures: map{url: str(uri), enabled: bool}, lock_branch: map{enabled: bool}, allow_fork_syncing: map{enabled: bool}} # Response
@errors {404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/branches/{branch}/protection
@desc Update branch protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql)., required_status_checks: map{strict!: bool, contexts!: [str], checks: [map]} # Require status checks to pass before merging. Set to `null` to disable., enforce_admins: bool # Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable., required_pull_request_reviews: map{dismissal_restrictions: map, dismiss_stale_reviews: bool, require_code_owner_reviews: bool, required_approving_review_count: int, require_last_push_approval: bool, bypass_pull_request_allowances: map} # Require at least one approving review on a pull request, before merging. Set to `null` to disable., restrictions: map{users!: [str], teams!: [str], apps: [str]} # Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.}
@optional {required_linear_history: bool # Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation., allow_force_pushes: bool # Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.", allow_deletions: bool # Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation., block_creations: bool # If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`., required_conversation_resolution: bool # Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`., lock_branch: bool=False # Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`., allow_fork_syncing: bool=False # Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.}
@returns(200) {url: str(uri), required_status_checks: map{url: str(uri), strict: bool, contexts: [str], checks: [map], contexts_url: str(uri)}, required_pull_request_reviews: map{url: str(uri), dismiss_stale_reviews: bool, require_code_owner_reviews: bool, required_approving_review_count: int, require_last_push_approval: bool, dismissal_restrictions: map{url: str(uri), users_url: str(uri), teams_url: str(uri), users: [map], teams: [map], apps: [map]}, bypass_pull_request_allowances: map{users: [map], teams: [map], apps: [map]}}, required_signatures: map{url: str(uri), enabled: bool}, enforce_admins: map{url: str(uri), enabled: bool}, required_linear_history: map{enabled: bool}, allow_force_pushes: map{enabled: bool}, allow_deletions: map{enabled: bool}, restrictions: map{url: str(uri), users_url: str(uri), teams_url: str(uri), apps_url: str(uri), users: [map], teams: [map], apps: [map]}, required_conversation_resolution: map{enabled: bool}, block_creations: map{enabled: bool}, lock_branch: map{enabled: bool}, allow_fork_syncing: map{enabled: bool}} # Response
@errors {403: Forbidden, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"required_status_checks":{"strict":true,"contexts":["continuous-integration/travis-ci"]},"enforce_admins":true,"required_pull_request_reviews":{"dismissal_restrictions":{"users":["octocat"],"teams":["justice-league"]},"dismiss_stale_reviews":true,"require_code_owner_reviews":true,"required_approving_review_count":2,"require_last_push_approval":true,"bypass_pull_request_allowances":{"users":["octocat"],"teams":["justice-league"]}},"restrictions":{"users":["octocat"],"teams":["justice-league"],"apps":["super-ci"]},"required_linear_history":true,"allow_force_pushes":true,"allow_deletions":true,"block_creations":true,"required_conversation_resolution":true,"lock_branch":true,"allow_fork_syncing":true}

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection
@desc Delete branch protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(204) Response
@errors {403: Forbidden}

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
@desc Get admin branch protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) {url: str(uri), enabled: bool} # Response

@endpoint POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
@desc Set admin branch protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) {url: str(uri), enabled: bool} # Response

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
@desc Delete admin branch protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
@desc Get pull request review protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) {url: str(uri), dismissal_restrictions: map{users: [map], teams: [map], apps: [map], url: str, users_url: str, teams_url: str}, bypass_pull_request_allowances: map{users: [map], teams: [map], apps: [map]}, dismiss_stale_reviews: bool, require_code_owner_reviews: bool, required_approving_review_count: int, require_last_push_approval: bool} # Response

@endpoint PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
@desc Update pull request review protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@optional {dismissal_restrictions: map{users: [str], teams: [str], apps: [str]} # Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories., dismiss_stale_reviews: bool # Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit., require_code_owner_reviews: bool # Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed., required_approving_review_count: int # Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers., require_last_push_approval: bool=False # Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`, bypass_pull_request_allowances: map{users: [str], teams: [str], apps: [str]} # Allow specific users, teams, or apps to bypass pull request requirements.}
@returns(200) {url: str(uri), dismissal_restrictions: map{users: [map], teams: [map], apps: [map], url: str, users_url: str, teams_url: str}, bypass_pull_request_allowances: map{users: [map], teams: [map], apps: [map]}, dismiss_stale_reviews: bool, require_code_owner_reviews: bool, required_approving_review_count: int, require_last_push_approval: bool} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"dismissal_restrictions":{"users":["octocat"],"teams":["justice-league"],"apps":["octoapp"]},"bypass_pull_request_allowances":{"users":["octocat"],"teams":["justice-league"],"apps":["octoapp"]},"dismiss_stale_reviews":true,"require_code_owner_reviews":true,"required_approving_review_count":2,"require_last_push_approval":true}

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
@desc Delete pull request review protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
@desc Get commit signature protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) {url: str(uri), enabled: bool} # Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
@desc Create commit signature protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) {url: str(uri), enabled: bool} # Response
@errors {404: Resource not found}

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
@desc Delete commit signature protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
@desc Get status checks protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) {url: str(uri), strict: bool, contexts: [str], checks: [map], contexts_url: str(uri)} # Response
@errors {404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
@desc Update status check protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@optional {strict: bool # Require branches to be up to date before merging., contexts: [str] # **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control., checks: [map{context!: str, app_id: int}] # The list of status checks to require in order to merge into this branch.}
@returns(200) {url: str(uri), strict: bool, contexts: [str], checks: [map], contexts_url: str(uri)} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"strict":true,"contexts":["continuous-integration/travis-ci"]}

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
@desc Remove status check protection
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
@desc Get all status check contexts
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
@desc Add status check contexts
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed., 403: Forbidden, 404: Resource not found}
@example_request {"contexts":["continuous-integration/travis-ci","continuous-integration/jenkins"]}

@endpoint PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
@desc Set status check contexts
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"contexts":["continuous-integration/travis-ci"]}

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
@desc Remove status check contexts
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"contexts":["continuous-integration/jenkins"]}

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
@desc Get access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) {url: str(uri), users_url: str(uri), teams_url: str(uri), apps_url: str(uri), users: [map], teams: [map], apps: [map]} # Response
@errors {404: Resource not found}

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
@desc Delete access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
@desc Get apps with access to the protected branch
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
@desc Add app access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql)., apps: [str] # The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"apps":["octoapp"]}

@endpoint PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
@desc Set app access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql)., apps: [str] # The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"apps":["octoapp"]}

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
@desc Remove app access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql)., apps: [str] # The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"apps":["my-app"]}

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
@desc Get teams with access to the protected branch
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
@desc Add team access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"teams":["justice-league"]}

@endpoint PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
@desc Set team access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"teams":["justice-league"]}

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
@desc Remove team access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"teams":["octocats"]}

@endpoint GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
@desc Get users with access to the protected branch
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
@desc Add user access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql)., users: [str] # The username for users}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"users":["octocat"]}

@endpoint PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
@desc Set user access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql)., users: [str] # The username for users}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"users":["octocat"]}

@endpoint DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
@desc Remove user access restrictions
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql)., users: [str] # The username for users}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"users":["octocat"]}

@endpoint POST /repos/{owner}/{repo}/branches/{branch}/rename
@desc Rename a branch
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql)., new_name: str # The new name of the branch.}
@returns(201) {name: str, commit: map{url: str(uri), sha: str, node_id: str, html_url: str(uri), comments_url: str(uri), commit: map{url: str(uri), author: map?, committer: map?, message: str, comment_count: int, tree: map, verification: map}, author: any?, committer: any?, parents: [map], stats: map{additions: int, deletions: int, total: int}, files: [map]}, _links: map{html: str, self: str(uri)}, protected: bool, protection: map{url: str, enabled: bool, required_status_checks: map{url: str, enforcement_level: str, contexts: [str], checks: [map], contexts_url: str, strict: bool}, enforce_admins: map{url: str(uri), enabled: bool}, required_pull_request_reviews: map{url: str(uri), dismissal_restrictions: map, bypass_pull_request_allowances: map, dismiss_stale_reviews: bool, require_code_owner_reviews: bool, required_approving_review_count: int, require_last_push_approval: bool}, restrictions: map{url: str(uri), users_url: str(uri), teams_url: str(uri), apps_url: str(uri), users: [map], teams: [map], apps: [map]}, required_linear_history: map{enabled: bool}, allow_force_pushes: map{enabled: bool}, allow_deletions: map{enabled: bool}, block_creations: map{enabled: bool}, required_conversation_resolution: map{enabled: bool}, name: str, protection_url: str, required_signatures: map{url: str(uri), enabled: bool}, lock_branch: map{enabled: bool}, allow_fork_syncing: map{enabled: bool}}, protection_url: str(uri), pattern: str, required_approving_review_count: int} # Response
@errors {403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"new_name":"my_renamed_branch"}

@endpoint POST /repos/{owner}/{repo}/check-runs
@desc Create a check run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the check. For example, "code-coverage"., head_sha: str # The SHA of the commit.}
@optional {details_url: str # The URL of the integrator's site that has the full details of the check. If the integrator does not provide this, then the homepage of the GitHub app is used., external_id: str # A reference for the run on the integrator's system., status: str(queued/in_progress/completed/waiting/requested/pending)=queued # The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`., started_at: str(date-time) # The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., conclusion: str(action_required/cancelled/failure/neutral/success/skipped/stale/timed_out) # **Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check.  **Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this., completed_at: str(date-time) # The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., output: map{title!: str, summary!: str, text: str, annotations: [map], images: [map]} # Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run., actions: [map{label!: str, description!: str, identifier!: str}] # Displays a button on GitHub that can be clicked to alert your app to do additional tasks. For example, a code linting app can display a button that automatically fixes detected errors. The button created in this object is displayed after the check run completes. When a user clicks the button, GitHub sends the [`check_run.requested_action` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) to your app. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions)."}
@returns(201) {id: int(int64), head_sha: str, node_id: str, external_id: str?, url: str, html_url: str?, details_url: str?, status: str, conclusion: str?, started_at: str(date-time)?, completed_at: str(date-time)?, output: map{title: str?, summary: str?, text: str?, annotations_count: int, annotations_url: str(uri)}, name: str, check_suite: map?{id: int}, app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, pull_requests: [map], deployment: map{url: str(uri), id: int, node_id: str, task: str, original_environment: str, environment: str, description: str?, created_at: str(date-time), updated_at: str(date-time), statuses_url: str(uri), repository_url: str(uri), transient_environment: bool, production_environment: bool, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map, events: [str], installations_count: int}}} # Response
@example_request {"name":"mighty_readme","head_sha":"ce587453ced02b1526dfb4cb910479d431683101","status":"in_progress","external_id":"42","started_at":"2018-05-04T01:14:52Z","output":{"title":"Mighty Readme report","summary":"","text":""}}

@endpoint GET /repos/{owner}/{repo}/check-runs/{check_run_id}
@desc Get a check run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., check_run_id: int # The unique identifier of the check run.}
@returns(200) {id: int(int64), head_sha: str, node_id: str, external_id: str?, url: str, html_url: str?, details_url: str?, status: str, conclusion: str?, started_at: str(date-time)?, completed_at: str(date-time)?, output: map{title: str?, summary: str?, text: str?, annotations_count: int, annotations_url: str(uri)}, name: str, check_suite: map?{id: int}, app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, pull_requests: [map], deployment: map{url: str(uri), id: int, node_id: str, task: str, original_environment: str, environment: str, description: str?, created_at: str(date-time), updated_at: str(date-time), statuses_url: str(uri), repository_url: str(uri), transient_environment: bool, production_environment: bool, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map, events: [str], installations_count: int}}} # Response

@endpoint PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}
@desc Update a check run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., check_run_id: int # The unique identifier of the check run.}
@optional {name: str # The name of the check. For example, "code-coverage"., details_url: str # The URL of the integrator's site that has the full details of the check., external_id: str # A reference for the run on the integrator's system., started_at: str(date-time) # This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., status: str(queued/in_progress/completed/waiting/requested/pending) # The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`., conclusion: str(action_required/cancelled/failure/neutral/success/skipped/stale/timed_out) # **Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check.  **Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this., completed_at: str(date-time) # The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., output: map{title: str, summary!: str, text: str, annotations: [map], images: [map]} # Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run., actions: [map{label!: str, description!: str, identifier!: str}] # Possible further actions the integrator can perform, which a user may trigger. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions)."}
@returns(200) {id: int(int64), head_sha: str, node_id: str, external_id: str?, url: str, html_url: str?, details_url: str?, status: str, conclusion: str?, started_at: str(date-time)?, completed_at: str(date-time)?, output: map{title: str?, summary: str?, text: str?, annotations_count: int, annotations_url: str(uri)}, name: str, check_suite: map?{id: int}, app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, pull_requests: [map], deployment: map{url: str(uri), id: int, node_id: str, task: str, original_environment: str, environment: str, description: str?, created_at: str(date-time), updated_at: str(date-time), statuses_url: str(uri), repository_url: str(uri), transient_environment: bool, production_environment: bool, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map, events: [str], installations_count: int}}} # Response
@example_request {"name":"mighty_readme","started_at":"2018-05-04T01:14:52Z","status":"completed","conclusion":"success","completed_at":"2018-05-04T01:14:52Z","output":{"title":"Mighty Readme report","summary":"There are 0 failures, 2 warnings, and 1 notices.","text":"You may have some misspelled words on lines 2 and 4. You also may want to add a section in your README about how to install your app.","annotations":[{"path":"README.md","annotation_level":"warning","title":"Spell Checker","message":"Check your spelling for 'banaas'.","raw_details":"Do you mean 'bananas' or 'banana'?","start_line":2,"end_line":2},{"path":"README.md","annotation_level":"warning","title":"Spell Checker","message":"Check your spelling for 'aples'","raw_details":"Do you mean 'apples' or 'Naples'","start_line":4,"end_line":4}],"images":[{"alt":"Super bananas","image_url":"http://example.com/images/42"}]}}

@endpoint GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
@desc List check run annotations
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., check_run_id: int # The unique identifier of the check run.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest
@desc Rerequest a check run
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., check_run_id: int # The unique identifier of the check run.}
@returns(201) Response
@errors {403: Forbidden if the check run is not rerequestable or doesn't belong to the authenticated GitHub App, 422: Validation error if the check run is not rerequestable, 404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/check-suites
@desc Create a check suite
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., head_sha: str # The sha of the head commit.}
@returns(200) {id: int(int64), node_id: str, head_branch: str?, head_sha: str, status: str?, conclusion: str?, url: str?, before: str?, after: str?, pull_requests: [map]?, app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, created_at: str(date-time)?, updated_at: str(date-time)?, head_commit: map{id: str, tree_id: str, message: str, timestamp: str(date-time), author: map?{name: str, email: str(email)}, committer: map?{name: str, email: str(email)}}, latest_check_runs_count: int, check_runs_url: str, rerequestable: bool, runs_rerequestable: bool} # Response when the suite already exists
@returns(201) {id: int(int64), node_id: str, head_branch: str?, head_sha: str, status: str?, conclusion: str?, url: str?, before: str?, after: str?, pull_requests: [map]?, app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, created_at: str(date-time)?, updated_at: str(date-time)?, head_commit: map{id: str, tree_id: str, message: str, timestamp: str(date-time), author: map?{name: str, email: str(email)}, committer: map?{name: str, email: str(email)}}, latest_check_runs_count: int, check_runs_url: str, rerequestable: bool, runs_rerequestable: bool} # Response when the suite was created
@example_request {"head_sha":"d6fde92930d4715a2b49857d24b940956b26d2d3"}

@endpoint PATCH /repos/{owner}/{repo}/check-suites/preferences
@desc Update repository preferences for check suites
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {auto_trigger_checks: [map{app_id!: int, setting!: bool}] # Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default.}
@returns(200) {preferences: map{auto_trigger_checks: [map]}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}} # Response
@example_request {"auto_trigger_checks":[{"app_id":4,"setting":false}]}

@endpoint GET /repos/{owner}/{repo}/check-suites/{check_suite_id}
@desc Get a check suite
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., check_suite_id: int # The unique identifier of the check suite.}
@returns(200) {id: int(int64), node_id: str, head_branch: str?, head_sha: str, status: str?, conclusion: str?, url: str?, before: str?, after: str?, pull_requests: [map]?, app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, created_at: str(date-time)?, updated_at: str(date-time)?, head_commit: map{id: str, tree_id: str, message: str, timestamp: str(date-time), author: map?{name: str, email: str(email)}, committer: map?{name: str, email: str(email)}}, latest_check_runs_count: int, check_runs_url: str, rerequestable: bool, runs_rerequestable: bool} # Response

@endpoint GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
@desc List check runs in a check suite
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., check_suite_id: int # The unique identifier of the check suite.}
@optional {check_name: str # Returns check runs with the specified `name`., status: str(queued/in_progress/completed) # Returns check runs with the specified `status`., filter: str(latest/all)=latest # Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, check_runs: [map]} # Response

@endpoint POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
@desc Rerequest a check suite
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., check_suite_id: int # The unique identifier of the check suite.}
@returns(201) Response

@endpoint GET /repos/{owner}/{repo}/code-scanning/alerts
@desc List code scanning alerts for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {tool_name: str # The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both., tool_guid: str # The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", ref: str # The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`., pr: int # The number of the pull request for the results you want to list., direction: str(asc/desc)=desc # The direction to sort the results by., before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", sort: str(created/updated)=created # The property by which to sort the results., state: str # If specified, only code scanning alerts with this state will be returned., severity: str # If specified, only code scanning alerts with this severity will be returned., assignees: str # Filter alerts by assignees. Provide a comma-separated list of user handles (e.g., `octocat` or `octocat,hubot`). Use `*` to list alerts with at least one assignee or `none` to list alerts with no assignees.}
@returns(200) Response
@errors {304: Not modified, 403: Response if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
@desc Get a code scanning alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.}
@returns(200) {number: int, created_at: str(date-time), updated_at: str(date-time), url: str(uri), html_url: str(uri), instances_url: str(uri), state: str?, fixed_at: str(date-time)?, dismissed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, dismissed_at: str(date-time)?, dismissed_reason: str?, dismissed_comment: str?, rule: map{id: str?, name: str, severity: str?, security_severity_level: str?, description: str, full_description: str, tags: [str]?, help: str?, help_uri: str?}, tool: map{name: str, version: str?, guid: str?}, most_recent_instance: map{ref: str, analysis_key: str, environment: str, category: str, state: str?, commit_sha: str, message: map{text: str}, location: map{path: str, start_line: int, end_line: int, start_column: int, end_column: int}, html_url: str, classifications: [str]}, dismissal_approved_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]} # Response
@errors {304: Not modified, 403: Response if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
@desc Update a code scanning alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.}
@optional {state: str(open/dismissed) # Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`., dismissed_reason: str(false positive/won't fix/used in tests) # **Required when the state is dismissed.** The reason for dismissing or closing the alert., dismissed_comment: str # The dismissal comment associated with the dismissal of the alert., create_request: bool # If `true`, attempt to create an alert dismissal request., assignees: [str] # The list of users to assign to the code scanning alert. An empty array unassigns all previous assignees from the alert.}
@returns(200) {number: int, created_at: str(date-time), updated_at: str(date-time), url: str(uri), html_url: str(uri), instances_url: str(uri), state: str?, fixed_at: str(date-time)?, dismissed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, dismissed_at: str(date-time)?, dismissed_reason: str?, dismissed_comment: str?, rule: map{id: str?, name: str, severity: str?, security_severity_level: str?, description: str, full_description: str, tags: [str]?, help: str?, help_uri: str?}, tool: map{name: str, version: str?, guid: str?}, most_recent_instance: map{ref: str, analysis_key: str, environment: str, category: str, state: str?, commit_sha: str, message: map{text: str}, location: map{path: str, start_line: int, end_line: int, start_column: int, end_column: int}, html_url: str, classifications: [str]}, dismissal_approved_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]} # Response
@errors {400: Bad Request, 403: Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}
@example_request {"state":"dismissed","dismissed_reason":"false positive","dismissed_comment":"This alert is not actually correct, because there's a sanitizer included in the library.","create_request":true}

@endpoint GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix
@desc Get the status of an autofix for a code scanning alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.}
@returns(200) {status: str, description: str?, started_at: str(date-time)} # Response
@errors {400: Bad Request, 403: Response if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix
@desc Create an autofix for a code scanning alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.}
@returns(200) {status: str, description: str?, started_at: str(date-time)} # OK
@returns(202) {status: str, description: str?, started_at: str(date-time)} # Accepted
@errors {400: Bad Request, 403: Response if the repository is archived, if GitHub Advanced Security is not enabled for this repository or if rate limit is exceeded, 404: Resource not found, 422: Unprocessable Entity, 503: Service unavailable}

@endpoint POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits
@desc Commit an autofix for a code scanning alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.}
@optional {target_ref: str # The Git reference of target branch for the commit. Branch needs to already exist.  For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation., message: str # Commit message to be used.}
@returns(201) {target_ref: str, sha: str} # Created
@errors {400: Bad Request, 403: Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 422: Unprocessable Entity, 503: Service unavailable}
@example_request {"target_ref":"refs/heads/fix-bug","message":"Let's fix this \ud83e\udeb2!"}

@endpoint GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
@desc List instances of a code scanning alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", ref: str # The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`., pr: int # The number of the pull request for the results you want to list.}
@returns(200) Response
@errors {403: Response if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/code-scanning/analyses
@desc List code scanning analyses for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {tool_name: str # The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both., tool_guid: str # The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", pr: int # The number of the pull request for the results you want to list., ref: str # The Git reference for the analyses you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`., sarif_id: str # Filter analyses belonging to the same SARIF upload., direction: str(asc/desc)=desc # The direction to sort the results by., sort: str=created # The property by which to sort the results.}
@returns(200) Response
@errors {403: Response if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
@desc Get a code scanning analysis for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., analysis_id: int # The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.}
@returns(200) {ref: str, commit_sha: str, analysis_key: str, environment: str, category: str, error: str, created_at: str(date-time), results_count: int, rules_count: int, id: int, url: str(uri), sarif_id: str, tool: map{name: str, version: str?, guid: str?}, deletable: bool, warning: str} # Response
@errors {403: Response if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 422: Response if analysis could not be processed, 503: Service unavailable}

@endpoint DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
@desc Delete a code scanning analysis from a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., analysis_id: int # The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.}
@optional {confirm_delete: str # Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final analysis in a set without setting this parameter to `true`, you'll get a 400 response with the message: `Analysis is last of its type and deletion may result in the loss of historical alert data. Please specify confirm_delete.`}
@returns(200) {next_analysis_url: str(uri)?, confirm_delete_url: str(uri)?} # Response
@errors {400: Bad Request, 403: Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/code-scanning/codeql/databases
@desc List CodeQL databases for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response
@errors {403: Response if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}
@desc Get a CodeQL database for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., language: str # The language of the CodeQL database.}
@returns(200) {id: int, name: str, language: str, uploader: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content_type: str, size: int, created_at: str(date-time), updated_at: str(date-time), url: str(uri), commit_oid: str?} # Response
@errors {302: Found, 403: Response if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}
@desc Delete a CodeQL database
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., language: str # The language of the CodeQL database.}
@returns(204) Response
@errors {403: Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses
@desc Create a CodeQL variant analysis
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., language: str(actions/cpp/csharp/go/java/javascript/python/ruby/rust/swift) # The language targeted by the CodeQL query, query_pack: str # A Base64-encoded tarball containing a CodeQL query and all its dependencies}
@optional {repositories: [str] # List of repository names (in the form `owner/repo-name`) to run the query against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required., repository_lists: [str] # List of repository lists to run the query against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required., repository_owners: [str] # List of organization or user names whose repositories the query should be run against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required.}
@returns(201) {id: int, controller_repo: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, hooks_url: str(uri)}, actor: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, query_language: str, query_pack_url: str, created_at: str(date-time), updated_at: str(date-time), completed_at: str(date-time)?, status: str, actions_workflow_run_id: int, failure_reason: str, scanned_repositories: [map], skipped_repositories: map{access_mismatch_repos: map{repository_count: int, repositories: [map]}, not_found_repos: map{repository_count: int, repository_full_names: [str]}, no_codeql_db_repos: map{repository_count: int, repositories: [map]}, over_limit_repos: map{repository_count: int, repositories: [map]}}} # Variant analysis submitted for processing
@errors {404: Resource not found, 422: Unable to process variant analysis submission, 503: Service unavailable}
@example_request {"language":"csharp","query_pack":"aGVsbG8=","repositories":["octocat/Hello-World","octocat/example"]}

@endpoint GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}
@desc Get the summary of a CodeQL variant analysis
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., codeql_variant_analysis_id: int # The unique identifier of the variant analysis.}
@returns(200) {id: int, controller_repo: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, hooks_url: str(uri)}, actor: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, query_language: str, query_pack_url: str, created_at: str(date-time), updated_at: str(date-time), completed_at: str(date-time)?, status: str, actions_workflow_run_id: int, failure_reason: str, scanned_repositories: [map], skipped_repositories: map{access_mismatch_repos: map{repository_count: int, repositories: [map]}, not_found_repos: map{repository_count: int, repository_full_names: [str]}, no_codeql_db_repos: map{repository_count: int, repositories: [map]}, over_limit_repos: map{repository_count: int, repositories: [map]}}} # Response
@errors {404: Resource not found, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}
@desc Get the analysis status of a repository in a CodeQL variant analysis
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the controller repository., codeql_variant_analysis_id: int # The ID of the variant analysis., repo_owner: str # The account owner of the variant analysis repository. The name is not case sensitive., repo_name: str # The name of the variant analysis repository.}
@returns(200) {repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, hooks_url: str(uri)}, analysis_status: str, artifact_size_in_bytes: int, result_count: int, failure_message: str, database_commit_sha: str, source_location_prefix: str, artifact_url: str} # Response
@errors {404: Resource not found, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/code-scanning/default-setup
@desc Get a code scanning default setup configuration
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {state: str, languages: [str], runner_type: str?, runner_label: str?, query_suite: str, threat_model: str, updated_at: str(date-time)?, schedule: str?} # Response
@errors {403: Response if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 503: Service unavailable}

@endpoint PATCH /repos/{owner}/{repo}/code-scanning/default-setup
@desc Update a code scanning default setup configuration
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {state: str(configured/not-configured) # The desired state of code scanning default setup., runner_type: str(standard/labeled) # Runner type to be used., runner_label: str # Runner label to be used if the runner type is labeled., query_suite: str(default/extended) # CodeQL query suite to be used., threat_model: str(remote/remote_and_local) # Threat model to be used for code scanning analysis. Use `remote` to analyze only network sources and `remote_and_local` to include local sources like filesystem access, command-line arguments, database reads, environment variable and standard input., languages: [str] # CodeQL languages to be analyzed.}
@returns(200) Response
@returns(202) {run_id: int, run_url: str} # Response
@errors {403: Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 409: Response if there is already a validation run in progress with a different default setup configuration, 422: Response if the configuration change cannot be made because the repository is not in the required state, 503: Service unavailable}
@example_request {"state":"configured","threat_model":"remote_and_local"}

@endpoint POST /repos/{owner}/{repo}/code-scanning/sarifs
@desc Upload an analysis as SARIF data
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., commit_sha: str # The SHA of the commit to which the analysis you are uploading relates., ref: str # The full Git reference, formatted as `refs/heads/<branch name>`, `refs/tags/<tag>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`., sarif: str # A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see "[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning)."}
@optional {checkout_uri: str(uri) # The base directory used in the analysis, as it appears in the SARIF file. This property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository., started_at: str(date-time) # The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., tool_name: str # The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to "API". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`., validate: bool # Whether the SARIF file will be validated according to the code scanning specifications. This parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning.}
@returns(202) {id: str, url: str(uri)} # Response
@errors {400: Bad Request if the sarif field is invalid, 403: Response if the repository is archived or if GitHub Advanced Security is not enabled for this repository, 404: Resource not found, 413: Payload Too Large if the sarif field is too large, 503: Service unavailable}
@example_request {"commit_sha":"4b6472266afd7b471e86085a6659e8c7f2b119da","ref":"refs/heads/master","sarif":"H4sICMLGdF4AA2V4YW1wbGUuc2FyaWYAvVjdbts2FL7PUxDCijaA/CM7iRNfLkPXYgHSNstumlzQ0pHFVCI1korjFgH2ONtr7Ul2KFmy/mOn6QIkjsjDw0/nfN85NL8dEGL9pNwAImqRObECrWM1H40kXQ2XTAfJIlEgXcE1cD10RTQSVDE10K4aKSqZP1AxuKOIKg1ydJU60jSfSh8Hk6EzHA/vlOCWbfa7B6kYPpj90rlsWCZcmbHP5Bs+4oAWIjQD2SMOeJLh2vIQDnIaQerqXHjw8YIgxohybxAyDsS4cAPKsp03K4RcUs6+Up2D+JXpd8mibKIQN9fM/aMCdbyBujGSSQgVxJtx5qX2d2qUcIweQhEuDQf3GBO6CKHkogx/N3MVCKl/AeVKFuf4y5ubsMGDTj1ep+5I7sgmLIpxtU38hLtmMRGSuCFVyip5eKzs5ydh+LztVL6f2m6oih1BkYiuyQIIJWodxVpERPj4sEiWBNNH8EWT0DMG8EAjzKVHXCrB4FkPu/F64NMk1OeC+2yZSNoBOoR7CC0EzYWGbm+xFDFIzbI011+cLjfZtyJkmMZfumAh02uL3NpV2y+MZ6RAjxibyKrNxxJcVjANSb4eBGwZ1M0KsuyR2poLr5rMl8vaDSeVn6eTWEO2j2xIEcmhwlTKNOi4GMOI8gfuZYkvJ7b4v5Tiumyz7RnHeodFzpS8ASIZCH/AYdWi2z3sG8JtFxJ6fF9yR9CdifBr9Pd6d5V2+zbJKjjCFGGmsHuYFy2ytJq9tUxcLSRSQecppOGKrpUxYfxefMEFK+wOGa4hudQByBVT0L+EKtyACxnRsABhEx1QjVDs1KNI9MbpnhqfE45B6FJvu3hRu5VRU9MhZLmK7fqkKyQSTHNoyMqUFMqXCV3CwAeqEwmVokraK8IuBaGvHjQ0gMYrKjnjyw7uk9uD8tgmsBbFMPnU1bV2ZhkJNkuolUiWys3UPWzs5aaIUz9TBe8zMb+6+nT+6fLy91dlE3xzeDDT4zYszb0bW6NjJd0Rvn2EnLvWLFSdKPpBzInzfRgu8ETyMcH8nIfMnJCeC2PyfTA+UKngcnGH7Hw2hGkVQs5YlIRCtdWZYQ4/73es2JlxkfViOEIhoWJq5Oo6UBBfiKIqFBWhiE3jJGbFwVoxBHTRSuIS67sMeplei24X20shLjG+8gqbKC/bESiNMC+wd5q5id0yeS7CJEqXzmrTWNq3k05l84P6f4/bEmXFJjI0fIt1BGQssUnUDkBYeVhE5TqPnMH3jqogDcP0zKcTgLPTMSzOjhbjuVOmW23l1fYNStulfo6sXlFsGLhbDy5RECPRYGCTgOj2bd4nUQEivEd0H7KKYxqnEhFohuur3a3UPskbH/+Yg0+M5P2MHRJu3ziHh3Z2NCrWt3XF1rWTw8Ne/pfbWYXnDSE0SNZQQt1i18q7te2vOhu7ehWuvVyeu0wbLZi24mhoo6aOOTltzG/lgdVvVoXQq5V+pewkFIzL8fjEcadT55jOjpzFzHuOTtDNrMkJPMVQDd7F09RID72O/UPZ0tmctqZ7kWX6EmSZnDpP8GU67SXM8XE3YSrxbKsx6UReZ4y6n/FVZfJjs9Z7stma75W5yQtkzjk5eSJxk1lv4o7+j8TlhaJ2lsKWZO6lruDPBLib3x5ZN/KGWzZ+pn///evv7OOf4iIBv3oY9L/l1wiJ9p0Tc+F1zZnOE9NxXWEus6IQhr5pMfoqxi8WPsuu0azsns4UC6WzNzHIzbeEx4P/AJ3SefgcFAAA"}

@endpoint GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
@desc Get information about a SARIF upload
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., sarif_id: str # The SARIF ID obtained after uploading.}
@returns(200) {processing_status: str, analyses_url: str(uri)?, errors: [str]?} # Response
@errors {403: Response if GitHub Advanced Security is not enabled for this repository, 404: Not Found if the sarif id does not match any upload, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/code-security-configuration
@desc Get the code security configuration associated with a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {status: str, configuration: map{id: int, name: str, target_type: str, description: str, advanced_security: str, dependency_graph: str, dependency_graph_autosubmit_action: str, dependency_graph_autosubmit_action_options: map{labeled_runners: bool}, dependabot_alerts: str, dependabot_security_updates: str, dependabot_delegated_alert_dismissal: str?, code_scanning_options: map?{allow_advanced: bool?}, code_scanning_default_setup: str, code_scanning_default_setup_options: map?{runner_type: str?, runner_label: str?}, code_scanning_delegated_alert_dismissal: str, secret_scanning: str, secret_scanning_push_protection: str, secret_scanning_delegated_bypass: str, secret_scanning_delegated_bypass_options: map{reviewers: [map]}, secret_scanning_validity_checks: str, secret_scanning_non_provider_patterns: str, secret_scanning_generic_secrets: str, secret_scanning_delegated_alert_dismissal: str, private_vulnerability_reporting: str, enforcement: str, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time)}} # Response
@returns(204) A header with no content is returned.
@errors {304: Not modified, 403: Forbidden, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/codeowners/errors
@desc List CODEOWNERS errors
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {ref: str # A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)}
@returns(200) {errors: [map]} # Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/codespaces
@desc List codespaces in a repository for the authenticated user
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, codespaces: [map]} # Response
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/codespaces
@desc Create a codespace in a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {ref: str # Git ref (typically a branch name) for this codespace, location: str # The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided., geo: str(EuropeWest/SoutheastAsia/UsEast/UsWest) # The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down., client_ip: str # IP for location auto-detection when proxying a request, machine: str # Machine type to use for this codespace, devcontainer_path: str # Path to devcontainer.json config to use for this codespace, multi_repo_permissions_opt_out: bool # Whether to authorize requested permissions from devcontainer.json, working_directory: str # Working directory for this codespace, idle_timeout_minutes: int # Time in minutes before codespace stops from inactivity, display_name: str # Display name for this codespace, retention_period_minutes: int # Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).}
@returns(201) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response when the codespace was successfully created
@returns(202) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response when the codespace creation partially failed but is being retried in the background
@errors {400: Bad Request, 401: Requires authentication, 403: Forbidden, 404: Resource not found, 503: Service unavailable}
@example_request {"ref":"main","machine":"standardLinux32gb"}

@endpoint GET /repos/{owner}/{repo}/codespaces/devcontainers
@desc List devcontainer configurations in a repository for the authenticated user
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, devcontainers: [map]} # Response
@errors {500: Internal Error, 400: Bad Request, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/codespaces/machines
@desc List available machine types for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {location: str # The location to check for available machines. Assigned by IP if not provided., client_ip: str # IP for location auto-detection when proxying a request, ref: str # The branch or commit to check for prebuild availability and devcontainer restrictions.}
@returns(200) {total_count: int, machines: [map]} # Response
@errors {304: Not modified, 500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/codespaces/new
@desc Get default attributes for a codespace
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {ref: str # The branch or commit to check for a default devcontainer path. If not specified, the default branch will be checked., client_ip: str # An alternative IP for default location auto-detection, such as when proxying a request.}
@returns(200) {billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, defaults: map{location: str, devcontainer_path: str?}} # Response when a user is able to create codespaces from the repository.
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/codespaces/permissions_check
@desc Check if permissions defined by a devcontainer have been accepted by the authenticated user
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The git reference that points to the location of the devcontainer configuration to use for the permission check. The value of `ref` will typically be a branch name (`heads/BRANCH_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation., devcontainer_path: str # Path to the devcontainer.json configuration to use for the permission check.}
@returns(200) {accepted: bool} # Response when the permission check is successful
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/codespaces/secrets
@desc List repository secrets
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, secrets: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/codespaces/secrets/public-key
@desc Get a repository public key
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {key_id: str, key: str, id: int, url: str, title: str, created_at: str} # Response

@endpoint GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}
@desc Get a repository secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(200) {name: str, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}
@desc Create or update a repository secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., secret_name: str # The name of the secret.}
@optional {encrypted_value: str # Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key) endpoint., key_id: str # ID of the key you used to encrypt the secret.}
@returns(201) Response when creating a secret
@returns(204) Response when updating a secret
@example_request {"encrypted_value":"c2VjcmV0","key_id":"012345678912345678"}

@endpoint DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}
@desc Delete a repository secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/collaborators
@desc List repository collaborators
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {affiliation: str(outside/direct/all)=all # Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see., permission: str(pull/triage/push/maintain/admin) # Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/collaborators/{username}
@desc Check if a user is a repository collaborator
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) Response if user is a collaborator
@errors {404: Not Found if user is not a collaborator}

@endpoint PUT /repos/{owner}/{repo}/collaborators/{username}
@desc Add a repository collaborator
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@optional {permission: str=push # The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.}
@returns(201) {id: int(int64), repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, invitee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, inviter: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, permissions: str, created_at: str(date-time), expired: bool, url: str, html_url: str, node_id: str} # Response when a new invitation is created
@returns(204) Response when: - an existing collaborator is added as a collaborator - an organization member is added as an individual collaborator - an existing team member (whose team is also a repository collaborator) is added as an individual collaborator
@errors {422: Response when: - validation failed, or the endpoint has been spammed - an Enterprise Managed User (EMU) account was invited to a repository in an enterprise with personal user accounts, 403: Forbidden}
@example_request {"permission":"triage"}

@endpoint DELETE /repos/{owner}/{repo}/collaborators/{username}
@desc Remove a repository collaborator
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(204) No Content when collaborator was removed from the repository.
@errors {422: Validation failed, or the endpoint has been spammed., 403: Forbidden}

@endpoint GET /repos/{owner}/{repo}/collaborators/{username}/permission
@desc Get repository permissions for a user
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., username: str # The handle for the GitHub user account.}
@returns(200) {permission: str, role_name: str, user: map?{login: str, id: int(int64), email: str?, name: str?, node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, permissions: map{pull: bool, triage: bool, push: bool, maintain: bool, admin: bool}, role_name: str, user_view_type: str}} # if user has admin permissions
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/comments
@desc List commit comments for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /repos/{owner}/{repo}/comments/{comment_id}
@desc Get a commit comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@returns(200) {html_url: str(uri), url: str(uri), id: int, node_id: str, body: str, path: str?, position: int?, line: int?, commit_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}} # Response
@errors {404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/comments/{comment_id}
@desc Update a commit comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment., body: str # The contents of the comment}
@returns(200) {html_url: str(uri), url: str(uri), id: int, node_id: str, body: str, path: str?, position: int?, line: int?, commit_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}} # Response
@errors {404: Resource not found}
@example_request {"body":"Nice change"}

@endpoint DELETE /repos/{owner}/{repo}/comments/{comment_id}
@desc Delete a commit comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/comments/{comment_id}/reactions
@desc List reactions for a commit comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@optional {content: str(+1/-1/laugh/confused/heart/hooray/rocket/eyes) # Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a commit comment., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/comments/{comment_id}/reactions
@desc Create reaction for a commit comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment., content: str(+1/-1/laugh/confused/heart/hooray/rocket/eyes) # The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the commit comment.}
@returns(200) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Reaction exists
@returns(201) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Reaction created
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"content":"heart"}

@endpoint DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
@desc Delete a commit comment reaction
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment., reaction_id: int # The unique identifier of the reaction.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/commits
@desc List commits
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {sha: str # SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`)., path: str # Only commits containing this file path will be returned., author: str # GitHub username or email address to use to filter by commit author., committer: str # GitHub username or email address to use to filter by commit committer., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned., until: str(date-time) # Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {500: Internal Error, 400: Bad Request, 404: Resource not found, 409: Conflict}

@endpoint GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head
@desc List branches for HEAD commit
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., commit_sha: str # The SHA of the commit.}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed., 409: Conflict}

@endpoint GET /repos/{owner}/{repo}/commits/{commit_sha}/comments
@desc List commit comments
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., commit_sha: str # The SHA of the commit.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/commits/{commit_sha}/comments
@desc Create a commit comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., commit_sha: str # The SHA of the commit., body: str # The contents of the comment.}
@optional {path: str # Relative path of the file to comment on., position: int # Line index in the diff to comment on., line: int # **Closing down notice**. Use **position** parameter instead. Line number in the file to comment on.}
@returns(201) {html_url: str(uri), url: str(uri), id: int, node_id: str, body: str, path: str?, position: int?, line: int?, commit_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}} # Response
@errors {403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"body":"Great stuff","path":"file1.txt","position":4,"line":1}

@endpoint GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
@desc List pull requests associated with a commit
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., commit_sha: str # The SHA of the commit.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {409: Conflict}

@endpoint GET /repos/{owner}/{repo}/commits/{ref}
@desc Get a commit
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {url: str(uri), sha: str, node_id: str, html_url: str(uri), comments_url: str(uri), commit: map{url: str(uri), author: map?{name: str, email: str, date: str(date-time)}, committer: map?{name: str, email: str, date: str(date-time)}, message: str, comment_count: int, tree: map{sha: str, url: str(uri)}, verification: map{verified: bool, reason: str, payload: str?, signature: str?, verified_at: str?}}, author: any?, committer: any?, parents: [map], stats: map{additions: int, deletions: int, total: int}, files: [map]} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 500: Internal Error, 503: Service unavailable, 409: Conflict}

@endpoint GET /repos/{owner}/{repo}/commits/{ref}/check-runs
@desc List check runs for a Git reference
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.}
@optional {check_name: str # Returns check runs with the specified `name`., status: str(queued/in_progress/completed) # Returns check runs with the specified `status`., filter: str(latest/all)=latest # Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", app_id: int}
@returns(200) {total_count: int, check_runs: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/commits/{ref}/check-suites
@desc List check suites for a Git reference
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.}
@optional {app_id: int # Filters check suites by GitHub App `id`., check_name: str # Returns check runs with the specified `name`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, check_suites: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/commits/{ref}/status
@desc Get the combined status for a specific reference
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {state: str, statuses: [map], sha: str, total_count: int, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, commit_url: str(uri), url: str(uri)} # Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/commits/{ref}/statuses
@desc List commit statuses for a reference
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {301: Moved permanently}

@endpoint GET /repos/{owner}/{repo}/community/profile
@desc Get community profile metrics
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {health_percentage: int, description: str?, documentation: str?, files: map{code_of_conduct: map?{url: str(uri), key: str, name: str, html_url: str(uri)?}, code_of_conduct_file: map?{url: str(uri), html_url: str(uri)}, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, contributing: map?{url: str(uri), html_url: str(uri)}, readme: map?{url: str(uri), html_url: str(uri)}, issue_template: map?{url: str(uri), html_url: str(uri)}, pull_request_template: map?{url: str(uri), html_url: str(uri)}}, updated_at: str(date-time)?, content_reports_enabled: bool} # Response

@endpoint GET /repos/{owner}/{repo}/compare/{basehead}
@desc Compare two commits
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., basehead: str # The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {url: str(uri), html_url: str(uri), permalink_url: str(uri), diff_url: str(uri), patch_url: str(uri), base_commit: map{url: str(uri), sha: str, node_id: str, html_url: str(uri), comments_url: str(uri), commit: map{url: str(uri), author: map?, committer: map?, message: str, comment_count: int, tree: map, verification: map}, author: any?, committer: any?, parents: [map], stats: map{additions: int, deletions: int, total: int}, files: [map]}, merge_base_commit: map{url: str(uri), sha: str, node_id: str, html_url: str(uri), comments_url: str(uri), commit: map{url: str(uri), author: map?, committer: map?, message: str, comment_count: int, tree: map, verification: map}, author: any?, committer: any?, parents: [map], stats: map{additions: int, deletions: int, total: int}, files: [map]}, status: str, ahead_by: int, behind_by: int, total_commits: int, commits: [map], files: [map]} # Response
@errors {404: Resource not found, 500: Internal Error, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/contents/{path}
@desc Get repository content
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., path: str # path parameter}
@optional {ref: str # The name of the commit/branch/tag. Default: the repositorys default branch.}
@returns(200) Response
@errors {404: Resource not found, 403: Forbidden, 302: Found, 304: Not modified}

@endpoint PUT /repos/{owner}/{repo}/contents/{path}
@desc Create or update file contents
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., path: str # path parameter, message: str # The commit message., content: str # The new file content, using Base64 encoding.}
@optional {sha: str # **Required if you are updating a file**. The blob SHA of the file being replaced., branch: str # The branch name. Default: the repositorys default branch., committer: map{name!: str, email!: str, date: str} # The person that committed the file. Default: the authenticated user., author: map{name!: str, email!: str, date: str} # The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.}
@returns(200) {content: map?{name: str, path: str, sha: str, size: int, url: str, html_url: str, git_url: str, download_url: str, type: str, _links: map{self: str, git: str, html: str}}, commit: map{sha: str, node_id: str, url: str, html_url: str, author: map{date: str, name: str, email: str}, committer: map{date: str, name: str, email: str}, message: str, tree: map{url: str, sha: str}, parents: [map], verification: map{verified: bool, reason: str, signature: str?, payload: str?, verified_at: str?}}} # Response
@returns(201) {content: map?{name: str, path: str, sha: str, size: int, url: str, html_url: str, git_url: str, download_url: str, type: str, _links: map{self: str, git: str, html: str}}, commit: map{sha: str, node_id: str, url: str, html_url: str, author: map{date: str, name: str, email: str}, committer: map{date: str, name: str, email: str}, message: str, tree: map{url: str, sha: str}, parents: [map], verification: map{verified: bool, reason: str, signature: str?, payload: str?, verified_at: str?}}} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 409: Conflict}
@example_request {"message":"my commit message","committer":{"name":"Monalisa Octocat","email":"octocat@github.com"},"content":"bXkgbmV3IGZpbGUgY29udGVudHM="}

@endpoint DELETE /repos/{owner}/{repo}/contents/{path}
@desc Delete a file
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., path: str # path parameter, message: str # The commit message., sha: str # The blob SHA of the file being deleted.}
@optional {branch: str # The branch name. Default: the repositorys default branch, committer: map{name: str, email: str} # object containing information about the committer., author: map{name: str, email: str} # object containing information about the author.}
@returns(200) {content: map?{name: str, path: str, sha: str, size: int, url: str, html_url: str, git_url: str, download_url: str, type: str, _links: map{self: str, git: str, html: str}}, commit: map{sha: str, node_id: str, url: str, html_url: str, author: map{date: str, name: str, email: str}, committer: map{date: str, name: str, email: str}, message: str, tree: map{url: str, sha: str}, parents: [map], verification: map{verified: bool, reason: str, signature: str?, payload: str?, verified_at: str?}}} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 409: Conflict, 503: Service unavailable}
@example_request {"message":"my commit message","committer":{"name":"Monalisa Octocat","email":"octocat@github.com"},"sha":"329688480d39049927147c162b9d2deaf885005f"}

@endpoint GET /repos/{owner}/{repo}/contributors
@desc List repository contributors
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {anon: str # Set to `1` or `true` to include anonymous contributors in results., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) If repository contains content
@returns(204) Response if repository is empty
@errors {403: Forbidden, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/dependabot/alerts
@desc List Dependabot alerts for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {state: str # A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`, severity: str # A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`, ecosystem: str # A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`, package: str # A comma-separated list of package names. If specified, only alerts for these packages will be returned., manifest: str # A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned., epss_percentage: str # CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as: - An exact number (`n`) - Comparators such as `>n`, `<n`, `>=n`, `<=n` - A range like `n..n`, where `n` is a number from 0.0 to 1.0  Filters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned., has: any # Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned. Multiple `has` filters can be passed to filter for alerts that have all of the values. Currently, only `patch` is supported., scope: str(development/runtime) # The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned., sort: str(created/updated/epss_percentage)=created # The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed. `epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage., direction: str(asc/desc)=desc # The direction to sort the results by., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 400: Bad Request, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}
@desc Get a Dependabot alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies a Dependabot alert in its repository. You can find this at the end of the URL for a Dependabot alert within GitHub, or in `number` fields in the response from the `GET /repos/{owner}/{repo}/dependabot/alerts` operation.}
@returns(200) {number: int, state: str, dependency: map{package: map{ecosystem: str, name: str}, manifest_path: str, scope: str?, relationship: str?}, security_advisory: map{ghsa_id: str, cve_id: str?, summary: str, description: str, vulnerabilities: [map], severity: str, cvss: map{score: num, vector_string: str?}, cvss_severities: map?{cvss_v3: map?, cvss_v4: map?}, epss: map?{percentage: num, percentile: num}, cwes: [map], identifiers: [map], references: [map], published_at: str(date-time), updated_at: str(date-time), withdrawn_at: str(date-time)?}, security_vulnerability: map{package: map{ecosystem: str, name: str}, severity: str, vulnerable_version_range: str, first_patched_version: map?{identifier: str}}, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), dismissed_at: str(date-time)?, dismissed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, dismissed_reason: str?, dismissed_comment: str?, fixed_at: str(date-time)?, auto_dismissed_at: str(date-time)?, dismissal_request: map?{id: int, status: str, requester: map{id: int, login: str}, created_at: str(date-time), url: str(uri)}} # Response
@errors {304: Not modified, 403: Forbidden, 404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}
@desc Update a Dependabot alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies a Dependabot alert in its repository. You can find this at the end of the URL for a Dependabot alert within GitHub, or in `number` fields in the response from the `GET /repos/{owner}/{repo}/dependabot/alerts` operation., state: str(dismissed/open) # The state of the Dependabot alert. A `dismissed_reason` must be provided when setting the state to `dismissed`.}
@optional {dismissed_reason: str(fix_started/inaccurate/no_bandwidth/not_used/tolerable_risk) # **Required when `state` is `dismissed`.** A reason for dismissing the alert., dismissed_comment: str # An optional comment associated with dismissing the alert.}
@returns(200) {number: int, state: str, dependency: map{package: map{ecosystem: str, name: str}, manifest_path: str, scope: str?, relationship: str?}, security_advisory: map{ghsa_id: str, cve_id: str?, summary: str, description: str, vulnerabilities: [map], severity: str, cvss: map{score: num, vector_string: str?}, cvss_severities: map?{cvss_v3: map?, cvss_v4: map?}, epss: map?{percentage: num, percentile: num}, cwes: [map], identifiers: [map], references: [map], published_at: str(date-time), updated_at: str(date-time), withdrawn_at: str(date-time)?}, security_vulnerability: map{package: map{ecosystem: str, name: str}, severity: str, vulnerable_version_range: str, first_patched_version: map?{identifier: str}}, url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), dismissed_at: str(date-time)?, dismissed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, dismissed_reason: str?, dismissed_comment: str?, fixed_at: str(date-time)?, auto_dismissed_at: str(date-time)?, dismissal_request: map?{id: int, status: str, requester: map{id: int, login: str}, created_at: str(date-time), url: str(uri)}} # Response
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found, 409: Conflict, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"state":"dismissed","dismissed_reason":"tolerable_risk","dismissed_comment":"This alert is accurate but we use a sanitizer."}

@endpoint GET /repos/{owner}/{repo}/dependabot/secrets
@desc List repository secrets
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, secrets: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/dependabot/secrets/public-key
@desc Get a repository public key
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {key_id: str, key: str} # Response

@endpoint GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}
@desc Get a repository secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(200) {name: str, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}
@desc Create or update a repository secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., secret_name: str # The name of the secret.}
@optional {encrypted_value: str # Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key) endpoint., key_id: str # ID of the key you used to encrypt the secret.}
@returns(201) Response when creating a secret
@returns(204) Response when updating a secret
@example_request {"encrypted_value":"c2VjcmV0","key_id":"012345678912345678"}

@endpoint DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}
@desc Delete a repository secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., secret_name: str # The name of the secret.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}
@desc Get a diff of the dependencies between commits
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., basehead: str # The base and head Git revisions to compare. The Git revisions will be resolved to commit SHAs. Named revisions will be resolved to their corresponding HEAD commits, and an appropriate merge base will be determined. This parameter expects the format `{base}...{head}`.}
@optional {name: str # The full path, relative to the repository root, of the dependency manifest file.}
@returns(200) Response
@errors {404: Resource not found, 403: Response for a private repository when GitHub Advanced Security is not enabled, or if used against a fork}

@endpoint GET /repos/{owner}/{repo}/dependency-graph/sbom
@desc Export a software bill of materials (SBOM) for a repository.
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {sbom: map{SPDXID: str, spdxVersion: str, comment: str, creationInfo: map{created: str, creators: [str]}, name: str, dataLicense: str, documentNamespace: str, packages: [map], relationships: [map]}} # Response
@errors {404: Resource not found, 403: Forbidden}

@endpoint POST /repos/{owner}/{repo}/dependency-graph/snapshots
@desc Create a snapshot of dependencies for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., version: int # The version of the repository snapshot submission., job: map{id!: str, correlator!: str, html_url: str}, sha: str # The commit SHA associated with this dependency snapshot. Maximum length: 40 characters., ref: str # The repository branch that triggered this snapshot., detector: map{name!: str, version!: str, url!: str} # A description of the detector used., scanned: str(date-time) # The time at which the snapshot was scanned.}
@optional {metadata: map # User-defined metadata to store domain-specific information limited to 8 keys with scalar values., manifests: map # A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.}
@returns(201) {id: int, created_at: str, result: str, message: str} # Response
@example_request {"version":0,"sha":"ce587453ced02b1526dfb4cb910479d431683101","ref":"refs/heads/main","job":{"correlator":"yourworkflowname_youractionname","id":"yourrunid"},"detector":{"name":"octo-detector","version":"0.0.1","url":"https://github.com/octo-org/octo-repo"},"scanned":"2022-06-14T20:25:00Z","manifests":{"package-lock.json":{"name":"package-lock.json","file":{"source_location":"src/package-lock.json"},"resolved":{"@actions/core":{"package_url":"pkg:/npm/%40actions/core@1.1.9","dependencies":["@actions/http-client"]},"@actions/http-client":{"package_url":"pkg:/npm/%40actions/http-client@1.0.7","dependencies":["tunnel"]},"tunnel":{"package_url":"pkg:/npm/tunnel@0.0.6"}}}}}

@endpoint GET /repos/{owner}/{repo}/deployments
@desc List deployments
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {sha: str=none # The SHA recorded at creation time., ref: str=none # The name of the ref. This can be a branch, tag, or SHA., task: str=none # The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`)., environment: str=none # The name of the environment that was deployed to (e.g., `staging` or `production`)., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/deployments
@desc Create a deployment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The ref to deploy. This can be a branch, tag, or SHA.}
@optional {task: str=deploy # Specifies a task to execute (e.g., `deploy` or `deploy:migrations`)., auto_merge: bool=True # Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch., required_contexts: [str] # The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts., payload: any, environment: str=production # Name for the target deployment environment (e.g., `production`, `staging`, `qa`)., description: str= # Short description of the deployment., transient_environment: bool=False # Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`, production_environment: bool # Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.}
@returns(201) {url: str(uri), id: int(int64), node_id: str, sha: str, ref: str, task: str, payload: any, original_environment: str, environment: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), statuses_url: str(uri), repository_url: str(uri), transient_environment: bool, production_environment: bool, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}} # Response
@returns(202) {message: str} # Merged branch response
@errors {409: Conflict when there is a merge conflict or the commit's status checks failed, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"ref":"topic-branch","payload":"{ \"deploy\": \"migrate\" }","description":"Deploy request from hubot"}

@endpoint GET /repos/{owner}/{repo}/deployments/{deployment_id}
@desc Get a deployment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., deployment_id: int # deployment_id parameter}
@returns(200) {url: str(uri), id: int(int64), node_id: str, sha: str, ref: str, task: str, payload: any, original_environment: str, environment: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), statuses_url: str(uri), repository_url: str(uri), transient_environment: bool, production_environment: bool, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}} # Response
@errors {404: Resource not found}

@endpoint DELETE /repos/{owner}/{repo}/deployments/{deployment_id}
@desc Delete a deployment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., deployment_id: int # deployment_id parameter}
@returns(204) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
@desc List deployment statuses
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., deployment_id: int # deployment_id parameter}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
@desc Create a deployment status
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., deployment_id: int # deployment_id parameter, state: str(error/failure/inactive/in_progress/queued/pending/success) # The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.}
@optional {target_url: str= # The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment.  > [!NOTE] > It's recommended to use the `log_url` parameter, which replaces `target_url`., log_url: str= # The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`, description: str= # A short description of the status. The maximum description length is 140 characters., environment: str # Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used., environment_url: str= # Sets the URL for accessing your environment. Default: `""`, auto_inactive: bool # Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`}
@returns(201) {url: str(uri), id: int(int64), node_id: str, state: str, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, description: str, environment: str, target_url: str(uri), created_at: str(date-time), updated_at: str(date-time), deployment_url: str(uri), repository_url: str(uri), environment_url: str(uri), log_url: str(uri), performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"environment":"production","state":"success","log_url":"https://example.com/deployment/42/output","description":"Deployment finished successfully."}

@endpoint GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
@desc Get a deployment status
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., deployment_id: int # deployment_id parameter, status_id: int}
@returns(200) {url: str(uri), id: int(int64), node_id: str, state: str, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, description: str, environment: str, target_url: str(uri), created_at: str(date-time), updated_at: str(date-time), deployment_url: str(uri), repository_url: str(uri), environment_url: str(uri), log_url: str(uri), performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}} # Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/dispatches
@desc Create a repository dispatch event
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., event_type: str # A custom webhook event name. Must be 100 characters or fewer.}
@optional {client_payload: map # JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB.}
@returns(204) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"event_type":"on-demand-test","client_payload":{"unit":false,"integration":true}}

@endpoint GET /repos/{owner}/{repo}/environments
@desc List environments
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, environments: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}
@desc Get an environment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.}
@returns(200) {id: int(int64), node_id: str, name: str, url: str, html_url: str, created_at: str(date-time), updated_at: str(date-time), protection_rules: [any], deployment_branch_policy: map?{protected_branches: bool, custom_branch_policies: bool}} # Response

@endpoint PUT /repos/{owner}/{repo}/environments/{environment_name}
@desc Create or update an environment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.}
@optional {wait_timer: int # The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days)., prevent_self_review: bool # Whether or not a user who created the job is prevented from approving their own job., reviewers: [map{type: str, id: int}] # The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed., deployment_branch_policy: map{protected_branches!: bool, custom_branch_policies!: bool} # The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.}
@returns(200) {id: int(int64), node_id: str, name: str, url: str, html_url: str, created_at: str(date-time), updated_at: str(date-time), protection_rules: [any], deployment_branch_policy: map?{protected_branches: bool, custom_branch_policies: bool}} # Response
@errors {422: Validation error when the environment name is invalid or when `protected_branches` and `custom_branch_policies` in `deployment_branch_policy` are set to the same value}
@example_request {"wait_timer":30,"prevent_self_review":false,"reviewers":[{"type":"User","id":1},{"type":"Team","id":1}],"deployment_branch_policy":{"protected_branches":false,"custom_branch_policies":true}}

@endpoint DELETE /repos/{owner}/{repo}/environments/{environment_name}
@desc Delete an environment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.}
@returns(204) Default response

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies
@desc List deployment branch policies
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, branch_policies: [map]} # Response

@endpoint POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies
@desc Create a deployment branch policy
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., name: str # The name pattern that branches or tags must match in order to deploy to the environment.  Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`. For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).}
@optional {type: str(branch/tag) # Whether this rule targets a branch or tag}
@returns(200) {id: int, node_id: str, name: str, type: str} # Response
@errors {404: Not Found or `deployment_branch_policy.custom_branch_policies` property for the environment is set to false, 303: Response if the same branch name pattern already exists}
@example_request {"name":"release/*"}

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}
@desc Get a deployment branch policy
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., branch_policy_id: int # The unique identifier of the branch policy.}
@returns(200) {id: int, node_id: str, name: str, type: str} # Response

@endpoint PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}
@desc Update a deployment branch policy
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., branch_policy_id: int # The unique identifier of the branch policy., name: str # The name pattern that branches must match in order to deploy to the environment.  Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`. For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).}
@returns(200) {id: int, node_id: str, name: str, type: str} # Response
@example_request {"name":"release/*"}

@endpoint DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}
@desc Delete a deployment branch policy
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., branch_policy_id: int # The unique identifier of the branch policy.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules
@desc Get all deployment protection rules for an environment
@required {environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., owner: str # The account owner of the repository. The name is not case sensitive.}
@returns(200) {total_count: int, custom_deployment_protection_rules: [map]} # List of deployment protection rules

@endpoint POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules
@desc Create a custom deployment protection rule on an environment
@required {environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., owner: str # The account owner of the repository. The name is not case sensitive.}
@optional {integration_id: int # The ID of the custom app that will be enabled on the environment.}
@returns(201) {id: int, node_id: str, enabled: bool, app: map{id: int, slug: str, integration_url: str, node_id: str}} # The enabled custom deployment protection rule
@example_request {"integration_id":5}

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps
@desc List custom deployment rule integrations available for an environment
@required {environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., owner: str # The account owner of the repository. The name is not case sensitive.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, available_custom_deployment_protection_rule_integrations: [map]} # A list of custom deployment rule integrations available for this environment.

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}
@desc Get a custom deployment protection rule
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., protection_rule_id: int # The unique identifier of the protection rule.}
@returns(200) {id: int, node_id: str, enabled: bool, app: map{id: int, slug: str, integration_url: str, node_id: str}} # Response

@endpoint DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}
@desc Disable a custom protection rule for an environment
@required {environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., owner: str # The account owner of the repository. The name is not case sensitive., protection_rule_id: int # The unique identifier of the protection rule.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/secrets
@desc List environment secrets
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, secrets: [map]} # Response

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key
@desc Get an environment public key
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.}
@returns(200) {key_id: str, key: str, id: int, url: str, title: str, created_at: str} # Response

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}
@desc Get an environment secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., secret_name: str # The name of the secret.}
@returns(200) {name: str, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}
@desc Create or update an environment secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., secret_name: str # The name of the secret., encrypted_value: str # Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/actions/secrets#get-an-environment-public-key) endpoint., key_id: str # ID of the key you used to encrypt the secret.}
@returns(201) Response when creating a secret
@returns(204) Response when updating a secret
@example_request {"encrypted_value":"c2VjcmV0","key_id":"012345678912345678"}

@endpoint DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}
@desc Delete an environment secret
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., secret_name: str # The name of the secret.}
@returns(204) Default response

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/variables
@desc List environment variables
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.}
@optional {per_page: int=10 # The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, variables: [map]} # Response

@endpoint POST /repos/{owner}/{repo}/environments/{environment_name}/variables
@desc Create an environment variable
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., name: str # The name of the variable., value: str # The value of the variable.}
@returns(201) Response
@example_request {"name":"USERNAME","value":"octocat"}

@endpoint GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}
@desc Get an environment variable
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`., name: str # The name of the variable.}
@returns(200) {name: str, value: str, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}
@desc Update an environment variable
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the variable., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.}
@optional {name: str # The name of the variable., value: str # The value of the variable.}
@returns(204) Response
@example_request {"name":"USERNAME","value":"octocat"}

@endpoint DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}
@desc Delete an environment variable
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the variable., environment_name: str # The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/events
@desc List repository events
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /repos/{owner}/{repo}/forks
@desc List forks
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {sort: str(newest/oldest/stargazers/watchers)=newest # The sort order. `stargazers` will sort by star count., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {400: Bad Request}

@endpoint POST /repos/{owner}/{repo}/forks
@desc Create a fork
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {organization: str # Optional parameter to specify the organization name if forking into an organization., name: str # When forking from an existing repository, a new name for the fork., default_branch_only: bool # When forking from an existing repository, fork with only the default branch.}
@returns(202) {id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time), created_at: str(date-time), updated_at: str(date-time), permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, allow_rebase_merge: bool, template_repository: map?{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, temp_clone_token: str?, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, organization: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, parent: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, source: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, forks: int, master_branch: str, open_issues: int, watchers: int, anonymous_access_enabled: bool, code_of_conduct: map{url: str(uri), key: str, name: str, html_url: str(uri)?}, security_and_analysis: map?{advanced_security: map{status: str}, code_security: map{status: str}, dependabot_security_updates: map{status: str}, secret_scanning: map{status: str}, secret_scanning_push_protection: map{status: str}, secret_scanning_non_provider_patterns: map{status: str}, secret_scanning_ai_detection: map{status: str}, secret_scanning_delegated_alert_dismissal: map{status: str}}, custom_properties: map} # Response
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed., 403: Forbidden, 404: Resource not found}
@example_request {"organization":"octocat","name":"Hello-World","default_branch_only":true}

@endpoint POST /repos/{owner}/{repo}/git/blobs
@desc Create a blob
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., content: str # The new blob's content.}
@optional {encoding: str=utf-8 # The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.}
@returns(201) {url: str, sha: str} # Response
@errors {404: Resource not found, 409: Conflict, 403: Forbidden, 422: Validation failed}
@example_request {"content":"Content of the blob","encoding":"utf-8"}

@endpoint GET /repos/{owner}/{repo}/git/blobs/{file_sha}
@desc Get a blob
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., file_sha: str}
@returns(200) {content: str, encoding: str, url: str(uri), sha: str, size: int?, node_id: str, highlighted_content: str} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 403: Forbidden, 409: Conflict}

@endpoint POST /repos/{owner}/{repo}/git/commits
@desc Create a commit
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., message: str # The commit message, tree: str # The SHA of the tree object this commit points to}
@optional {parents: [str] # The full SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided., author: map{name!: str, email!: str, date: str(date-time)} # Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details., committer: map{name: str, email: str, date: str(date-time)} # Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details., signature: str # The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits.}
@returns(201) {sha: str, node_id: str, url: str(uri), author: map{date: str(date-time), email: str, name: str}, committer: map{date: str(date-time), email: str, name: str}, message: str, tree: map{sha: str, url: str(uri)}, parents: [map], verification: map{verified: bool, reason: str, signature: str?, payload: str?, verified_at: str?}, html_url: str(uri)} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 409: Conflict}
@example_request {"message":"my commit message","author":{"name":"Mona Octocat","email":"octocat@github.com","date":"2008-07-09T16:13:30+12:00"},"parents":["7d1b31e74ee336d15cbd21741bc88a537ed063a0"],"tree":"827efc6d56897b048c772eb4087f854f46256132","signature":"-----BEGIN PGP SIGNATURE-----\n\niQIzBAABAQAdFiEESn/54jMNIrGSE6Tp6cQjvhfv7nAFAlnT71cACgkQ6cQjvhfv\n7nCWwA//XVqBKWO0zF+bZl6pggvky3Oc2j1pNFuRWZ29LXpNuD5WUGXGG209B0hI\nDkmcGk19ZKUTnEUJV2Xd0R7AW01S/YSub7OYcgBkI7qUE13FVHN5ln1KvH2all2n\n2+JCV1HcJLEoTjqIFZSSu/sMdhkLQ9/NsmMAzpf/iIM0nQOyU4YRex9eD1bYj6nA\nOQPIDdAuaTQj1gFPHYLzM4zJnCqGdRlg0sOM/zC5apBNzIwlgREatOYQSCfCKV7k\nnrU34X8b9BzQaUx48Qa+Dmfn5KQ8dl27RNeWAqlkuWyv3pUauH9UeYW+KyuJeMkU\n+NyHgAsWFaCFl23kCHThbLStMZOYEnGagrd0hnm1TPS4GJkV4wfYMwnI4KuSlHKB\njHl3Js9vNzEUQipQJbgCgTiWvRJoK3ENwBTMVkKHaqT4x9U4Jk/XZB6Q8MA09ezJ\n3QgiTjTAGcum9E9QiJqMYdWQPWkaBIRRz5cET6HPB48YNXAAUsfmuYsGrnVLYbG+\nUpC6I97VybYHTy2O9XSGoaLeMI9CsFn38ycAxxbWagk5mhclNTP5mezIq6wKSwmr\nX11FW3n1J23fWZn5HJMBsRnUCgzqzX3871IqLYHqRJ/bpZ4h20RhTyPj5c/z7QXp\neSakNQMfbbMcljkha+ZMuVQX1K9aRlVqbmv3ZMWh+OijLYVU2bc=\n=5Io4\n-----END PGP SIGNATURE-----\n"}

@endpoint GET /repos/{owner}/{repo}/git/commits/{commit_sha}
@desc Get a commit object
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., commit_sha: str # The SHA of the commit.}
@returns(200) {sha: str, node_id: str, url: str(uri), author: map{date: str(date-time), email: str, name: str}, committer: map{date: str(date-time), email: str, name: str}, message: str, tree: map{sha: str, url: str(uri)}, parents: [map], verification: map{verified: bool, reason: str, signature: str?, payload: str?, verified_at: str?}, html_url: str(uri)} # Response
@errors {404: Resource not found, 409: Conflict}

@endpoint GET /repos/{owner}/{repo}/git/matching-refs/{ref}
@desc List matching references
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.}
@returns(200) Response
@errors {409: Conflict}

@endpoint GET /repos/{owner}/{repo}/git/ref/{ref}
@desc Get a reference
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.}
@returns(200) {ref: str, node_id: str, url: str(uri), object: map{type: str, sha: str, url: str(uri)}} # Response
@errors {404: Resource not found, 409: Conflict}

@endpoint POST /repos/{owner}/{repo}/git/refs
@desc Create a reference
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected., sha: str # The SHA1 value for this reference.}
@returns(201) {ref: str, node_id: str, url: str(uri), object: map{type: str, sha: str, url: str(uri)}} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 409: Conflict}
@example_request {"ref":"refs/heads/featureA","sha":"aa218f56b14c9653891f9e74264a383fa43fefbd"}

@endpoint PATCH /repos/{owner}/{repo}/git/refs/{ref}
@desc Update a reference
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation., sha: str # The SHA1 value to set this reference to}
@optional {force: bool=False # Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work.}
@returns(200) {ref: str, node_id: str, url: str(uri), object: map{type: str, sha: str, url: str(uri)}} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 409: Conflict}
@example_request {"sha":"aa218f56b14c9653891f9e74264a383fa43fefbd","force":true}

@endpoint DELETE /repos/{owner}/{repo}/git/refs/{ref}
@desc Delete a reference
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str # The Git reference. For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.}
@returns(204) Response
@errors {422: Validation failed, an attempt was made to delete the default branch, or the endpoint has been spammed., 409: Conflict}

@endpoint POST /repos/{owner}/{repo}/git/tags
@desc Create a tag object
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., tag: str # The tag's name. This is typically a version (e.g., "v0.0.1")., message: str # The tag message., object: str # The SHA of the git object this is tagging., type: str(commit/tree/blob) # The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.}
@optional {tagger: map{name!: str, email!: str, date: str(date-time)} # An object with information about the individual creating the tag.}
@returns(201) {node_id: str, tag: str, sha: str, url: str(uri), message: str, tagger: map{date: str, email: str, name: str}, object: map{sha: str, type: str, url: str(uri)}, verification: map{verified: bool, reason: str, payload: str?, signature: str?, verified_at: str?}} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 409: Conflict}
@example_request {"tag":"v0.0.1","message":"initial version","object":"c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c","type":"commit","tagger":{"name":"Monalisa Octocat","email":"octocat@github.com","date":"2011-06-17T14:53:35-07:00"}}

@endpoint GET /repos/{owner}/{repo}/git/tags/{tag_sha}
@desc Get a tag
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., tag_sha: str}
@returns(200) {node_id: str, tag: str, sha: str, url: str(uri), message: str, tagger: map{date: str, email: str, name: str}, object: map{sha: str, type: str, url: str(uri)}, verification: map{verified: bool, reason: str, payload: str?, signature: str?, verified_at: str?}} # Response
@errors {404: Resource not found, 409: Conflict}

@endpoint POST /repos/{owner}/{repo}/git/trees
@desc Create a tree
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., tree: [map{path: str, mode: str, type: str, sha: str, content: str}] # Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.}
@optional {base_tree: str # The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on. If not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit.}
@returns(201) {sha: str, url: str(uri), truncated: bool, tree: [map]} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 403: Forbidden, 409: Conflict}
@example_request {"base_tree":"9fb037999f264ba9a7fc6274d15fa3ae2ab98312","tree":[{"path":"file.rb","mode":"100644","type":"blob","sha":"44b4fc6d56897b048c772eb4087f854f46256132"}]}

@endpoint GET /repos/{owner}/{repo}/git/trees/{tree_sha}
@desc Get a tree
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., tree_sha: str # The SHA1 value or ref (branch or tag) name of the tree.}
@optional {recursive: str # Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable returning objects or subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent recursively returning objects or subtrees.}
@returns(200) {sha: str, url: str(uri), truncated: bool, tree: [map]} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 409: Conflict}

@endpoint GET /repos/{owner}/{repo}/hooks
@desc List repository webhooks
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/hooks
@desc Create a repository webhook
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {name: str # Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`., config: map{url: str(uri), content_type: str, secret: str, insecure_ssl: any} # Key/value pairs to provide settings for this webhook., events: [str]=['push'] # Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for., active: bool=True # Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.}
@returns(201) {type: str, id: int, name: str, active: bool, events: [str], config: map{url: str(uri), content_type: str, secret: str, insecure_ssl: any}, updated_at: str(date-time), created_at: str(date-time), url: str(uri), test_url: str(uri), ping_url: str(uri), deliveries_url: str(uri), last_response: map{code: int?, status: str?, message: str?}} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"name":"web","active":true,"events":["push","pull_request"],"config":{"url":"https://example.com/webhook","content_type":"json","insecure_ssl":"0"}}

@endpoint GET /repos/{owner}/{repo}/hooks/{hook_id}
@desc Get a repository webhook
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@returns(200) {type: str, id: int, name: str, active: bool, events: [str], config: map{url: str(uri), content_type: str, secret: str, insecure_ssl: any}, updated_at: str(date-time), created_at: str(date-time), url: str(uri), test_url: str(uri), ping_url: str(uri), deliveries_url: str(uri), last_response: map{code: int?, status: str?, message: str?}} # Response
@errors {404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/hooks/{hook_id}
@desc Update a repository webhook
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@optional {config: map{url: str(uri), content_type: str, secret: str, insecure_ssl: any} # Configuration object of the webhook, events: [str]=['push'] # Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events., add_events: [str] # Determines a list of events to be added to the list of events that the Hook triggers for., remove_events: [str] # Determines a list of events to be removed from the list of events that the Hook triggers for., active: bool=True # Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.}
@returns(200) {type: str, id: int, name: str, active: bool, events: [str], config: map{url: str(uri), content_type: str, secret: str, insecure_ssl: any}, updated_at: str(date-time), created_at: str(date-time), url: str(uri), test_url: str(uri), ping_url: str(uri), deliveries_url: str(uri), last_response: map{code: int?, status: str?, message: str?}} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"active":true,"add_events":["pull_request"]}

@endpoint DELETE /repos/{owner}/{repo}/hooks/{hook_id}
@desc Delete a repository webhook
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/hooks/{hook_id}/config
@desc Get a webhook configuration for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@returns(200) {url: str(uri), content_type: str, secret: str, insecure_ssl: any} # Response

@endpoint PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config
@desc Update a webhook configuration for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@optional {url: str(uri) # The URL to which the payloads will be delivered., content_type: str # The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`., secret: str # If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers)., insecure_ssl: any}
@returns(200) {url: str(uri), content_type: str, secret: str, insecure_ssl: any} # Response
@example_request {"content_type":"json","url":"https://example.com/webhook"}

@endpoint GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries
@desc List deliveries for a repository webhook
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", cursor: str # Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.}
@returns(200) Response
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}
@desc Get a delivery for a repository webhook
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery., delivery_id: int}
@returns(200) {id: int, guid: str, delivered_at: str(date-time), redelivery: bool, duration: num, status: str, status_code: int, event: str, action: str?, installation_id: int?, repository_id: int?, throttled_at: str(date-time)?, url: str, request: map{headers: map?, payload: map?}, response: map{headers: map?, payload: str?}} # Response
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}

@endpoint POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
@desc Redeliver a delivery for a repository webhook
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery., delivery_id: int}
@returns(202) Accepted
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed.}

@endpoint POST /repos/{owner}/{repo}/hooks/{hook_id}/pings
@desc Ping a repository webhook
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/hooks/{hook_id}/tests
@desc Test the push repository webhook
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., hook_id: int # The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/immutable-releases
@desc Check if immutable releases are enabled for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {enabled: bool, enforced_by_owner: bool} # Response if immutable releases are enabled
@errors {404: Not Found if immutable releases are not enabled for the repository}

@endpoint PUT /repos/{owner}/{repo}/immutable-releases
@desc Enable immutable releases
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) A header with no content is returned.
@errors {409: Conflict}

@endpoint DELETE /repos/{owner}/{repo}/immutable-releases
@desc Disable immutable releases
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) A header with no content is returned.
@errors {409: Conflict}

@endpoint GET /repos/{owner}/{repo}/import
@desc Get an import status
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {vcs: str?, use_lfs: bool, vcs_url: str, svc_root: str, tfvc_project: str, status: str, status_text: str?, failed_step: str?, error_message: str?, import_percent: int?, commit_count: int?, push_percent: int?, has_large_files: bool, large_files_size: int, large_files_count: int, project_choices: [map], message: str, authors_count: int?, url: str(uri), html_url: str(uri), authors_url: str(uri), repository_url: str(uri), svn_root: str} # Response
@errors {404: Resource not found, 503: Unavailable due to service under maintenance.}

@endpoint PUT /repos/{owner}/{repo}/import
@desc Start an import
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., vcs_url: str # The URL of the originating repository.}
@optional {vcs: str(subversion/git/mercurial/tfvc) # The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response., vcs_username: str # If authentication is required, the username to provide to `vcs_url`., vcs_password: str # If authentication is required, the password to provide to `vcs_url`., tfvc_project: str # For a tfvc import, the name of the project that is being imported.}
@returns(201) {vcs: str?, use_lfs: bool, vcs_url: str, svc_root: str, tfvc_project: str, status: str, status_text: str?, failed_step: str?, error_message: str?, import_percent: int?, commit_count: int?, push_percent: int?, has_large_files: bool, large_files_size: int, large_files_count: int, project_choices: [map], message: str, authors_count: int?, url: str(uri), html_url: str(uri), authors_url: str(uri), repository_url: str(uri), svn_root: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 503: Unavailable due to service under maintenance.}
@example_request {"vcs":"subversion","vcs_url":"http://svn.mycompany.com/svn/myproject","vcs_username":"octocat","vcs_password":"secret"}

@endpoint PATCH /repos/{owner}/{repo}/import
@desc Update an import
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {vcs_username: str # The username to provide to the originating repository., vcs_password: str # The password to provide to the originating repository., vcs: str(subversion/tfvc/git/mercurial) # The type of version control system you are migrating from., tfvc_project: str # For a tfvc import, the name of the project that is being imported.}
@returns(200) {vcs: str?, use_lfs: bool, vcs_url: str, svc_root: str, tfvc_project: str, status: str, status_text: str?, failed_step: str?, error_message: str?, import_percent: int?, commit_count: int?, push_percent: int?, has_large_files: bool, large_files_size: int, large_files_count: int, project_choices: [map], message: str, authors_count: int?, url: str(uri), html_url: str(uri), authors_url: str(uri), repository_url: str(uri), svn_root: str} # Response
@errors {503: Unavailable due to service under maintenance.}
@example_request {"vcs_username":"octocat","vcs_password":"secret"}

@endpoint DELETE /repos/{owner}/{repo}/import
@desc Cancel an import
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response
@errors {503: Unavailable due to service under maintenance.}

@endpoint GET /repos/{owner}/{repo}/import/authors
@desc Get commit authors
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {since: int # A user ID. Only return users with an ID greater than this ID.}
@returns(200) Response
@errors {404: Resource not found, 503: Unavailable due to service under maintenance.}

@endpoint PATCH /repos/{owner}/{repo}/import/authors/{author_id}
@desc Map a commit author
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., author_id: int}
@optional {email: str # The new Git author email., name: str # The new Git author name.}
@returns(200) {id: int, remote_id: str, remote_name: str, email: str, name: str, url: str(uri), import_url: str(uri)} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 503: Unavailable due to service under maintenance.}
@example_request {"email":"hubot@github.com","name":"Hubot the Robot"}

@endpoint GET /repos/{owner}/{repo}/import/large_files
@desc Get large files
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response
@errors {503: Unavailable due to service under maintenance.}

@endpoint PATCH /repos/{owner}/{repo}/import/lfs
@desc Update Git LFS preference
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., use_lfs: str(opt_in/opt_out) # Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.}
@returns(200) {vcs: str?, use_lfs: bool, vcs_url: str, svc_root: str, tfvc_project: str, status: str, status_text: str?, failed_step: str?, error_message: str?, import_percent: int?, commit_count: int?, push_percent: int?, has_large_files: bool, large_files_size: int, large_files_count: int, project_choices: [map], message: str, authors_count: int?, url: str(uri), html_url: str(uri), authors_url: str(uri), repository_url: str(uri), svn_root: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 503: Unavailable due to service under maintenance.}
@example_request {"use_lfs":"opt_in"}

@endpoint GET /repos/{owner}/{repo}/installation
@desc Get a repository installation for the authenticated app
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {id: int, account: any?, repository_selection: str, access_tokens_url: str(uri), repositories_url: str(uri), html_url: str(uri), app_id: int, client_id: str, target_id: int, target_type: str, permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str}, events: [str], created_at: str(date-time), updated_at: str(date-time), single_file_name: str?, has_multiple_single_files: bool, single_file_paths: [str], app_slug: str, suspended_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, suspended_at: str(date-time)?, contact_email: str?} # Response
@errors {301: Moved permanently, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/interaction-limits
@desc Get interaction restrictions for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response

@endpoint PUT /repos/{owner}/{repo}/interaction-limits
@desc Set interaction restrictions for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., limit: str(existing_users/contributors_only/collaborators_only) # The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.}
@optional {expiry: str(one_day/three_days/one_week/one_month/six_months) # The duration of the interaction restriction. Default: `one_day`.}
@returns(200) {limit: str, origin: str, expires_at: str(date-time)} # Response
@errors {409: Response}
@example_request {"limit":"collaborators_only","expiry":"one_day"}

@endpoint DELETE /repos/{owner}/{repo}/interaction-limits
@desc Remove interaction restrictions for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response
@errors {409: Response}

@endpoint GET /repos/{owner}/{repo}/invitations
@desc List repository invitations
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint PATCH /repos/{owner}/{repo}/invitations/{invitation_id}
@desc Update a repository invitation
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., invitation_id: int # The unique identifier of the invitation.}
@optional {permissions: str(read/write/maintain/triage/admin) # The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.}
@returns(200) {id: int(int64), repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, invitee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, inviter: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, permissions: str, created_at: str(date-time), expired: bool, url: str, html_url: str, node_id: str} # Response
@example_request {"permissions":"write"}

@endpoint DELETE /repos/{owner}/{repo}/invitations/{invitation_id}
@desc Delete a repository invitation
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., invitation_id: int # The unique identifier of the invitation.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/issues
@desc List repository issues
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {milestone: str # If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned., state: str(open/closed/all)=open # Indicates the state of the issues to return., assignee: str # Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user., type: str # Can be the name of an issue type. If the string `*` is passed, issues with any type are accepted. If the string `none` is passed, issues without type are returned., creator: str # The user that created the issue., mentioned: str # A user that's mentioned in the issue., labels: str # A list of comma separated label names. Example: `bug,ui,@high`, sort: str(created/updated/comments)=created # What to sort results by., direction: str(asc/desc)=desc # The direction to sort the results by., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {301: Moved permanently, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/issues
@desc Create an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., title: any # The title of the issue.}
@optional {body: str # The contents of the issue., assignee: str # Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is closing down.**_, milestone: any, labels: [any] # Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._, assignees: [str] # Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._, type: str # The name of the issue type to associate with this issue. _NOTE: Only users with push access can set the type for new issues. The type is silently dropped otherwise._}
@returns(201) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@errors {400: Bad Request, 403: Forbidden, 422: Validation failed, or the endpoint has been spammed., 503: Service unavailable, 404: Resource not found, 410: Gone}
@example_request {"title":"Found a bug","body":"I'm having a problem with this.","assignees":["octocat"],"milestone":1,"labels":["bug"]}

@endpoint GET /repos/{owner}/{repo}/issues/comments
@desc List issue comments for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {sort: str(created/updated)=created # The property to sort the results by., direction: str(asc/desc) # Either `asc` or `desc`. Ignored without the `sort` parameter., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/issues/comments/{comment_id}
@desc Get an issue comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@returns(200) {id: int(int64), node_id: str, url: str(uri), body: str, body_text: str, body_html: str, html_url: str(uri), user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), issue_url: str(uri), author_association: str, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, pin: map?{pinned_at: str(date-time), pinned_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}} # Response
@errors {404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}
@desc Update an issue comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment., body: str # The contents of the comment.}
@returns(200) {id: int(int64), node_id: str, url: str(uri), body: str, body_text: str, body_html: str, html_url: str(uri), user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), issue_url: str(uri), author_association: str, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, pin: map?{pinned_at: str(date-time), pinned_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"body":"Me too"}

@endpoint DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}
@desc Delete an issue comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@returns(204) Response

@endpoint PUT /repos/{owner}/{repo}/issues/comments/{comment_id}/pin
@desc Pin an issue comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@returns(200) {id: int(int64), node_id: str, url: str(uri), body: str, body_text: str, body_html: str, html_url: str(uri), user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), issue_url: str(uri), author_association: str, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, pin: map?{pinned_at: str(date-time), pinned_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}} # Response
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 410: Gone, 422: Validation failed, or the endpoint has been spammed.}

@endpoint DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/pin
@desc Unpin an issue comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@returns(204) Response
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 410: Gone, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
@desc List reactions for an issue comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@optional {content: str(+1/-1/laugh/confused/heart/hooray/rocket/eyes) # Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue comment., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
@desc Create reaction for an issue comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment., content: str(+1/-1/laugh/confused/heart/hooray/rocket/eyes) # The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue comment.}
@returns(200) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Reaction exists
@returns(201) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Reaction created
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"content":"heart"}

@endpoint DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
@desc Delete an issue comment reaction
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment., reaction_id: int # The unique identifier of the reaction.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/issues/events
@desc List issue events for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/issues/events/{event_id}
@desc Get an issue event
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., event_id: int}
@returns(200) {id: int(int64), node_id: str, url: str(uri), actor: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, event: str, commit_id: str?, commit_url: str?, created_at: str(date-time), issue: map?{id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]}, label: map{name: str?, color: str?}, assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assigner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, review_requester: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, requested_reviewer: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, requested_team: map{id: int, node_id: str, name: str, slug: str, description: str?, privacy: str, notification_setting: str, permission: str, permissions: map{pull: bool, triage: bool, push: bool, maintain: bool, admin: bool}, url: str(uri), html_url: str(uri), members_url: str, repositories_url: str(uri), type: str, organization_id: int, enterprise_id: int, parent: map?{id: int, node_id: str, url: str(uri), members_url: str, name: str, description: str?, permission: str, privacy: str, notification_setting: str, html_url: str(uri), repositories_url: str(uri), slug: str, ldap_dn: str, type: str, organization_id: int, enterprise_id: int}}, dismissed_review: map{state: str, review_id: int, dismissal_message: str?, dismissal_commit_id: str?}, milestone: map{title: str}, project_card: map{url: str(uri), id: int, project_url: str(uri), project_id: int, column_name: str, previous_column_name: str}, rename: map{from: str, to: str}, author_association: str, lock_reason: str?, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}} # Response
@errors {404: Resource not found, 410: Gone, 403: Forbidden}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}
@desc Get an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@returns(200) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@errors {301: Moved permanently, 404: Resource not found, 410: Gone, 304: Not modified}

@endpoint PATCH /repos/{owner}/{repo}/issues/{issue_number}
@desc Update an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {title: any # The title of the issue., body: str # The contents of the issue., assignee: str # Username to assign to this issue. **This field is closing down.**, state: str(open/closed) # The open or closed state of the issue., state_reason: str(completed/not_planned/duplicate/reopened) # The reason for the state change. Ignored unless `state` is changed., milestone: any, labels: [any] # Labels to associate with this issue. Pass one or more labels to _replace_ the set of labels on this issue. Send an empty array (`[]`) to clear all labels from the issue. Only users with push access can set labels for issues. Without push access to the repository, label changes are silently dropped., assignees: [str] # Usernames to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this issue. Send an empty array (`[]`) to clear all assignees from the issue. Only users with push access can set assignees for new issues. Without push access to the repository, assignee changes are silently dropped., type: str # The name of the issue type to associate with this issue or use `null` to remove the current issue type. Only users with push access can set the type for issues. Without push access to the repository, type changes are silently dropped.}
@returns(200) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 503: Service unavailable, 403: Forbidden, 301: Moved permanently, 404: Resource not found, 410: Gone}
@example_request {"title":"Found a bug","body":"I'm having a problem with this.","assignees":["octocat"],"milestone":1,"state":"open","labels":["bug"]}

@endpoint POST /repos/{owner}/{repo}/issues/{issue_number}/assignees
@desc Add assignees to an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {assignees: [str] # Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._}
@returns(201) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@example_request {"assignees":["hubot","other_user"]}

@endpoint DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees
@desc Remove assignees from an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {assignees: [str] # Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._}
@returns(200) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@example_request {"assignees":["hubot","other_user"]}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}
@desc Check if a user can be assigned to a issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., assignee: str}
@returns(204) Response if `assignee` can be assigned to `issue_number`
@errors {404: Response if `assignee` can not be assigned to `issue_number`}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/comments
@desc List issue comments
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 410: Gone}

@endpoint POST /repos/{owner}/{repo}/issues/{issue_number}/comments
@desc Create an issue comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., body: str # The contents of the comment.}
@returns(201) {id: int(int64), node_id: str, url: str(uri), body: str, body_text: str, body_html: str, html_url: str(uri), user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), issue_url: str(uri), author_association: str, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, pin: map?{pinned_at: str(date-time), pinned_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}} # Response
@errors {403: Forbidden, 410: Gone, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"body":"Me too"}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by
@desc List dependencies an issue is blocked by
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {301: Moved permanently, 404: Resource not found, 410: Gone}

@endpoint POST /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by
@desc Add a dependency an issue is blocked by
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., issue_id: int # The id of the issue that blocks the current issue}
@returns(201) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@errors {301: Moved permanently, 403: Forbidden, 410: Gone, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"issue_id":1}

@endpoint DELETE /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by/{issue_id}
@desc Remove dependency an issue is blocked by
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., issue_id: int # The id of the blocking issue to remove as a dependency}
@returns(200) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@errors {301: Moved permanently, 400: Bad Request, 401: Requires authentication, 403: Forbidden, 404: Resource not found, 410: Gone}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocking
@desc List dependencies an issue is blocking
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {301: Moved permanently, 404: Resource not found, 410: Gone}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/events
@desc List issue events
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {410: Gone}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/labels
@desc List labels for an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {301: Moved permanently, 404: Resource not found, 410: Gone}

@endpoint POST /repos/{owner}/{repo}/issues/{issue_number}/labels
@desc Add labels to an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@returns(200) Response
@errors {301: Moved permanently, 404: Resource not found, 410: Gone, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"labels":["bug","enhancement"]}

@endpoint PUT /repos/{owner}/{repo}/issues/{issue_number}/labels
@desc Set labels for an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@returns(200) Response
@errors {301: Moved permanently, 404: Resource not found, 410: Gone, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"labels":["bug","enhancement"]}

@endpoint DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels
@desc Remove all labels from an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@returns(204) Response
@errors {301: Moved permanently, 404: Resource not found, 410: Gone}

@endpoint DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
@desc Remove a label from an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., name: str}
@returns(200) Response
@errors {301: Moved permanently, 404: Resource not found, 410: Gone}

@endpoint PUT /repos/{owner}/{repo}/issues/{issue_number}/lock
@desc Lock an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {lock_reason: str(off-topic/too heated/resolved/spam) # The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:    * `off-topic`    * `too heated`    * `resolved`    * `spam`}
@returns(204) Response
@errors {403: Forbidden, 410: Gone, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"lock_reason":"off-topic"}

@endpoint DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock
@desc Unlock an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@returns(204) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/parent
@desc Get parent issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@returns(200) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@errors {301: Moved permanently, 404: Resource not found, 410: Gone}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/reactions
@desc List reactions for an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {content: str(+1/-1/laugh/confused/heart/hooray/rocket/eyes) # Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 410: Gone}

@endpoint POST /repos/{owner}/{repo}/issues/{issue_number}/reactions
@desc Create reaction for an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., content: str(+1/-1/laugh/confused/heart/hooray/rocket/eyes) # The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue.}
@returns(200) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Response
@returns(201) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"content":"heart"}

@endpoint DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
@desc Delete an issue reaction
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., reaction_id: int # The unique identifier of the reaction.}
@returns(204) Response

@endpoint DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue
@desc Remove sub-issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., sub_issue_id: int # The id of the sub-issue to remove}
@returns(200) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@errors {400: Bad Request, 404: Resource not found}
@example_request {"sub_issue_id":6}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues
@desc List sub-issues
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 410: Gone}

@endpoint POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues
@desc Add sub-issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., sub_issue_id: int # The id of the sub-issue to add. The sub-issue must belong to the same repository owner as the parent issue}
@optional {replace_parent: bool # Option that, when true, instructs the operation to replace the sub-issues current parent issue}
@returns(201) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@errors {403: Forbidden, 410: Gone, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"sub_issue_id":1}

@endpoint PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority
@desc Reprioritize sub-issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue., sub_issue_id: int # The id of the sub-issue to reprioritize}
@optional {after_id: int # The id of the sub-issue to be prioritized after (either positional argument after OR before should be specified)., before_id: int # The id of the sub-issue to be prioritized before (either positional argument after OR before should be specified).}
@returns(200) {id: int(int64), node_id: str, url: str(uri), repository_url: str(uri), labels_url: str, comments_url: str(uri), events_url: str(uri), html_url: str(uri), number: int, state: str, state_reason: str?, title: str, body: str?, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, labels: [any], assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, locked: bool, active_lock_reason: str?, comments: int, pull_request: map{merged_at: str(date-time)?, diff_url: str(uri)?, html_url: str(uri)?, patch_url: str(uri)?, url: str(uri)?}, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), draft: bool, closed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body_html: str, body_text: str, timeline_url: str(uri), type: map?{id: int, node_id: str, name: str, description: str?, color: str?, created_at: str(date-time), updated_at: str(date-time), is_enabled: bool}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, performed_via_github_app: map?{id: int, slug: str, node_id: str, client_id: str, owner: any, name: str, description: str?, external_url: str(uri), html_url: str(uri), created_at: str(date-time), updated_at: str(date-time), permissions: map{issues: str, checks: str, metadata: str, contents: str, deployments: str}, events: [str], installations_count: int}, author_association: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, sub_issues_summary: map{total: int, completed: int, percent_completed: int}, parent_issue_url: str(uri)?, issue_dependencies_summary: map{blocked_by: int, blocking: int, total_blocked_by: int, total_blocking: int}, issue_field_values: [map]} # Response
@errors {403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 503: Service unavailable}
@example_request {"sub_issue_id":6,"after_id":5}

@endpoint GET /repos/{owner}/{repo}/issues/{issue_number}/timeline
@desc List timeline events for an issue
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., issue_number: int # The number that identifies the issue.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 410: Gone}

@endpoint GET /repos/{owner}/{repo}/keys
@desc List deploy keys
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/keys
@desc Create a deploy key
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., key: str # The contents of the key.}
@optional {title: str # A name for the key., read_only: bool # If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.      Deploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/)."}
@returns(201) {id: int, key: str, url: str, title: str, verified: bool, created_at: str, read_only: bool, added_by: str?, last_used: str(date-time)?, enabled: bool} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"title":"octocat@octomac","key":"ssh-rsa AAA...","read_only":true}

@endpoint GET /repos/{owner}/{repo}/keys/{key_id}
@desc Get a deploy key
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., key_id: int # The unique identifier of the key.}
@returns(200) {id: int, key: str, url: str, title: str, verified: bool, created_at: str, read_only: bool, added_by: str?, last_used: str(date-time)?, enabled: bool} # Response
@errors {404: Resource not found}

@endpoint DELETE /repos/{owner}/{repo}/keys/{key_id}
@desc Delete a deploy key
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., key_id: int # The unique identifier of the key.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/labels
@desc List labels for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/labels
@desc Create a label
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."}
@optional {color: str # The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`., description: str # A short description of the label. Must be 100 characters or fewer.}
@returns(201) {id: int(int64), node_id: str, url: str(uri), name: str, description: str?, color: str, default: bool} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"name":"bug","description":"Something isn't working","color":"f29513"}

@endpoint GET /repos/{owner}/{repo}/labels/{name}
@desc Get a label
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str}
@returns(200) {id: int(int64), node_id: str, url: str(uri), name: str, description: str?, color: str, default: bool} # Response
@errors {404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/labels/{name}
@desc Update a label
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str}
@optional {new_name: str # The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet).", color: str # The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`., description: str # A short description of the label. Must be 100 characters or fewer.}
@returns(200) {id: int(int64), node_id: str, url: str(uri), name: str, description: str?, color: str, default: bool} # Response
@example_request {"new_name":"bug :bug:","description":"Small bug fix required","color":"b01f26"}

@endpoint DELETE /repos/{owner}/{repo}/labels/{name}
@desc Delete a label
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/languages
@desc List repository languages
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response

@endpoint GET /repos/{owner}/{repo}/license
@desc Get the license for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {ref: str # The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.}
@returns(200) {name: str, path: str, sha: str, size: int, url: str(uri), html_url: str(uri)?, git_url: str(uri)?, download_url: str(uri)?, type: str, content: str, encoding: str, _links: map{git: str(uri)?, html: str(uri)?, self: str(uri)}, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}} # Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/merge-upstream
@desc Sync a fork branch with the upstream repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch which should be updated to match upstream.}
@returns(200) {message: str, merge_type: str, base_branch: str} # The branch has been successfully synced with the upstream repository
@errors {409: The branch could not be synced because of a merge conflict, 422: The branch could not be synced for some other reason}
@example_request {"branch":"main"}

@endpoint POST /repos/{owner}/{repo}/merges
@desc Merge a branch
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., base: str # The name of the base branch that the head will be merged into., head: str # The head to merge. This can be a branch name or a commit SHA1.}
@optional {commit_message: str # Commit message to use for the merge commit. If omitted, a default message will be used.}
@returns(201) {url: str(uri), sha: str, node_id: str, html_url: str(uri), comments_url: str(uri), commit: map{url: str(uri), author: map?{name: str, email: str, date: str(date-time)}, committer: map?{name: str, email: str, date: str(date-time)}, message: str, comment_count: int, tree: map{sha: str, url: str(uri)}, verification: map{verified: bool, reason: str, payload: str?, signature: str?, verified_at: str?}}, author: any?, committer: any?, parents: [map], stats: map{additions: int, deletions: int, total: int}, files: [map]} # Successful Response (The resulting merge commit)
@returns(204) Response when already merged
@errors {404: Not Found when the base or head does not exist, 409: Conflict when there is a merge conflict, 403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"base":"master","head":"cool_feature","commit_message":"Shipped cool_feature!"}

@endpoint GET /repos/{owner}/{repo}/milestones
@desc List milestones
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {state: str(open/closed/all)=open # The state of the milestone. Either `open`, `closed`, or `all`., sort: str(due_on/completeness)=due_on # What to sort results by. Either `due_on` or `completeness`., direction: str(asc/desc)=asc # The direction of the sort. Either `asc` or `desc`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/milestones
@desc Create a milestone
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., title: str # The title of the milestone.}
@optional {state: str(open/closed)=open # The state of the milestone. Either `open` or `closed`., description: str # A description of the milestone., due_on: str(date-time) # The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@returns(201) {url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"title":"v1.0","state":"open","description":"Tracking milestone for version 1.0","due_on":"2012-10-09T23:39:01Z"}

@endpoint GET /repos/{owner}/{repo}/milestones/{milestone_number}
@desc Get a milestone
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., milestone_number: int # The number that identifies the milestone.}
@returns(200) {url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?} # Response
@errors {404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/milestones/{milestone_number}
@desc Update a milestone
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., milestone_number: int # The number that identifies the milestone.}
@optional {title: str # The title of the milestone., state: str(open/closed)=open # The state of the milestone. Either `open` or `closed`., description: str # A description of the milestone., due_on: str(date-time) # The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@returns(200) {url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?} # Response
@example_request {"title":"v1.0","state":"open","description":"Tracking milestone for version 1.0","due_on":"2012-10-09T23:39:01Z"}

@endpoint DELETE /repos/{owner}/{repo}/milestones/{milestone_number}
@desc Delete a milestone
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., milestone_number: int # The number that identifies the milestone.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels
@desc List labels for issues in a milestone
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., milestone_number: int # The number that identifies the milestone.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /repos/{owner}/{repo}/notifications
@desc List repository notifications for the authenticated user
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {all: bool=False # If `true`, show notifications marked as read., participating: bool=False # If `true`, only shows notifications in which the user is directly participating or mentioned., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., before: str(date-time) # Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint PUT /repos/{owner}/{repo}/notifications
@desc Mark repository notifications as read
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {last_read_at: str(date-time) # Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.}
@returns(202) {message: str, url: str} # Response
@returns(205) Reset Content
@example_request {"last_read_at":"2019-01-01T00:00:00Z"}

@endpoint GET /repos/{owner}/{repo}/pages
@desc Get a GitHub Pages site
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {url: str(uri), status: str?, cname: str?, protected_domain_state: str?, pending_domain_unverified_at: str(date-time)?, custom_404: bool, html_url: str(uri), build_type: str?, source: map{branch: str, path: str}, public: bool, https_certificate: map{state: str, description: str, domains: [str], expires_at: str(date)}, https_enforced: bool} # Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/pages
@desc Create a GitHub Pages site
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {build_type: str(legacy/workflow) # The process in which the Page will be built. Possible values are `"legacy"` and `"workflow"`., source: map{branch!: str, path: str} # The source branch and directory used to publish your Pages site.}
@returns(201) {url: str(uri), status: str?, cname: str?, protected_domain_state: str?, pending_domain_unverified_at: str(date-time)?, custom_404: bool, html_url: str(uri), build_type: str?, source: map{branch: str, path: str}, public: bool, https_certificate: map{state: str, description: str, domains: [str], expires_at: str(date)}, https_enforced: bool} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 409: Conflict}
@example_request {"source":{"branch":"main","path":"/docs"}}

@endpoint PUT /repos/{owner}/{repo}/pages
@desc Update information about a GitHub Pages site
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {cname: str # Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see "[Using a custom domain with GitHub Pages](https://docs.github.com/pages/configuring-a-custom-domain-for-your-github-pages-site).", https_enforced: bool # Specify whether HTTPS should be enforced for the repository., build_type: str(legacy/workflow) # The process by which the GitHub Pages site will be built. `workflow` means that the site is built by a custom GitHub Actions workflow. `legacy` means that the site is built by GitHub when changes are pushed to a specific branch., source: any}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed., 400: Bad Request, 409: Conflict}
@example_request {"cname":"octocatblog.com","source":{"branch":"main","path":"/"}}

@endpoint DELETE /repos/{owner}/{repo}/pages
@desc Delete a GitHub Pages site
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found, 409: Conflict}

@endpoint GET /repos/{owner}/{repo}/pages/builds
@desc List GitHub Pages builds
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/pages/builds
@desc Request a GitHub Pages build
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(201) {url: str(uri), status: str} # Response

@endpoint GET /repos/{owner}/{repo}/pages/builds/latest
@desc Get latest Pages build
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {url: str(uri), status: str, error: map{message: str?}, pusher: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, commit: str, duration: int, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint GET /repos/{owner}/{repo}/pages/builds/{build_id}
@desc Get GitHub Pages build
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., build_id: int}
@returns(200) {url: str(uri), status: str, error: map{message: str?}, pusher: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, commit: str, duration: int, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint POST /repos/{owner}/{repo}/pages/deployments
@desc Create a GitHub Pages deployment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pages_build_version: str=GITHUB_SHA # A unique string that represents the version of the build for this deployment., oidc_token: str # The OIDC token issued by GitHub Actions certifying the origin of the deployment.}
@optional {artifact_id: num # The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required., artifact_url: str # The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required., environment: str=github-pages # The target environment for this GitHub Pages deployment.}
@returns(200) {id: any, status_url: str(uri), page_url: str(uri), preview_url: str(uri)} # Response
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"artifact_url":"https://downloadcontent/","environment":"github-pages","pages_build_version":"4fd754f7e594640989b406850d0bc8f06a121251","oidc_token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6IlV2R1h4SUhlY0JFc1JCdEttemUxUEhfUERiVSIsImtpZCI6IjUyRjE5N0M0ODFERTcwMTEyQzQ0MUI0QTlCMzdCNTNDN0ZDRjBEQjUifQ.eyJqdGkiOiJhMWIwNGNjNy0zNzZiLTQ1N2QtOTMzNS05NTY5YmVjZDExYTIiLCJzdWIiOiJyZXBvOnBhcGVyLXNwYS9taW55aTplbnZpcm9ubWVudDpQcm9kdWN0aW9uIiwiYXVkIjoiaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLXNwYSIsInJlZiI6InJlZnMvaGVhZHMvbWFpbiIsInNoYSI6ImEyODU1MWJmODdiZDk3NTFiMzdiMmM0YjM3M2MxZjU3NjFmYWM2MjYiLCJyZXBvc2l0b3J5IjoicGFwZXItc3BhL21pbnlpIiwicmVwb3NpdG9yeV9vd25lciI6InBhcGVyLXNwYSIsInJ1bl9pZCI6IjE1NDY0NTkzNjQiLCJydW5fbnVtYmVyIjoiMzQiLCJydW5fYXR0ZW1wdCI6IjYiLCJhY3RvciI6IllpTXlzdHkiLCJ3b3JrZmxvdyI6IkNJIiwiaGVhZF9yZWYiOiIiLCJiYXNlX3JlZiI6IiIsImV2ZW50X25hbWUiOiJwdXNoIiwicmVmX3R5cGUiOiJicmFuY2giLCJlbnZpcm9ubWVudCI6IlByb2R1Y3Rpb24iLCJqb2Jfd29ya2Zsb3dfcmVmIjoicGFwZXItc3BhL21pbnlpLy5naXRodWIvd29ya2Zsb3dzL2JsYW5rLnltbEByZWZzL2hlYWRzL21haW4iLCJpc3MiOiJodHRwczovL3Rva2VuLmFjdGlvbnMuZ2l0aHVidXNlcmNvbnRlbnQuY29tIiwibmJmIjoxNjM5MDAwODU2LCJleHAiOjE2MzkwMDE3NTYsImlhdCI6MTYzOTAwMTQ1Nn0.VP8WictbQECKozE2SgvKb2FqJ9hisWsoMkYRTqfBrQfZTCXi5IcFEdgDMB2X7a99C2DeUuTvHh9RMKXLL2a0zg3-Sd7YrO7a2ll2kNlnvyIypcN6AeIc7BxHsTTnZN9Ud_xmEsTrSRGOEKmzCFkULQ6N4zlVD0sidypmXlMemmWEcv_ZHqhioEI_VMp5vwXQurketWH7qX4oDgG4okyYtPrv5RQHbfQcVo9izaPJ_jnsDd0CBA0QOx9InjPidtIkMYQLyUgJy33HLJy86EFNUnAf8UhBQuQi5mAsEpEzBBuKpG3PDiPtYCHOk64JZkZGd5mR888a5sbHRiaF8hm8YA"}

@endpoint GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}
@desc Get the status of a GitHub Pages deployment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pages_deployment_id: any # The ID of the Pages deployment. You can also give the commit SHA of the deployment.}
@returns(200) {status: str} # Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel
@desc Cancel a GitHub Pages deployment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pages_deployment_id: any # The ID of the Pages deployment. You can also give the commit SHA of the deployment.}
@returns(204) A header with no content is returned.
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/pages/health
@desc Get a DNS health check for GitHub Pages
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {domain: map{host: str, uri: str, nameservers: str, dns_resolves: bool, is_proxied: bool?, is_cloudflare_ip: bool?, is_fastly_ip: bool?, is_old_ip_address: bool?, is_a_record: bool?, has_cname_record: bool?, has_mx_records_present: bool?, is_valid_domain: bool, is_apex_domain: bool, should_be_a_record: bool?, is_cname_to_github_user_domain: bool?, is_cname_to_pages_dot_github_dot_com: bool?, is_cname_to_fastly: bool?, is_pointed_to_github_pages_ip: bool?, is_non_github_pages_ip_present: bool?, is_pages_domain: bool, is_served_by_pages: bool?, is_valid: bool, reason: str?, responds_to_https: bool, enforces_https: bool, https_error: str?, is_https_eligible: bool?, caa_error: str?}, alt_domain: map?{host: str, uri: str, nameservers: str, dns_resolves: bool, is_proxied: bool?, is_cloudflare_ip: bool?, is_fastly_ip: bool?, is_old_ip_address: bool?, is_a_record: bool?, has_cname_record: bool?, has_mx_records_present: bool?, is_valid_domain: bool, is_apex_domain: bool, should_be_a_record: bool?, is_cname_to_github_user_domain: bool?, is_cname_to_pages_dot_github_dot_com: bool?, is_cname_to_fastly: bool?, is_pointed_to_github_pages_ip: bool?, is_non_github_pages_ip_present: bool?, is_pages_domain: bool, is_served_by_pages: bool?, is_valid: bool, reason: str?, responds_to_https: bool, enforces_https: bool, https_error: str?, is_https_eligible: bool?, caa_error: str?}} # Response
@returns(202) Empty response
@errors {400: Custom domains are not available for GitHub Pages, 422: There isn't a CNAME for this page, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/private-vulnerability-reporting
@desc Check if private vulnerability reporting is enabled for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {enabled: bool} # Private vulnerability reporting status
@errors {422: Bad Request}

@endpoint PUT /repos/{owner}/{repo}/private-vulnerability-reporting
@desc Enable private vulnerability reporting for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) A header with no content is returned.
@errors {422: Bad Request}

@endpoint DELETE /repos/{owner}/{repo}/private-vulnerability-reporting
@desc Disable private vulnerability reporting for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) A header with no content is returned.
@errors {422: Bad Request}

@endpoint GET /repos/{owner}/{repo}/properties/values
@desc Get all custom property values for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/properties/values
@desc Create or update custom property values for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., properties: [map{property_name!: str, value!: any}] # A list of custom property names and associated values to apply to the repositories.}
@returns(204) No Content when custom property values are successfully created or updated
@errors {403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"properties":[{"property_name":"environment","value":"production"},{"property_name":"service","value":"web"},{"property_name":"team","value":"octocat"}]}

@endpoint GET /repos/{owner}/{repo}/pulls
@desc List pull requests
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {state: str(open/closed/all)=open # Either `open`, `closed`, or `all` to filter by state., head: str # Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`., base: str # Filter pulls by base branch name. Example: `gh-pages`., sort: str(created/updated/popularity/long-running)=created # What to sort results by. `popularity` will sort by the number of comments. `long-running` will sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month., direction: str(asc/desc) # The direction of the sort. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 422: Validation failed, or the endpoint has been spammed.}

@endpoint POST /repos/{owner}/{repo}/pulls
@desc Create a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., head: str # The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`., base: str # The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.}
@optional {title: str # The title of the new pull request. Required unless `issue` is specified., head_repo: str(repo.nwo) # The name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization., body: str # The contents of the pull request., maintainer_can_modify: bool # Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request., draft: bool # Indicates whether the pull request is a draft. See "[Draft Pull Requests](https://docs.github.com/articles/about-pull-requests#draft-pull-requests)" in the GitHub Help documentation to learn more., issue: int(int64) # An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.}
@returns(201) {url: str(uri), id: int(int64), node_id: str, html_url: str(uri), diff_url: str(uri), patch_url: str(uri), issue_url: str(uri), commits_url: str(uri), review_comments_url: str(uri), review_comment_url: str, comments_url: str(uri), statuses_url: str(uri), number: int, state: str, locked: bool, title: str, user: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str?, labels: [map], milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, active_lock_reason: str?, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, merged_at: str(date-time)?, merge_commit_sha: str?, assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, requested_reviewers: [map]?, requested_teams: [map]?, head: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, base: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, _links: map{comments: map{href: str}, commits: map{href: str}, statuses: map{href: str}, html: map{href: str}, issue: map{href: str}, review_comments: map{href: str}, review_comment: map{href: str}, self: map{href: str}}, author_association: str, auto_merge: map?{enabled_by: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, merge_method: str, commit_title: str, commit_message: str}, draft: bool, merged: bool, mergeable: bool?, rebaseable: bool?, mergeable_state: str, merged_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, comments: int, review_comments: int, maintainer_can_modify: bool, commits: int, additions: int, deletions: int, changed_files: int} # Response
@errors {403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"title":"Amazing new feature","body":"Please pull these awesome changes in!","head":"octocat:new-feature","base":"master"}

@endpoint GET /repos/{owner}/{repo}/pulls/comments
@desc List review comments in a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {sort: str(created/updated/created_at), direction: str(asc/desc) # The direction to sort results. Ignored without `sort` parameter., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /repos/{owner}/{repo}/pulls/comments/{comment_id}
@desc Get a review comment for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@returns(200) {url: str, pull_request_review_id: int(int64)?, id: int(int64), node_id: str, diff_hunk: str, path: str, position: int, original_position: int, commit_id: str, original_commit_id: str, in_reply_to_id: int, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, created_at: str(date-time), updated_at: str(date-time), html_url: str(uri), pull_request_url: str(uri), author_association: str, _links: map{self: map{href: str(uri)}, html: map{href: str(uri)}, pull_request: map{href: str(uri)}}, start_line: int?, original_start_line: int?, start_side: str?, line: int, original_line: int, side: str, subject_type: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, body_html: str, body_text: str} # Response
@errors {404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}
@desc Update a review comment for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment., body: str # The text of the reply to the review comment.}
@returns(200) {url: str, pull_request_review_id: int(int64)?, id: int(int64), node_id: str, diff_hunk: str, path: str, position: int, original_position: int, commit_id: str, original_commit_id: str, in_reply_to_id: int, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, created_at: str(date-time), updated_at: str(date-time), html_url: str(uri), pull_request_url: str(uri), author_association: str, _links: map{self: map{href: str(uri)}, html: map{href: str(uri)}, pull_request: map{href: str(uri)}}, start_line: int?, original_start_line: int?, start_side: str?, line: int, original_line: int, side: str, subject_type: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, body_html: str, body_text: str} # Response
@example_request {"body":"I like this too!"}

@endpoint DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}
@desc Delete a review comment for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
@desc List reactions for a pull request review comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment.}
@optional {content: str(+1/-1/laugh/confused/heart/hooray/rocket/eyes) # Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a pull request review comment., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
@desc Create reaction for a pull request review comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment., content: str(+1/-1/laugh/confused/heart/hooray/rocket/eyes) # The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the pull request review comment.}
@returns(200) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Reaction exists
@returns(201) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Reaction created
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"content":"heart"}

@endpoint DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
@desc Delete a pull request comment reaction
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., comment_id: int(int64) # The unique identifier of the comment., reaction_id: int # The unique identifier of the reaction.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/pulls/{pull_number}
@desc Get a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@returns(200) {url: str(uri), id: int(int64), node_id: str, html_url: str(uri), diff_url: str(uri), patch_url: str(uri), issue_url: str(uri), commits_url: str(uri), review_comments_url: str(uri), review_comment_url: str, comments_url: str(uri), statuses_url: str(uri), number: int, state: str, locked: bool, title: str, user: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str?, labels: [map], milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, active_lock_reason: str?, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, merged_at: str(date-time)?, merge_commit_sha: str?, assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, requested_reviewers: [map]?, requested_teams: [map]?, head: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, base: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, _links: map{comments: map{href: str}, commits: map{href: str}, statuses: map{href: str}, html: map{href: str}, issue: map{href: str}, review_comments: map{href: str}, review_comment: map{href: str}, self: map{href: str}}, author_association: str, auto_merge: map?{enabled_by: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, merge_method: str, commit_title: str, commit_message: str}, draft: bool, merged: bool, mergeable: bool?, rebaseable: bool?, mergeable_state: str, merged_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, comments: int, review_comments: int, maintainer_can_modify: bool, commits: int, additions: int, deletions: int, changed_files: int} # Pass the appropriate [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types) to fetch diff and patch formats.
@errors {304: Not modified, 404: Resource not found, 406: Unacceptable, 500: Internal Error, 503: Service unavailable}

@endpoint PATCH /repos/{owner}/{repo}/pulls/{pull_number}
@desc Update a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {title: str # The title of the pull request., body: str # The contents of the pull request., state: str(open/closed) # State of this Pull Request. Either `open` or `closed`., base: str # The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository., maintainer_can_modify: bool # Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.}
@returns(200) {url: str(uri), id: int(int64), node_id: str, html_url: str(uri), diff_url: str(uri), patch_url: str(uri), issue_url: str(uri), commits_url: str(uri), review_comments_url: str(uri), review_comment_url: str, comments_url: str(uri), statuses_url: str(uri), number: int, state: str, locked: bool, title: str, user: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str?, labels: [map], milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, active_lock_reason: str?, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, merged_at: str(date-time)?, merge_commit_sha: str?, assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, requested_reviewers: [map]?, requested_teams: [map]?, head: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, base: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, _links: map{comments: map{href: str}, commits: map{href: str}, statuses: map{href: str}, html: map{href: str}, issue: map{href: str}, review_comments: map{href: str}, review_comment: map{href: str}, self: map{href: str}}, author_association: str, auto_merge: map?{enabled_by: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, merge_method: str, commit_title: str, commit_message: str}, draft: bool, merged: bool, mergeable: bool?, rebaseable: bool?, mergeable_state: str, merged_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, comments: int, review_comments: int, maintainer_can_modify: bool, commits: int, additions: int, deletions: int, changed_files: int} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"title":"new title","body":"updated body","state":"open","base":"master"}

@endpoint POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces
@desc Create a codespace from a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {location: str # The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided., geo: str(EuropeWest/SoutheastAsia/UsEast/UsWest) # The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down., client_ip: str # IP for location auto-detection when proxying a request, machine: str # Machine type to use for this codespace, devcontainer_path: str # Path to devcontainer.json config to use for this codespace, multi_repo_permissions_opt_out: bool # Whether to authorize requested permissions from devcontainer.json, working_directory: str # Working directory for this codespace, idle_timeout_minutes: int # Time in minutes before codespace stops from inactivity, display_name: str # Display name for this codespace, retention_period_minutes: int # Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).}
@returns(201) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response when the codespace was successfully created
@returns(202) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response when the codespace creation partially failed but is being retried in the background
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 503: Service unavailable}
@example_request {"repository_id":1,"ref":"main"}

@endpoint GET /repos/{owner}/{repo}/pulls/{pull_number}/comments
@desc List review comments on a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {sort: str(created/updated)=created # The property to sort the results by., direction: str(asc/desc) # The direction to sort results. Ignored without `sort` parameter., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/pulls/{pull_number}/comments
@desc Create a review comment for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request., body: str # The text of the review comment., commit_id: str # The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`., path: str # The relative path to the file that necessitates a comment.}
@optional {position: int # **This parameter is closing down. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file., side: str(LEFT/RIGHT) # In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation., line: int # **Required unless using `subject_type:file`**. The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to., start_line: int # **Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation., start_side: str(LEFT/RIGHT/side) # **Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context., in_reply_to: int # The ID of the review comment to reply to. To find the ID of a review comment with ["List review comments on a pull request"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored., subject_type: str(line/file) # The level at which the comment is targeted.}
@returns(201) {url: str, pull_request_review_id: int(int64)?, id: int(int64), node_id: str, diff_hunk: str, path: str, position: int, original_position: int, commit_id: str, original_commit_id: str, in_reply_to_id: int, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, created_at: str(date-time), updated_at: str(date-time), html_url: str(uri), pull_request_url: str(uri), author_association: str, _links: map{self: map{href: str(uri)}, html: map{href: str(uri)}, pull_request: map{href: str(uri)}}, start_line: int?, original_start_line: int?, start_side: str?, line: int, original_line: int, side: str, subject_type: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, body_html: str, body_text: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"body":"Great stuff!","commit_id":"6dcb09b5b57875f334f61aebed695e2e4193db5e","path":"file1.txt","start_line":1,"start_side":"RIGHT","line":2,"side":"RIGHT"}

@endpoint POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
@desc Create a reply for a review comment
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request., comment_id: int(int64) # The unique identifier of the comment., body: str # The text of the review comment.}
@returns(201) {url: str, pull_request_review_id: int(int64)?, id: int(int64), node_id: str, diff_hunk: str, path: str, position: int, original_position: int, commit_id: str, original_commit_id: str, in_reply_to_id: int, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, created_at: str(date-time), updated_at: str(date-time), html_url: str(uri), pull_request_url: str(uri), author_association: str, _links: map{self: map{href: str(uri)}, html: map{href: str(uri)}, pull_request: map{href: str(uri)}}, start_line: int?, original_start_line: int?, start_side: str?, line: int, original_line: int, side: str, subject_type: str, reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}, body_html: str, body_text: str} # Response
@errors {404: Resource not found}
@example_request {"body":"Great stuff!"}

@endpoint GET /repos/{owner}/{repo}/pulls/{pull_number}/commits
@desc List commits on a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /repos/{owner}/{repo}/pulls/{pull_number}/files
@desc List pull requests files
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed., 500: Internal Error, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/pulls/{pull_number}/merge
@desc Check if a pull request has been merged
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@returns(204) Response if pull request has been merged
@errors {404: Not Found if pull request has not been merged}

@endpoint PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge
@desc Merge a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {commit_title: str # Title for the automatic commit message., commit_message: str # Extra detail to append to automatic commit message., sha: str # SHA that pull request head must match to allow merge., merge_method: str(merge/squash/rebase) # The merge method to use.}
@returns(200) {sha: str, merged: bool, message: str} # if merge was successful
@errors {405: Method Not Allowed if merge cannot be performed, 409: Conflict if sha was provided and pull request head did not match, 422: Validation failed, or the endpoint has been spammed., 403: Forbidden, 404: Resource not found}
@example_request {"commit_title":"Expand enum","commit_message":"Add a new value to the merge_method enum"}

@endpoint GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
@desc Get all requested reviewers for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@returns(200) {users: [map], teams: [map]} # Response

@endpoint POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
@desc Request reviewers for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {reviewers: [str] # An array of user `login`s that will be requested., team_reviewers: [str] # An array of team `slug`s that will be requested.}
@returns(201) {url: str(uri), id: int(int64), node_id: str, html_url: str(uri), diff_url: str(uri), patch_url: str(uri), issue_url: str(uri), commits_url: str(uri), review_comments_url: str(uri), review_comment_url: str, comments_url: str(uri), statuses_url: str(uri), number: int, state: str, locked: bool, title: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str?, labels: [map], milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, active_lock_reason: str?, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, merged_at: str(date-time)?, merge_commit_sha: str?, assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, requested_reviewers: [map]?, requested_teams: [map]?, head: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, base: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, _links: map{comments: map{href: str}, commits: map{href: str}, statuses: map{href: str}, html: map{href: str}, issue: map{href: str}, review_comments: map{href: str}, review_comment: map{href: str}, self: map{href: str}}, author_association: str, auto_merge: map?{enabled_by: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, merge_method: str, commit_title: str, commit_message: str}, draft: bool} # Response
@errors {422: Unprocessable Entity if user is not a collaborator, 403: Forbidden}
@example_request {"reviewers":["octocat","hubot","other_user"],"team_reviewers":["justice-league"]}

@endpoint DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
@desc Remove requested reviewers from a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request., reviewers: [str] # An array of user `login`s that will be removed.}
@optional {team_reviewers: [str] # An array of team `slug`s that will be removed.}
@returns(200) {url: str(uri), id: int(int64), node_id: str, html_url: str(uri), diff_url: str(uri), patch_url: str(uri), issue_url: str(uri), commits_url: str(uri), review_comments_url: str(uri), review_comment_url: str, comments_url: str(uri), statuses_url: str(uri), number: int, state: str, locked: bool, title: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str?, labels: [map], milestone: map?{url: str(uri), html_url: str(uri), labels_url: str(uri), id: int, node_id: str, number: int, state: str, title: str, description: str?, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, open_issues: int, closed_issues: int, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, due_on: str(date-time)?}, active_lock_reason: str?, created_at: str(date-time), updated_at: str(date-time), closed_at: str(date-time)?, merged_at: str(date-time)?, merge_commit_sha: str?, assignee: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assignees: [map]?, requested_reviewers: [map]?, requested_teams: [map]?, head: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, base: map{label: str, ref: str, repo: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, sha: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}}, _links: map{comments: map{href: str}, commits: map{href: str}, statuses: map{href: str}, html: map{href: str}, issue: map{href: str}, review_comments: map{href: str}, review_comment: map{href: str}, self: map{href: str}}, author_association: str, auto_merge: map?{enabled_by: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, merge_method: str, commit_title: str, commit_message: str}, draft: bool} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"reviewers":["octocat","hubot","other_user"],"team_reviewers":["justice-league"]}

@endpoint GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews
@desc List reviews for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) The list of reviews returns in chronological order.

@endpoint POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews
@desc Create a review for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {commit_id: str # The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value., body: str # **Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review., event: str(APPROVE/REQUEST_CHANGES/COMMENT) # The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request) when you are ready., comments: [map{path!: str, position: int, body!: str, line: int, side: str, start_line: int, start_side: str}] # Use the following table to specify the location, destination, and contents of the draft review comment.}
@returns(200) {id: int(int64), node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, state: str, html_url: str(uri), pull_request_url: str(uri), _links: map{html: map{href: str}, pull_request: map{href: str}}, submitted_at: str(date-time), commit_id: str?, body_html: str, body_text: str, author_association: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"commit_id":"ecdd80bb57125d7ba9641ffaa4d7d2c19d3f3091","body":"This is close to perfect! Please address the suggested inline change.","event":"REQUEST_CHANGES","comments":[{"path":"file.md","position":6,"body":"Please add more information here, and fix this typo."}]}

@endpoint GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
@desc Get a review for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request., review_id: int # The unique identifier of the review.}
@returns(200) {id: int(int64), node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, state: str, html_url: str(uri), pull_request_url: str(uri), _links: map{html: map{href: str}, pull_request: map{href: str}}, submitted_at: str(date-time), commit_id: str?, body_html: str, body_text: str, author_association: str} # Response
@errors {404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
@desc Update a review for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request., review_id: int # The unique identifier of the review., body: str # The body text of the pull request review.}
@returns(200) {id: int(int64), node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, state: str, html_url: str(uri), pull_request_url: str(uri), _links: map{html: map{href: str}, pull_request: map{href: str}}, submitted_at: str(date-time), commit_id: str?, body_html: str, body_text: str, author_association: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"body":"This is close to perfect! Please address the suggested inline change. And add more about this."}

@endpoint DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
@desc Delete a pending review for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request., review_id: int # The unique identifier of the review.}
@returns(200) {id: int(int64), node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, state: str, html_url: str(uri), pull_request_url: str(uri), _links: map{html: map{href: str}, pull_request: map{href: str}}, submitted_at: str(date-time), commit_id: str?, body_html: str, body_text: str, author_association: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
@desc List comments for a pull request review
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request., review_id: int # The unique identifier of the review.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
@desc Dismiss a review for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request., review_id: int # The unique identifier of the review., message: str # The message for the pull request review dismissal}
@optional {event: str}
@returns(200) {id: int(int64), node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, state: str, html_url: str(uri), pull_request_url: str(uri), _links: map{html: map{href: str}, pull_request: map{href: str}}, submitted_at: str(date-time), commit_id: str?, body_html: str, body_text: str, author_association: str} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"message":"You are dismissed","event":"DISMISS"}

@endpoint POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
@desc Submit a review for a pull request
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request., review_id: int # The unique identifier of the review., event: str(APPROVE/REQUEST_CHANGES/COMMENT) # The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.}
@optional {body: str # The body text of the pull request review}
@returns(200) {id: int(int64), node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, body: str, state: str, html_url: str(uri), pull_request_url: str(uri), _links: map{html: map{href: str}, pull_request: map{href: str}}, submitted_at: str(date-time), commit_id: str?, body_html: str, body_text: str, author_association: str} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"body":"Here is the body for the review.","event":"REQUEST_CHANGES"}

@endpoint PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch
@desc Update a pull request branch
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pull_number: int # The number that identifies the pull request.}
@optional {expected_head_sha: str # The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the "[List commits](https://docs.github.com/rest/commits/commits#list-commits)" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref.}
@returns(202) {message: str, url: str} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"expected_head_sha":"6dcb09b5b57875f334f61aebed695e2e4193db5e"}

@endpoint GET /repos/{owner}/{repo}/readme
@desc Get a repository README
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {ref: str # The name of the commit/branch/tag. Default: the repositorys default branch.}
@returns(200) {type: str, encoding: str, size: int, name: str, path: str, content: str, sha: str, url: str(uri), git_url: str(uri)?, html_url: str(uri)?, download_url: str(uri)?, _links: map{git: str(uri)?, html: str(uri)?, self: str(uri)}, target: str, submodule_git_url: str} # Response
@errors {304: Not modified, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/readme/{dir}
@desc Get a repository README for a directory
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., dir: str # The alternate path to look for a README file}
@optional {ref: str # The name of the commit/branch/tag. Default: the repositorys default branch.}
@returns(200) {type: str, encoding: str, size: int, name: str, path: str, content: str, sha: str, url: str(uri), git_url: str(uri)?, html_url: str(uri)?, download_url: str(uri)?, _links: map{git: str(uri)?, html: str(uri)?, self: str(uri)}, target: str, submodule_git_url: str} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/releases
@desc List releases
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/releases
@desc Create a release
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., tag_name: str # The name of the tag.}
@optional {target_commitish: str # Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch., name: str # The name of the release., body: str # Text describing the contents of the tag., draft: bool=False # `true` to create a draft (unpublished) release, `false` to create a published one., prerelease: bool=False # `true` to identify the release as a prerelease. `false` to identify the release as a full release., discussion_category_name: str # If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository).", generate_release_notes: bool=False # Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes., make_latest: str(true/false/legacy)=true # Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.}
@returns(201) {url: str(uri), html_url: str(uri), assets_url: str(uri), upload_url: str, tarball_url: str(uri)?, zipball_url: str(uri)?, id: int, node_id: str, tag_name: str, target_commitish: str, name: str?, body: str?, draft: bool, prerelease: bool, immutable: bool, created_at: str(date-time), published_at: str(date-time)?, updated_at: str(date-time)?, author: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assets: [map], body_html: str, body_text: str, mentions_count: int, discussion_url: str(uri), reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}} # Response
@errors {404: Not Found if the discussion category name is invalid, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"tag_name":"v1.0.0","target_commitish":"master","name":"v1.0.0","body":"Description of the release","draft":false,"prerelease":false,"generate_release_notes":false}

@endpoint GET /repos/{owner}/{repo}/releases/assets/{asset_id}
@desc Get a release asset
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., asset_id: int # The unique identifier of the asset.}
@returns(200) {url: str(uri), browser_download_url: str(uri), id: int, node_id: str, name: str, label: str?, state: str, content_type: str, size: int, digest: str?, download_count: int, created_at: str(date-time), updated_at: str(date-time), uploader: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}} # Response
@errors {404: Resource not found, 302: Found}

@endpoint PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}
@desc Update a release asset
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., asset_id: int # The unique identifier of the asset.}
@optional {name: str # The file name of the asset., label: str # An alternate short description of the asset. Used in place of the filename., state: str}
@returns(200) {url: str(uri), browser_download_url: str(uri), id: int, node_id: str, name: str, label: str?, state: str, content_type: str, size: int, digest: str?, download_count: int, created_at: str(date-time), updated_at: str(date-time), uploader: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}} # Response
@example_request {"name":"foo-1.0.0-osx.zip","label":"Mac binary"}

@endpoint DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}
@desc Delete a release asset
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., asset_id: int # The unique identifier of the asset.}
@returns(204) Response

@endpoint POST /repos/{owner}/{repo}/releases/generate-notes
@desc Generate release notes content for a release
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., tag_name: str # The tag name for the release. This can be an existing tag or a new one.}
@optional {target_commitish: str # Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists., previous_tag_name: str # The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release., configuration_file_path: str # Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used.}
@returns(200) {name: str, body: str} # Name and body of generated release notes
@errors {404: Resource not found}
@example_request {"tag_name":"v1.0.0","target_commitish":"main","previous_tag_name":"v0.9.2","configuration_file_path":".github/custom_release_config.yml"}

@endpoint GET /repos/{owner}/{repo}/releases/latest
@desc Get the latest release
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {url: str(uri), html_url: str(uri), assets_url: str(uri), upload_url: str, tarball_url: str(uri)?, zipball_url: str(uri)?, id: int, node_id: str, tag_name: str, target_commitish: str, name: str?, body: str?, draft: bool, prerelease: bool, immutable: bool, created_at: str(date-time), published_at: str(date-time)?, updated_at: str(date-time)?, author: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assets: [map], body_html: str, body_text: str, mentions_count: int, discussion_url: str(uri), reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}} # Response

@endpoint GET /repos/{owner}/{repo}/releases/tags/{tag}
@desc Get a release by tag name
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., tag: str # tag parameter}
@returns(200) {url: str(uri), html_url: str(uri), assets_url: str(uri), upload_url: str, tarball_url: str(uri)?, zipball_url: str(uri)?, id: int, node_id: str, tag_name: str, target_commitish: str, name: str?, body: str?, draft: bool, prerelease: bool, immutable: bool, created_at: str(date-time), published_at: str(date-time)?, updated_at: str(date-time)?, author: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assets: [map], body_html: str, body_text: str, mentions_count: int, discussion_url: str(uri), reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}} # Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/releases/{release_id}
@desc Get a release
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., release_id: int # The unique identifier of the release.}
@returns(200) {url: str(uri), html_url: str(uri), assets_url: str(uri), upload_url: str, tarball_url: str(uri)?, zipball_url: str(uri)?, id: int, node_id: str, tag_name: str, target_commitish: str, name: str?, body: str?, draft: bool, prerelease: bool, immutable: bool, created_at: str(date-time), published_at: str(date-time)?, updated_at: str(date-time)?, author: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assets: [map], body_html: str, body_text: str, mentions_count: int, discussion_url: str(uri), reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}} # **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
@errors {401: Unauthorized}

@endpoint PATCH /repos/{owner}/{repo}/releases/{release_id}
@desc Update a release
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., release_id: int # The unique identifier of the release.}
@optional {tag_name: str # The name of the tag., target_commitish: str # Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch., name: str # The name of the release., body: str # Text describing the contents of the tag., draft: bool # `true` makes the release a draft, and `false` publishes the release., prerelease: bool # `true` to identify the release as a prerelease, `false` to identify the release as a full release., make_latest: str(true/false/legacy)=True # Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version., discussion_category_name: str # If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."}
@returns(200) {url: str(uri), html_url: str(uri), assets_url: str(uri), upload_url: str, tarball_url: str(uri)?, zipball_url: str(uri)?, id: int, node_id: str, tag_name: str, target_commitish: str, name: str?, body: str?, draft: bool, prerelease: bool, immutable: bool, created_at: str(date-time), published_at: str(date-time)?, updated_at: str(date-time)?, author: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, assets: [map], body_html: str, body_text: str, mentions_count: int, discussion_url: str(uri), reactions: map{url: str(uri), total_count: int, +1: int, -1: int, laugh: int, confused: int, heart: int, hooray: int, eyes: int, rocket: int}} # Response
@errors {404: Not Found if the discussion category name is invalid}
@example_request {"tag_name":"v1.0.0","target_commitish":"master","name":"v1.0.0","body":"Description of the release","draft":false,"prerelease":false}

@endpoint DELETE /repos/{owner}/{repo}/releases/{release_id}
@desc Delete a release
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., release_id: int # The unique identifier of the release.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/releases/{release_id}/assets
@desc List release assets
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., release_id: int # The unique identifier of the release.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint POST /repos/{owner}/{repo}/releases/{release_id}/assets
@desc Upload a release asset
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., release_id: int # The unique identifier of the release., name: str}
@optional {label: str}
@returns(201) {url: str(uri), browser_download_url: str(uri), id: int, node_id: str, name: str, label: str?, state: str, content_type: str, size: int, digest: str?, download_count: int, created_at: str(date-time), updated_at: str(date-time), uploader: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}} # Response for successful upload
@errors {422: Response if you upload an asset with the same filename as another uploaded asset}

@endpoint GET /repos/{owner}/{repo}/releases/{release_id}/reactions
@desc List reactions for a release
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., release_id: int # The unique identifier of the release.}
@optional {content: str(+1/laugh/heart/hooray/rocket/eyes) # Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a release., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/releases/{release_id}/reactions
@desc Create reaction for a release
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., release_id: int # The unique identifier of the release., content: str(+1/laugh/heart/hooray/rocket/eyes) # The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the release.}
@returns(200) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Reaction exists
@returns(201) {id: int, node_id: str, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, content: str, created_at: str(date-time)} # Reaction created
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"content":"heart"}

@endpoint DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}
@desc Delete a release reaction
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., release_id: int # The unique identifier of the release., reaction_id: int # The unique identifier of the reaction.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/rules/branches/{branch}
@desc Get rules for a branch
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., branch: str # The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /repos/{owner}/{repo}/rulesets
@desc Get all repository rulesets
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", includes_parents: bool=True # Include rulesets configured at higher levels that apply to this repository, targets: str # A comma-separated list of rule targets to filter by. If provided, only rulesets that apply to the specified targets will be returned. For example, `branch,tag,push`.}
@returns(200) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint POST /repos/{owner}/{repo}/rulesets
@desc Create a repository ruleset
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., name: str # The name of the ruleset., enforcement: str(disabled/active/evaluate) # The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).}
@optional {target: str(branch/tag/push)=branch # The target of the ruleset, bypass_actors: [map{actor_id: int, actor_type!: str, bypass_mode: str}] # The actors that can bypass the rules in this ruleset, conditions: map{ref_name: map} # Parameters for a repository ruleset ref name condition, rules: [map] # An array of rules within the ruleset.}
@returns(201) {id: int, name: str, target: str, source_type: str, source: str, enforcement: str, bypass_actors: [map], current_user_can_bypass: str, node_id: str, _links: map{self: map{href: str}, html: map?{href: str}}, conditions: any?, rules: [map], created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {404: Resource not found, 500: Internal Error}
@example_request {"name":"super cool ruleset","target":"branch","enforcement":"active","bypass_actors":[{"actor_id":234,"actor_type":"Team","bypass_mode":"always"}],"conditions":{"ref_name":{"include":["refs/heads/main","refs/heads/master"],"exclude":["refs/heads/dev*"]}},"rules":[{"type":"commit_author_email_pattern","parameters":{"operator":"contains","pattern":"github"}}]}

@endpoint GET /repos/{owner}/{repo}/rulesets/rule-suites
@desc List repository rule suites
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {ref: str # The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned., time_period: str(hour/day/week/month)=day # The time period to filter by.  For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for rule suites that occurred in the past 7 days (168 hours)., actor_name: str # The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned., rule_suite_result: str(pass/fail/bypass/all)=all # The rule suite results to filter on. When specified, only suites with this result will be returned., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}
@desc Get a repository rule suite
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., rule_suite_id: int # The unique identifier of the rule suite result. To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites) for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites) for organizations.}
@returns(200) {id: int, actor_id: int?, actor_name: str?, before_sha: str, after_sha: str, ref: str, repository_id: int, repository_name: str, pushed_at: str(date-time), result: str, evaluation_result: str?, rule_evaluations: [map]} # Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /repos/{owner}/{repo}/rulesets/{ruleset_id}
@desc Get a repository ruleset
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ruleset_id: int # The ID of the ruleset.}
@optional {includes_parents: bool=True # Include rulesets configured at higher levels that apply to this repository}
@returns(200) {id: int, name: str, target: str, source_type: str, source: str, enforcement: str, bypass_actors: [map], current_user_can_bypass: str, node_id: str, _links: map{self: map{href: str}, html: map?{href: str}}, conditions: any?, rules: [map], created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}
@desc Update a repository ruleset
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ruleset_id: int # The ID of the ruleset.}
@optional {name: str # The name of the ruleset., target: str(branch/tag/push) # The target of the ruleset, enforcement: str(disabled/active/evaluate) # The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise)., bypass_actors: [map{actor_id: int, actor_type!: str, bypass_mode: str}] # The actors that can bypass the rules in this ruleset, conditions: map{ref_name: map} # Parameters for a repository ruleset ref name condition, rules: [map] # An array of rules within the ruleset.}
@returns(200) {id: int, name: str, target: str, source_type: str, source: str, enforcement: str, bypass_actors: [map], current_user_can_bypass: str, node_id: str, _links: map{self: map{href: str}, html: map?{href: str}}, conditions: any?, rules: [map], created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {404: Resource not found, 500: Internal Error}
@example_request {"name":"super cool ruleset","target":"branch","enforcement":"active","bypass_actors":[{"actor_id":234,"actor_type":"Team","bypass_mode":"always"}],"conditions":{"ref_name":{"include":["refs/heads/main","refs/heads/master"],"exclude":["refs/heads/dev*"]}},"rules":[{"type":"commit_author_email_pattern","parameters":{"operator":"contains","pattern":"github"}}]}

@endpoint DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}
@desc Delete a repository ruleset
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ruleset_id: int # The ID of the ruleset.}
@returns(204) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history
@desc Get repository ruleset history
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ruleset_id: int # The ID of the ruleset.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}
@desc Get repository ruleset version
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ruleset_id: int # The ID of the ruleset., version_id: int # The ID of the version}
@returns(200) Response
@errors {404: Resource not found, 500: Internal Error}

@endpoint GET /repos/{owner}/{repo}/secret-scanning/alerts
@desc List secret scanning alerts for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {state: str(open/resolved) # Set to `open` or `resolved` to only list secret scanning alerts in a specific state., secret_type: str # A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types., resolution: str # A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`., assignee: str # Filters alerts by assignee. Use `*` to get all assigned alerts, `none` to get all unassigned alerts, or a GitHub username to get alerts assigned to a specific user., sort: str(created/updated)=created # The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved., direction: str(asc/desc)=desc # The direction to sort the results by., page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string., after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string., validity: str # A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`., is_publicly_leaked: bool=False # A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present., is_multi_repo: bool=False # A boolean value representing whether or not to filter alerts by the multi-repo tag being present., hide_secret: bool=False # A boolean value representing whether or not to hide literal secrets in the results.}
@returns(200) Response
@errors {404: Repository is public or secret scanning is disabled for the repository, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
@desc Get a secret scanning alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.}
@optional {hide_secret: bool=False # A boolean value representing whether or not to hide literal secrets in the results.}
@returns(200) {number: int, created_at: str(date-time), updated_at: str(date-time)?, url: str(uri), html_url: str(uri), locations_url: str(uri), state: str, resolution: str?, resolved_at: str(date-time)?, resolved_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, resolution_comment: str?, secret_type: str, secret_type_display_name: str, secret: str, push_protection_bypassed: bool?, push_protection_bypassed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, push_protection_bypassed_at: str(date-time)?, push_protection_bypass_request_reviewer: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, push_protection_bypass_request_reviewer_comment: str?, push_protection_bypass_request_comment: str?, push_protection_bypass_request_html_url: str(uri)?, validity: str, publicly_leaked: bool?, multi_repo: bool?, is_base64_encoded: bool?, first_location_detected: any?, has_more_locations: bool, assigned_to: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}} # Response
@errors {304: Not modified, 404: Repository is public, or secret scanning is disabled for the repository, or the resource is not found, 503: Service unavailable}

@endpoint PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
@desc Update a secret scanning alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.}
@optional {state: str(open/resolved) # Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`., resolution: str(false_positive/wont_fix/revoked/used_in_tests) # **Required when the `state` is `resolved`.** The reason for resolving the alert., resolution_comment: str # An optional comment when closing or reopening an alert. Cannot be updated or deleted., assignee: str # The username of the user to assign to the alert. Set to `null` to unassign the alert.}
@returns(200) {number: int, created_at: str(date-time), updated_at: str(date-time)?, url: str(uri), html_url: str(uri), locations_url: str(uri), state: str, resolution: str?, resolved_at: str(date-time)?, resolved_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, resolution_comment: str?, secret_type: str, secret_type_display_name: str, secret: str, push_protection_bypassed: bool?, push_protection_bypassed_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, push_protection_bypassed_at: str(date-time)?, push_protection_bypass_request_reviewer: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, push_protection_bypass_request_reviewer_comment: str?, push_protection_bypass_request_comment: str?, push_protection_bypass_request_html_url: str(uri)?, validity: str, publicly_leaked: bool?, multi_repo: bool?, is_base64_encoded: bool?, first_location_detected: any?, has_more_locations: bool, assigned_to: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}} # Response
@errors {400: Bad request, resolution comment is invalid or the resolution was not changed., 404: Repository is public, or secret scanning is disabled for the repository, or the resource is not found, 422: State does not match the resolution or resolution comment, or assignee does not have write access to the repository, 503: Service unavailable}
@example_request {"state":"resolved","resolution":"false_positive"}

@endpoint GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations
@desc List locations for a secret scanning alert
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., alert_number: int # The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Repository is public, or secret scanning is disabled for the repository, or the resource is not found, 503: Service unavailable}

@endpoint POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses
@desc Create a push protection bypass
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., reason: str(false_positive/used_in_tests/will_fix_later) # The reason for bypassing push protection., placeholder_id: str # The ID of the push protection bypass placeholder. This value is returned on any push protected routes.}
@returns(200) {reason: str, expire_at: str(date-time)?, token_type: str} # Response
@errors {403: User does not have enough permissions to perform this action., 404: Placeholder ID not found, or push protection is disabled on this repository., 422: Bad request, input data missing or incorrect., 503: Service unavailable}
@example_request {"reason":"will_fix_later","placeholder_id":"2k4dM4tseyC5lPIsjl5emX9sPNk"}

@endpoint GET /repos/{owner}/{repo}/secret-scanning/scan-history
@desc Get secret scanning scan history for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {incremental_scans: [map], pattern_update_scans: [map], backfill_scans: [map], custom_pattern_backfill_scans: [any]} # Response
@errors {404: Repository does not have GitHub Advanced Security or secret scanning enabled, 503: Service unavailable}

@endpoint GET /repos/{owner}/{repo}/security-advisories
@desc List repository security advisories
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {direction: str(asc/desc)=desc # The direction to sort the results by., sort: str(created/updated/published)=created # The property to sort the results by., before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of advisories to return per page. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", state: str(triage/draft/published/closed) # Filter by state of the repository advisories. Only advisories of this state will be returned.}
@returns(200) Response
@errors {400: Bad Request, 404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/security-advisories
@desc Create a repository security advisory
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., summary: str # A short summary of the advisory., description: str # A detailed description of what the advisory impacts., vulnerabilities: [map{package!: map, vulnerable_version_range: str, patched_versions: str, vulnerable_functions: [str]}] # A product affected by the vulnerability detailed in a repository security advisory.}
@optional {cve_id: str # The Common Vulnerabilities and Exposures (CVE) ID., cwe_ids: [str] # A list of Common Weakness Enumeration (CWE) IDs., credits: [map{login!: str, type!: str}] # A list of users receiving credit for their participation in the security advisory., severity: str(critical/high/medium/low) # The severity of the advisory. You must choose between setting this field or `cvss_vector_string`., cvss_vector_string: str # The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`., start_private_fork: bool=False # Whether to create a temporary private fork of the repository to collaborate on a fix.}
@returns(201) {ghsa_id: str, cve_id: str?, url: str(uri), html_url: str(uri), summary: str, description: str?, severity: str?, author: any?, publisher: any?, identifiers: [map], state: str, created_at: str(date-time)?, updated_at: str(date-time)?, published_at: str(date-time)?, closed_at: str(date-time)?, withdrawn_at: str(date-time)?, submission: map?{accepted: bool}, vulnerabilities: [map]?, cvss: map?{vector_string: str?, score: num?}, cvss_severities: map?{cvss_v3: map?{vector_string: str?, score: num?}, cvss_v4: map?{vector_string: str?, score: num?}}, cwes: [map]?, cwe_ids: [str]?, credits: [map]?, credits_detailed: [map]?, collaborating_users: [map]?, collaborating_teams: [map]?, private_fork: any?} # Response
@errors {403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"summary":"A new important advisory","description":"A more in-depth description of what the problem is.","severity":"high","cve_id":null,"vulnerabilities":[{"package":{"name":"a-package","ecosystem":"npm"},"vulnerable_version_range":"< 1.0.0","patched_versions":"1.0.0","vulnerable_functions":["important_function"]}],"cwe_ids":["CWE-1101","CWE-20"],"credits":[{"login":"monalisa","type":"reporter"},{"login":"octocat","type":"analyst"}]}

@endpoint POST /repos/{owner}/{repo}/security-advisories/reports
@desc Privately report a security vulnerability
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., summary: str # A short summary of the advisory., description: str # A detailed description of what the advisory impacts.}
@optional {vulnerabilities: [map{package!: map, vulnerable_version_range: str, patched_versions: str, vulnerable_functions: [str]}] # An array of products affected by the vulnerability detailed in a repository security advisory., cwe_ids: [str] # A list of Common Weakness Enumeration (CWE) IDs., severity: str(critical/high/medium/low) # The severity of the advisory. You must choose between setting this field or `cvss_vector_string`., cvss_vector_string: str # The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`., start_private_fork: bool=False # Whether to create a temporary private fork of the repository to collaborate on a fix.}
@returns(201) {ghsa_id: str, cve_id: str?, url: str(uri), html_url: str(uri), summary: str, description: str?, severity: str?, author: any?, publisher: any?, identifiers: [map], state: str, created_at: str(date-time)?, updated_at: str(date-time)?, published_at: str(date-time)?, closed_at: str(date-time)?, withdrawn_at: str(date-time)?, submission: map?{accepted: bool}, vulnerabilities: [map]?, cvss: map?{vector_string: str?, score: num?}, cvss_severities: map?{cvss_v3: map?{vector_string: str?, score: num?}, cvss_v4: map?{vector_string: str?, score: num?}}, cwes: [map]?, cwe_ids: [str]?, credits: [map]?, credits_detailed: [map]?, collaborating_users: [map]?, collaborating_teams: [map]?, private_fork: any?} # Response
@errors {403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"summary":"A newly discovered vulnerability","description":"A more in-depth description of what the problem is.","severity":"high","vulnerabilities":[{"package":{"name":"a-package","ecosystem":"npm"},"vulnerable_version_range":"< 1.0.0","patched_versions":"1.0.0","vulnerable_functions":["important_function"]}],"cwe_ids":["CWE-123"]}

@endpoint GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}
@desc Get a repository security advisory
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ghsa_id: str # The GHSA (GitHub Security Advisory) identifier of the advisory.}
@returns(200) {ghsa_id: str, cve_id: str?, url: str(uri), html_url: str(uri), summary: str, description: str?, severity: str?, author: any?, publisher: any?, identifiers: [map], state: str, created_at: str(date-time)?, updated_at: str(date-time)?, published_at: str(date-time)?, closed_at: str(date-time)?, withdrawn_at: str(date-time)?, submission: map?{accepted: bool}, vulnerabilities: [map]?, cvss: map?{vector_string: str?, score: num?}, cvss_severities: map?{cvss_v3: map?{vector_string: str?, score: num?}, cvss_v4: map?{vector_string: str?, score: num?}}, cwes: [map]?, cwe_ids: [str]?, credits: [map]?, credits_detailed: [map]?, collaborating_users: [map]?, collaborating_teams: [map]?, private_fork: any?} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}
@desc Update a repository security advisory
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ghsa_id: str # The GHSA (GitHub Security Advisory) identifier of the advisory.}
@optional {summary: str # A short summary of the advisory., description: str # A detailed description of what the advisory impacts., cve_id: str # The Common Vulnerabilities and Exposures (CVE) ID., vulnerabilities: [map{package!: map, vulnerable_version_range: str, patched_versions: str, vulnerable_functions: [str]}] # A product affected by the vulnerability detailed in a repository security advisory., cwe_ids: [str] # A list of Common Weakness Enumeration (CWE) IDs., credits: [map{login!: str, type!: str}] # A list of users receiving credit for their participation in the security advisory., severity: str(critical/high/medium/low) # The severity of the advisory. You must choose between setting this field or `cvss_vector_string`., cvss_vector_string: str # The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`., state: str(published/closed/draft) # The state of the advisory., collaborating_users: [str] # A list of usernames who have been granted write access to the advisory., collaborating_teams: [str] # A list of team slugs which have been granted write access to the advisory.}
@returns(200) {ghsa_id: str, cve_id: str?, url: str(uri), html_url: str(uri), summary: str, description: str?, severity: str?, author: any?, publisher: any?, identifiers: [map], state: str, created_at: str(date-time)?, updated_at: str(date-time)?, published_at: str(date-time)?, closed_at: str(date-time)?, withdrawn_at: str(date-time)?, submission: map?{accepted: bool}, vulnerabilities: [map]?, cvss: map?{vector_string: str?, score: num?}, cvss_severities: map?{cvss_v3: map?{vector_string: str?, score: num?}, cvss_v4: map?{vector_string: str?, score: num?}}, cwes: [map]?, cwe_ids: [str]?, credits: [map]?, credits_detailed: [map]?, collaborating_users: [map]?, collaborating_teams: [map]?, private_fork: any?} # Response
@errors {403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"severity":"critical","state":"published"}

@endpoint POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve
@desc Request a CVE for a repository security advisory
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ghsa_id: str # The GHSA (GitHub Security Advisory) identifier of the advisory.}
@returns(202) Accepted
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks
@desc Create a temporary private fork
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ghsa_id: str # The GHSA (GitHub Security Advisory) identifier of the advisory.}
@returns(202) {id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time), created_at: str(date-time), updated_at: str(date-time), permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, allow_rebase_merge: bool, template_repository: map?{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, temp_clone_token: str?, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, organization: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, parent: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, source: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, forks: int, master_branch: str, open_issues: int, watchers: int, anonymous_access_enabled: bool, code_of_conduct: map{url: str(uri), key: str, name: str, html_url: str(uri)?}, security_and_analysis: map?{advanced_security: map{status: str}, code_security: map{status: str}, dependabot_security_updates: map{status: str}, secret_scanning: map{status: str}, secret_scanning_push_protection: map{status: str}, secret_scanning_non_provider_patterns: map{status: str}, secret_scanning_ai_detection: map{status: str}, secret_scanning_delegated_alert_dismissal: map{status: str}}, custom_properties: map} # Response
@errors {400: Bad Request, 422: Validation failed, or the endpoint has been spammed., 403: Forbidden, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/stargazers
@desc List stargazers
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /repos/{owner}/{repo}/stats/code_frequency
@desc Get the weekly commit activity
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
@returns(202) Accepted
@returns(204) A header with no content is returned.
@errors {422: Repository contains more than 10,000 commits}

@endpoint GET /repos/{owner}/{repo}/stats/commit_activity
@desc Get the last year of commit activity
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response
@returns(202) Accepted
@returns(204) A header with no content is returned.

@endpoint GET /repos/{owner}/{repo}/stats/contributors
@desc Get all contributor commit activity
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response
@returns(202) Accepted
@returns(204) A header with no content is returned.

@endpoint GET /repos/{owner}/{repo}/stats/participation
@desc Get the weekly commit count
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {all: [int], owner: [int]} # The array order is oldest week (index 0) to most recent week.
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/stats/punch_card
@desc Get the hourly commit count for each day
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
@returns(204) A header with no content is returned.

@endpoint POST /repos/{owner}/{repo}/statuses/{sha}
@desc Create a commit status
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., sha: str, state: str(error/failure/pending/success) # The state of the status.}
@optional {target_url: str # The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.   For example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:   `http://ci.example.com/user/repo/build/sha`, description: str # A short description of the status., context: str=default # A string label to differentiate this status from the status of other systems. This field is case-insensitive.}
@returns(201) {url: str, avatar_url: str?, id: int, node_id: str, state: str, description: str?, target_url: str?, context: str, created_at: str, updated_at: str, creator: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}} # Response
@example_request {"state":"success","target_url":"https://example.com/build/status","description":"The build succeeded!","context":"continuous-integration/jenkins"}

@endpoint GET /repos/{owner}/{repo}/subscribers
@desc List watchers
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /repos/{owner}/{repo}/subscription
@desc Get a repository subscription
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {subscribed: bool, ignored: bool, reason: str?, created_at: str(date-time), url: str(uri), repository_url: str(uri)} # if you subscribe to the repository
@errors {404: Not Found if you don't subscribe to the repository, 403: Forbidden}

@endpoint PUT /repos/{owner}/{repo}/subscription
@desc Set a repository subscription
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {subscribed: bool # Determines if notifications should be received from this repository., ignored: bool # Determines if all notifications should be blocked from this repository.}
@returns(200) {subscribed: bool, ignored: bool, reason: str?, created_at: str(date-time), url: str(uri), repository_url: str(uri)} # Response
@example_request {"subscribed":true,"ignored":false}

@endpoint DELETE /repos/{owner}/{repo}/subscription
@desc Delete a repository subscription
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/tags
@desc List repository tags
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /repos/{owner}/{repo}/tags/protection
@desc Closing down - List tag protection states for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint POST /repos/{owner}/{repo}/tags/protection
@desc Closing down - Create a tag protection state for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., pattern: str # An optional glob pattern to match against when enforcing tag protection.}
@returns(201) {id: int, created_at: str, updated_at: str, enabled: bool, pattern: str} # Response
@errors {403: Forbidden, 404: Resource not found}
@example_request {"pattern":"v1.*"}

@endpoint DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}
@desc Closing down - Delete a tag protection state for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., tag_protection_id: int # The unique identifier of the tag protection.}
@returns(204) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/tarball/{ref}
@desc Download a repository archive (tar)
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str}
@errors {302: Response}

@endpoint GET /repos/{owner}/{repo}/teams
@desc List repository teams
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /repos/{owner}/{repo}/topics
@desc Get all repository topics
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {names: [str]} # Response
@errors {404: Resource not found}

@endpoint PUT /repos/{owner}/{repo}/topics
@desc Replace all repository topics
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., names: [str] # An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` will be saved as lowercase.}
@returns(200) {names: [str]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"names":["octocat","atom","electron","api"]}

@endpoint GET /repos/{owner}/{repo}/traffic/clones
@desc Get repository clones
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per: str(day/week)=day # The time frame to display results for.}
@returns(200) {count: int, uniques: int, clones: [map]} # Response
@errors {403: Forbidden}

@endpoint GET /repos/{owner}/{repo}/traffic/popular/paths
@desc Get top referral paths
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response
@errors {403: Forbidden}

@endpoint GET /repos/{owner}/{repo}/traffic/popular/referrers
@desc Get top referral sources
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) Response
@errors {403: Forbidden}

@endpoint GET /repos/{owner}/{repo}/traffic/views
@desc Get page views
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {per: str(day/week)=day # The time frame to display results for.}
@returns(200) {count: int, uniques: int, views: [map]} # Response
@errors {403: Forbidden}

@endpoint POST /repos/{owner}/{repo}/transfer
@desc Transfer a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., new_owner: str # The username or organization name the repository will be transferred to.}
@optional {new_name: str # The new name to be given to the repository., team_ids: [int] # ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.}
@returns(202) {id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map{status: str}, code_security: map{status: str}, dependabot_security_updates: map{status: str}, secret_scanning: map{status: str}, secret_scanning_push_protection: map{status: str}, secret_scanning_non_provider_patterns: map{status: str}, secret_scanning_ai_detection: map{status: str}, secret_scanning_delegated_alert_dismissal: map{status: str}}, custom_properties: map} # Response
@example_request {"new_owner":"github","team_ids":[12,345],"new_name":"octorepo"}

@endpoint GET /repos/{owner}/{repo}/vulnerability-alerts
@desc Check if vulnerability alerts are enabled for a repository
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response if repository is enabled with vulnerability alerts
@errors {404: Not Found if repository is not enabled with vulnerability alerts}

@endpoint PUT /repos/{owner}/{repo}/vulnerability-alerts
@desc Enable vulnerability alerts
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response

@endpoint DELETE /repos/{owner}/{repo}/vulnerability-alerts
@desc Disable vulnerability alerts
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response

@endpoint GET /repos/{owner}/{repo}/zipball/{ref}
@desc Download a repository archive (zip)
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive., ref: str}
@errors {302: Response}

@endpoint POST /repos/{template_owner}/{template_repo}/generate
@desc Create a repository using a template
@required {template_owner: str # The account owner of the template repository. The name is not case sensitive., template_repo: str # The name of the template repository without the `.git` extension. The name is not case sensitive., name: str # The name of the new repository.}
@optional {owner: str # The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization., description: str # A short description of the new repository., include_all_branches: bool=False # Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`., private: bool=False # Either `true` to create a new private repository or `false` to create a new public one.}
@returns(201) {id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time), created_at: str(date-time), updated_at: str(date-time), permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, allow_rebase_merge: bool, template_repository: map?{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, temp_clone_token: str?, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, organization: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, parent: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, source: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, forks: int, master_branch: str, open_issues: int, watchers: int, anonymous_access_enabled: bool, code_of_conduct: map{url: str(uri), key: str, name: str, html_url: str(uri)?}, security_and_analysis: map?{advanced_security: map{status: str}, code_security: map{status: str}, dependabot_security_updates: map{status: str}, secret_scanning: map{status: str}, secret_scanning_push_protection: map{status: str}, secret_scanning_non_provider_patterns: map{status: str}, secret_scanning_ai_detection: map{status: str}, secret_scanning_delegated_alert_dismissal: map{status: str}}, custom_properties: map} # Response
@example_request {"owner":"octocat","name":"Hello-World","description":"This is your first repository","include_all_branches":false,"private":false}

@endgroup

@group repositories
@endpoint GET /repositories
@desc List public repositories
@optional {since: int # A repository ID. Only return repositories with an ID greater than this ID.}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified}

@endgroup

@group search
@endpoint GET /search/code
@desc Search code
@required {q: str # The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching code](https://docs.github.com/search-github/searching-on-github/searching-code)" for a detailed list of qualifiers.}
@optional {sort: str # **This field is closing down.** Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results), order: str(desc/asc)=desc # **This field is closing down.** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, incomplete_results: bool, items: [map]} # Response
@errors {304: Not modified, 503: Service unavailable, 422: Validation failed, or the endpoint has been spammed., 403: Forbidden}

@endpoint GET /search/commits
@desc Search commits
@required {q: str # The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching commits](https://docs.github.com/search-github/searching-on-github/searching-commits)" for a detailed list of qualifiers.}
@optional {sort: str(author-date/committer-date) # Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results), order: str(desc/asc)=desc # Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, incomplete_results: bool, items: [map]} # Response
@errors {304: Not modified}

@endpoint GET /search/issues
@desc Search issues and pull requests
@required {q: str # The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching issues and pull requests](https://docs.github.com/search-github/searching-on-github/searching-issues-and-pull-requests)" for a detailed list of qualifiers.}
@optional {sort: str(comments/reactions/reactions-+1/reactions--1/reactions-smile/reactions-thinking_face/reactions-heart/reactions-tada/interactions/created/updated) # Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results), order: str(desc/asc)=desc # Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", advanced_search: str # Set to `true` to use advanced search. Example: `http://api.github.com/search/issues?q={query}&advanced_search=true`}
@returns(200) {total_count: int, incomplete_results: bool, items: [map]} # Response
@errors {503: Service unavailable, 422: Validation failed, or the endpoint has been spammed., 304: Not modified, 403: Forbidden}

@endpoint GET /search/labels
@desc Search labels
@required {repository_id: int # The id of the repository., q: str # The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query).}
@optional {sort: str(created/updated) # Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results), order: str(desc/asc)=desc # Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, incomplete_results: bool, items: [map]} # Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /search/repositories
@desc Search repositories
@required {q: str # The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.}
@optional {sort: str(stars/forks/help-wanted-issues/updated) # Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results), order: str(desc/asc)=desc # Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, incomplete_results: bool, items: [map]} # Response
@errors {503: Service unavailable, 422: Validation failed, or the endpoint has been spammed., 304: Not modified}

@endpoint GET /search/topics
@desc Search topics
@required {q: str # The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query).}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, incomplete_results: bool, items: [map]} # Response
@errors {304: Not modified}

@endpoint GET /search/users
@desc Search users
@required {q: str # The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching users](https://docs.github.com/search-github/searching-on-github/searching-users)" for a detailed list of qualifiers.}
@optional {sort: str(followers/repositories/joined) # Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results), order: str(desc/asc)=desc # Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, incomplete_results: bool, items: [map]} # Response
@errors {304: Not modified, 503: Service unavailable, 422: Validation failed, or the endpoint has been spammed.}

@endgroup

@group teams
@endpoint GET /teams/{team_id}
@desc Get a team (Legacy)
@required {team_id: int # The unique identifier of the team.}
@returns(200) {id: int, node_id: str, url: str(uri), html_url: str(uri), name: str, slug: str, description: str?, privacy: str, notification_setting: str, permission: str, members_url: str, repositories_url: str(uri), parent: map?{id: int, node_id: str, url: str(uri), members_url: str, name: str, description: str?, permission: str, privacy: str, notification_setting: str, html_url: str(uri), repositories_url: str(uri), slug: str, ldap_dn: str, type: str, organization_id: int, enterprise_id: int}, members_count: int, repos_count: int, created_at: str(date-time), updated_at: str(date-time), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?, name: str, company: str, blog: str(uri), location: str, email: str(email), twitter_username: str?, is_verified: bool, has_organization_projects: bool, has_repository_projects: bool, public_repos: int, public_gists: int, followers: int, following: int, html_url: str(uri), created_at: str(date-time), type: str, total_private_repos: int, owned_private_repos: int, private_gists: int?, disk_usage: int?, collaborators: int?, billing_email: str(email)?, plan: map{name: str, space: int, private_repos: int, filled_seats: int, seats: int}, default_repository_permission: str?, members_can_create_repositories: bool?, two_factor_requirement_enabled: bool?, members_allowed_repository_creation_type: str, members_can_create_public_repositories: bool, members_can_create_private_repositories: bool, members_can_create_internal_repositories: bool, members_can_create_pages: bool, members_can_create_public_pages: bool, members_can_create_private_pages: bool, members_can_fork_private_repositories: bool?, web_commit_signoff_required: bool, updated_at: str(date-time), archived_at: str(date-time)?}, ldap_dn: str, type: str, organization_id: int, enterprise_id: int} # Response
@errors {404: Resource not found}

@endpoint PATCH /teams/{team_id}
@desc Update a team (Legacy)
@required {team_id: int # The unique identifier of the team., name: str # The name of the team.}
@optional {description: str # The description of the team., privacy: str(secret/closed) # The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:   **For a non-nested team:**    * `secret` - only visible to organization owners and members of this team.    * `closed` - visible to all members of this organization.   **For a parent or child team:**    * `closed` - visible to all members of this organization., notification_setting: str(notifications_enabled/notifications_disabled) # The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are:   * `notifications_enabled` - team members receive notifications when the team is @mentioned.    * `notifications_disabled` - no one receives notifications., permission: str(pull/push/admin)=pull # **Closing down notice**. The permission that new repositories will be added to the team with when none is specified., parent_team_id: int # The ID of a team to set as the parent team.}
@returns(200) {id: int, node_id: str, url: str(uri), html_url: str(uri), name: str, slug: str, description: str?, privacy: str, notification_setting: str, permission: str, members_url: str, repositories_url: str(uri), parent: map?{id: int, node_id: str, url: str(uri), members_url: str, name: str, description: str?, permission: str, privacy: str, notification_setting: str, html_url: str(uri), repositories_url: str(uri), slug: str, ldap_dn: str, type: str, organization_id: int, enterprise_id: int}, members_count: int, repos_count: int, created_at: str(date-time), updated_at: str(date-time), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?, name: str, company: str, blog: str(uri), location: str, email: str(email), twitter_username: str?, is_verified: bool, has_organization_projects: bool, has_repository_projects: bool, public_repos: int, public_gists: int, followers: int, following: int, html_url: str(uri), created_at: str(date-time), type: str, total_private_repos: int, owned_private_repos: int, private_gists: int?, disk_usage: int?, collaborators: int?, billing_email: str(email)?, plan: map{name: str, space: int, private_repos: int, filled_seats: int, seats: int}, default_repository_permission: str?, members_can_create_repositories: bool?, two_factor_requirement_enabled: bool?, members_allowed_repository_creation_type: str, members_can_create_public_repositories: bool, members_can_create_private_repositories: bool, members_can_create_internal_repositories: bool, members_can_create_pages: bool, members_can_create_public_pages: bool, members_can_create_private_pages: bool, members_can_fork_private_repositories: bool?, web_commit_signoff_required: bool, updated_at: str(date-time), archived_at: str(date-time)?}, ldap_dn: str, type: str, organization_id: int, enterprise_id: int} # Response when the updated information already exists
@returns(201) {id: int, node_id: str, url: str(uri), html_url: str(uri), name: str, slug: str, description: str?, privacy: str, notification_setting: str, permission: str, members_url: str, repositories_url: str(uri), parent: map?{id: int, node_id: str, url: str(uri), members_url: str, name: str, description: str?, permission: str, privacy: str, notification_setting: str, html_url: str(uri), repositories_url: str(uri), slug: str, ldap_dn: str, type: str, organization_id: int, enterprise_id: int}, members_count: int, repos_count: int, created_at: str(date-time), updated_at: str(date-time), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?, name: str, company: str, blog: str(uri), location: str, email: str(email), twitter_username: str?, is_verified: bool, has_organization_projects: bool, has_repository_projects: bool, public_repos: int, public_gists: int, followers: int, following: int, html_url: str(uri), created_at: str(date-time), type: str, total_private_repos: int, owned_private_repos: int, private_gists: int?, disk_usage: int?, collaborators: int?, billing_email: str(email)?, plan: map{name: str, space: int, private_repos: int, filled_seats: int, seats: int}, default_repository_permission: str?, members_can_create_repositories: bool?, two_factor_requirement_enabled: bool?, members_allowed_repository_creation_type: str, members_can_create_public_repositories: bool, members_can_create_private_repositories: bool, members_can_create_internal_repositories: bool, members_can_create_pages: bool, members_can_create_public_pages: bool, members_can_create_private_pages: bool, members_can_fork_private_repositories: bool?, web_commit_signoff_required: bool, updated_at: str(date-time), archived_at: str(date-time)?}, ldap_dn: str, type: str, organization_id: int, enterprise_id: int} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 403: Forbidden}
@example_request {"name":"new team name","description":"new team description","privacy":"closed","notification_setting":"notifications_enabled"}

@endpoint DELETE /teams/{team_id}
@desc Delete a team (Legacy)
@required {team_id: int # The unique identifier of the team.}
@returns(204) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /teams/{team_id}/invitations
@desc List pending team invitations (Legacy)
@required {team_id: int # The unique identifier of the team.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /teams/{team_id}/members
@desc List team members (Legacy)
@required {team_id: int # The unique identifier of the team.}
@optional {role: str(member/maintainer/all)=all # Filters members returned by their role in the team., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /teams/{team_id}/members/{username}
@desc Get team member (Legacy)
@required {team_id: int # The unique identifier of the team., username: str # The handle for the GitHub user account.}
@returns(204) if user is a member
@errors {404: if user is not a member}

@endpoint PUT /teams/{team_id}/members/{username}
@desc Add team member (Legacy)
@required {team_id: int # The unique identifier of the team., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {404: Not Found if team synchronization is set up, 422: Unprocessable Entity if you attempt to add an organization to a team or you attempt to add a user to a team when they are not a member of at least one other team in the same organization, 403: Forbidden}

@endpoint DELETE /teams/{team_id}/members/{username}
@desc Remove team member (Legacy)
@required {team_id: int # The unique identifier of the team., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {404: Not Found if team synchronization is setup}

@endpoint GET /teams/{team_id}/memberships/{username}
@desc Get team membership for a user (Legacy)
@required {team_id: int # The unique identifier of the team., username: str # The handle for the GitHub user account.}
@returns(200) {url: str(uri), role: str, state: str} # Response
@errors {404: Resource not found}

@endpoint PUT /teams/{team_id}/memberships/{username}
@desc Add or update team membership for a user (Legacy)
@required {team_id: int # The unique identifier of the team., username: str # The handle for the GitHub user account.}
@optional {role: str(member/maintainer)=member # The role that this user should have in the team.}
@returns(200) {url: str(uri), role: str, state: str} # Response
@errors {403: Forbidden if team synchronization is set up, 422: Unprocessable Entity if you attempt to add an organization to a team, 404: Resource not found}
@example_request {"role":"member"}

@endpoint DELETE /teams/{team_id}/memberships/{username}
@desc Remove team membership for a user (Legacy)
@required {team_id: int # The unique identifier of the team., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {403: if team synchronization is set up}

@endpoint GET /teams/{team_id}/repos
@desc List team repositories (Legacy)
@required {team_id: int # The unique identifier of the team.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /teams/{team_id}/repos/{owner}/{repo}
@desc Check team permissions for a repository (Legacy)
@required {team_id: int # The unique identifier of the team., owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(200) {id: int, node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, role_name: str, owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, open_issues: int, watchers: int, master_branch: str} # Alternative response with extra repository information
@returns(204) Response if repository is managed by this team
@errors {404: Not Found if repository is not managed by this team}

@endpoint PUT /teams/{team_id}/repos/{owner}/{repo}
@desc Add or update team repository permissions (Legacy)
@required {team_id: int # The unique identifier of the team., owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@optional {permission: str(pull/push/admin) # The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.}
@returns(204) Response
@errors {403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"permission":"push"}

@endpoint DELETE /teams/{team_id}/repos/{owner}/{repo}
@desc Remove a repository from a team (Legacy)
@required {team_id: int # The unique identifier of the team., owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response

@endpoint GET /teams/{team_id}/teams
@desc List child teams (Legacy)
@required {team_id: int # The unique identifier of the team.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) if child teams exist
@errors {404: Resource not found, 403: Forbidden, 422: Validation failed, or the endpoint has been spammed.}

@endgroup

@group user
@endpoint GET /user
@desc Get the authenticated user
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint PATCH /user
@desc Update the authenticated user
@optional {name: str # The new name of the user., email: str # The publicly visible email address of the user., blog: str # The new blog URL of the user., twitter_username: str # The new Twitter username of the user., company: str # The new company of the user., location: str # The new location of the user., hireable: bool # The new hiring availability of the user., bio: str # The new short biography of the user.}
@returns(200) {login: str, id: int(int64), user_view_type: str, node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, name: str?, company: str?, blog: str?, location: str?, email: str(email)?, notification_email: str(email)?, hireable: bool?, bio: str?, twitter_username: str?, public_repos: int, public_gists: int, followers: int, following: int, created_at: str(date-time), updated_at: str(date-time), private_gists: int, total_private_repos: int, owned_private_repos: int, disk_usage: int, collaborators: int, two_factor_authentication: bool, plan: map{collaborators: int, name: str, space: int, private_repos: int}, business_plus: bool, ldap_dn: str} # Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"blog":"https://github.com/blog","name":"monalisa octocat"}

@endpoint GET /user/blocks
@desc List users blocked by the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/blocks/{username}
@desc Check if a user is blocked by the authenticated user
@required {username: str # The handle for the GitHub user account.}
@returns(204) If the user is blocked
@errors {404: If the user is not blocked, 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint PUT /user/blocks/{username}
@desc Block a user
@required {username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication, 422: Validation failed, or the endpoint has been spammed.}

@endpoint DELETE /user/blocks/{username}
@desc Unblock a user
@required {username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication, 404: Resource not found}

@endpoint GET /user/codespaces
@desc List codespaces for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", repository_id: int # ID of the Repository to filter on}
@returns(200) {total_count: int, codespaces: [map]} # Response
@errors {304: Not modified, 500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint POST /user/codespaces
@desc Create a codespace for the authenticated user
@returns(201) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response when the codespace was successfully created
@returns(202) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response when the codespace creation partially failed but is being retried in the background
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 503: Service unavailable}
@example_request {"repository_id":1,"ref":"main","geo":"UsWest"}

@endpoint GET /user/codespaces/secrets
@desc List secrets for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, secrets: [map]} # Response

@endpoint GET /user/codespaces/secrets/public-key
@desc Get public key for the authenticated user
@returns(200) {key_id: str, key: str} # Response

@endpoint GET /user/codespaces/secrets/{secret_name}
@desc Get a secret for the authenticated user
@required {secret_name: str # The name of the secret.}
@returns(200) {name: str, created_at: str(date-time), updated_at: str(date-time), visibility: str, selected_repositories_url: str(uri)} # Response

@endpoint PUT /user/codespaces/secrets/{secret_name}
@desc Create or update a secret for the authenticated user
@required {secret_name: str # The name of the secret., key_id: str # ID of the key you used to encrypt the secret.}
@optional {encrypted_value: str # Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user) endpoint., selected_repository_ids: [any] # An array of repository ids that can access the user secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Set selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#set-selected-repositories-for-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.}
@returns(201) Response after successfully creating a secret
@returns(204) Response after successfully updating a secret
@errors {422: Validation failed, or the endpoint has been spammed., 404: Resource not found}
@example_request {"encrypted_value":"c2VjcmV0","key_id":"012345678912345678","selected_repository_ids":["1234567","2345678"]}

@endpoint DELETE /user/codespaces/secrets/{secret_name}
@desc Delete a secret for the authenticated user
@required {secret_name: str # The name of the secret.}
@returns(204) Response

@endpoint GET /user/codespaces/secrets/{secret_name}/repositories
@desc List selected repositories for a user secret
@required {secret_name: str # The name of the secret.}
@returns(200) {total_count: int, repositories: [map]} # Response
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 500: Internal Error}

@endpoint PUT /user/codespaces/secrets/{secret_name}/repositories
@desc Set selected repositories for a user secret
@required {secret_name: str # The name of the secret., selected_repository_ids: [int] # An array of repository ids for which a codespace can access the secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Add a selected repository to a user secret](https://docs.github.com/rest/codespaces/secrets#add-a-selected-repository-to-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.}
@returns(204) No Content when repositories were added to the selected list
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 500: Internal Error}
@example_request {"selected_repository_ids":["1296269","1296280"]}

@endpoint PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}
@desc Add a selected repository to a user secret
@required {secret_name: str # The name of the secret., repository_id: int}
@returns(204) No Content when repository was added to the selected list
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 500: Internal Error}

@endpoint DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}
@desc Remove a selected repository from a user secret
@required {secret_name: str # The name of the secret., repository_id: int}
@returns(204) No Content when repository was removed from the selected list
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 500: Internal Error}

@endpoint GET /user/codespaces/{codespace_name}
@desc Get a codespace for the authenticated user
@required {codespace_name: str # The name of the codespace.}
@returns(200) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response
@errors {304: Not modified, 500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint PATCH /user/codespaces/{codespace_name}
@desc Update a codespace for the authenticated user
@required {codespace_name: str # The name of the codespace.}
@optional {machine: str # A valid machine to transition this codespace to., display_name: str # Display name for this codespace, recent_folders: [str] # Recently opened folders inside the codespace. It is currently used by the clients to determine the folder path to load the codespace in.}
@returns(200) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found}
@example_request {"machine":"standardLinux"}

@endpoint DELETE /user/codespaces/{codespace_name}
@desc Delete a codespace for the authenticated user
@required {codespace_name: str # The name of the codespace.}
@returns(202) Accepted
@errors {304: Not modified, 500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint POST /user/codespaces/{codespace_name}/exports
@desc Export a codespace for the authenticated user
@required {codespace_name: str # The name of the codespace.}
@returns(202) {state: str?, completed_at: str(date-time)?, branch: str?, sha: str?, id: str, export_url: str, html_url: str?} # Response
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /user/codespaces/{codespace_name}/exports/{export_id}
@desc Get details about a codespace export
@required {codespace_name: str # The name of the codespace., export_id: str # The ID of the export operation, or `latest`. Currently only `latest` is currently supported.}
@returns(200) {state: str?, completed_at: str(date-time)?, branch: str?, sha: str?, id: str, export_url: str, html_url: str?} # Response
@errors {404: Resource not found}

@endpoint GET /user/codespaces/{codespace_name}/machines
@desc List machine types for a codespace
@required {codespace_name: str # The name of the codespace.}
@returns(200) {total_count: int, machines: [map]} # Response
@errors {304: Not modified, 500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint POST /user/codespaces/{codespace_name}/publish
@desc Create a repository from an unpublished codespace
@required {codespace_name: str # The name of the codespace.}
@optional {name: str # A name for the new repository., private: bool=False # Whether the new repository should be private.}
@returns(201) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time), created_at: str(date-time), updated_at: str(date-time), permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, allow_rebase_merge: bool, template_repository: map?{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, temp_clone_token: str?, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, organization: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, parent: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, source: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?, forks: int, permissions: map, owner: map, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map}, forks: int, master_branch: str, open_issues: int, watchers: int, anonymous_access_enabled: bool, code_of_conduct: map{url: str(uri), key: str, name: str, html_url: str(uri)?}, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?} # Response
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"repository":"monalisa-octocat-hello-world-g4wpq6h95q","private":false}

@endpoint POST /user/codespaces/{codespace_name}/start
@desc Start a codespace for the authenticated user
@required {codespace_name: str # The name of the codespace.}
@returns(200) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response
@errors {304: Not modified, 500: Internal Error, 400: Bad Request, 401: Requires authentication, 402: Payment required, 403: Forbidden, 404: Resource not found, 409: Conflict}

@endpoint POST /user/codespaces/{codespace_name}/stop
@desc Stop a codespace for the authenticated user
@required {codespace_name: str # The name of the codespace.}
@returns(200) {id: int(int64), name: str, display_name: str?, environment_id: str?, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, billable_owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, machine: map?{name: str, display_name: str, operating_system: str, storage_in_bytes: int, memory_in_bytes: int, cpus: int, prebuild_availability: str?}, devcontainer_path: str?, prebuild: bool?, created_at: str(date-time), updated_at: str(date-time), last_used_at: str(date-time), state: str, url: str(uri), git_status: map{ahead: int, behind: int, has_unpushed_changes: bool, has_uncommitted_changes: bool, ref: str}, location: str, idle_timeout_minutes: int?, web_url: str(uri), machines_url: str(uri), start_url: str(uri), stop_url: str(uri), publish_url: str(uri)?, pulls_url: str(uri)?, recent_folders: [str], runtime_constraints: map{allowed_port_privacy_settings: [str]?}, pending_operation: bool?, pending_operation_disabled_reason: str?, idle_timeout_notice: str?, retention_period_minutes: int?, retention_expires_at: str(date-time)?, last_known_stop_notice: str?} # Response
@errors {500: Internal Error, 401: Requires authentication, 403: Forbidden, 404: Resource not found}

@endpoint GET /user/docker/conflicts
@desc Get list of conflicting packages during Docker migration for authenticated-user
@returns(200) Response

@endpoint PATCH /user/email/visibility
@desc Set primary email visibility for the authenticated user
@required {visibility: str(public/private) # Denotes whether an email is publicly visible.}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"visibility":"private"}

@endpoint GET /user/emails
@desc List email addresses for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /user/emails
@desc Add an email address for the authenticated user
@returns(201) Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}
@example_request {"emails":["octocat@github.com","mona@github.com","octocat@octocat.org"]}

@endpoint DELETE /user/emails
@desc Delete an email address for the authenticated user
@returns(204) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"emails":["octocat@github.com","mona@github.com"]}

@endpoint GET /user/followers
@desc List followers of the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/following
@desc List the people the authenticated user follows
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/following/{username}
@desc Check if a person is followed by the authenticated user
@required {username: str # The handle for the GitHub user account.}
@returns(204) if the person is followed by the authenticated user
@errors {404: if the person is not followed by the authenticated user, 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint PUT /user/following/{username}
@desc Follow a user
@required {username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication, 422: Validation failed, or the endpoint has been spammed.}

@endpoint DELETE /user/following/{username}
@desc Unfollow a user
@required {username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/gpg_keys
@desc List GPG keys for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /user/gpg_keys
@desc Create a GPG key for the authenticated user
@required {armored_public_key: str # A GPG key in ASCII-armored format.}
@optional {name: str # A descriptive name for the new key.}
@returns(201) {id: int(int64), name: str?, primary_key_id: int?, key_id: str, public_key: str, emails: [map], subkeys: [map], can_sign: bool, can_encrypt_comms: bool, can_encrypt_storage: bool, can_certify: bool, created_at: str(date-time), expires_at: str(date-time)?, revoked: bool, raw_key: str?} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}
@example_request {"name":"Octocat's GPG Key","armored_public_key":"-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: GnuPG v1\n\nmQINBFnZ2ZIBEADQ2Z7Z7\n-----END PGP PUBLIC KEY BLOCK-----"}

@endpoint GET /user/gpg_keys/{gpg_key_id}
@desc Get a GPG key for the authenticated user
@required {gpg_key_id: int # The unique identifier of the GPG key.}
@returns(200) {id: int(int64), name: str?, primary_key_id: int?, key_id: str, public_key: str, emails: [map], subkeys: [map], can_sign: bool, can_encrypt_comms: bool, can_encrypt_storage: bool, can_certify: bool, created_at: str(date-time), expires_at: str(date-time)?, revoked: bool, raw_key: str?} # Response
@errors {404: Resource not found, 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint DELETE /user/gpg_keys/{gpg_key_id}
@desc Delete a GPG key for the authenticated user
@required {gpg_key_id: int # The unique identifier of the GPG key.}
@returns(204) Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/installations
@desc List app installations accessible to the user access token
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, installations: [map]} # You can find the permissions for the installation under the `permissions` key.
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/installations/{installation_id}/repositories
@desc List repositories accessible to the user access token
@required {installation_id: int # The unique identifier of the installation.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) {total_count: int, repository_selection: str, repositories: [any]} # The access the user has to each repository is included in the hash under the `permissions` key.
@errors {404: Resource not found, 403: Forbidden, 304: Not modified}

@endpoint PUT /user/installations/{installation_id}/repositories/{repository_id}
@desc Add a repository to an app installation
@required {installation_id: int # The unique identifier of the installation., repository_id: int # The unique identifier of the repository.}
@returns(204) Response
@errors {403: Forbidden, 304: Not modified, 404: Resource not found}

@endpoint DELETE /user/installations/{installation_id}/repositories/{repository_id}
@desc Remove a repository from an app installation
@required {installation_id: int # The unique identifier of the installation., repository_id: int # The unique identifier of the repository.}
@returns(204) Response
@errors {403: Forbidden, 304: Not modified, 404: Resource not found, 422: Returned when the application is installed on `all` repositories in the organization, or if this request would remove the last repository that the application has access to in the organization.}

@endpoint GET /user/interaction-limits
@desc Get interaction restrictions for your public repositories
@returns(200) Default response
@returns(204) Response when there are no restrictions

@endpoint PUT /user/interaction-limits
@desc Set interaction restrictions for your public repositories
@required {limit: str(existing_users/contributors_only/collaborators_only) # The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.}
@optional {expiry: str(one_day/three_days/one_week/one_month/six_months) # The duration of the interaction restriction. Default: `one_day`.}
@returns(200) {limit: str, origin: str, expires_at: str(date-time)} # Response
@errors {422: Validation failed, or the endpoint has been spammed.}
@example_request {"limit":"collaborators_only","expiry":"one_month"}

@endpoint DELETE /user/interaction-limits
@desc Remove interaction restrictions from your public repositories
@returns(204) Response

@endpoint GET /user/issues
@desc List user account issues assigned to the authenticated user
@optional {filter: str(assigned/created/mentioned/subscribed/repos/all)=assigned # Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation., state: str(open/closed/all)=open # Indicates the state of the issues to return., labels: str # A list of comma separated label names. Example: `bug,ui,@high`, sort: str(created/updated/comments)=created # What to sort results by., direction: str(asc/desc)=desc # The direction to sort the results by., since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found, 304: Not modified}

@endpoint GET /user/keys
@desc List public SSH keys for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /user/keys
@desc Create a public SSH key for the authenticated user
@required {key: str # The public SSH key to add to your GitHub account.}
@optional {title: str # A descriptive name for the new key.}
@returns(201) {key: str, id: int(int64), url: str, title: str, created_at: str(date-time), verified: bool, read_only: bool, last_used: str(date-time)?} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}
@example_request {"title":"ssh-rsa AAAAB3NzaC1yc2EAAA","key":"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvv1234"}

@endpoint GET /user/keys/{key_id}
@desc Get a public SSH key for the authenticated user
@required {key_id: int # The unique identifier of the key.}
@returns(200) {key: str, id: int(int64), url: str, title: str, created_at: str(date-time), verified: bool, read_only: bool, last_used: str(date-time)?} # Response
@errors {404: Resource not found, 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint DELETE /user/keys/{key_id}
@desc Delete a public SSH key for the authenticated user
@required {key_id: int # The unique identifier of the key.}
@returns(204) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/marketplace_purchases
@desc List subscriptions for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 401: Requires authentication, 404: Resource not found}

@endpoint GET /user/marketplace_purchases/stubbed
@desc List subscriptions for the authenticated user (stubbed)
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 401: Requires authentication}

@endpoint GET /user/memberships/orgs
@desc List organization memberships for the authenticated user
@optional {state: str(active/pending) # Indicates the state of the memberships to return. If not specified, the API returns both active and pending memberships., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /user/memberships/orgs/{org}
@desc Get an organization membership for the authenticated user
@required {org: str # The organization name. The name is not case sensitive.}
@returns(200) {url: str(uri), state: str, role: str, direct_membership: bool, enterprise_teams_providing_indirect_membership: [str], organization_url: str(uri), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?}, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, permissions: map{can_create_repository: bool}} # Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint PATCH /user/memberships/orgs/{org}
@desc Update an organization membership for the authenticated user
@required {org: str # The organization name. The name is not case sensitive., state: str # The state that the membership should be in. Only `"active"` will be accepted.}
@returns(200) {url: str(uri), state: str, role: str, direct_membership: bool, enterprise_teams_providing_indirect_membership: [str], organization_url: str(uri), organization: map{login: str, id: int, node_id: str, url: str(uri), repos_url: str(uri), events_url: str(uri), hooks_url: str, issues_url: str, members_url: str, public_members_url: str, avatar_url: str, description: str?}, user: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, permissions: map{can_create_repository: bool}} # Response
@errors {403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"state":"active"}

@endpoint GET /user/migrations
@desc List user migrations
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint POST /user/migrations
@desc Start a user migration
@required {repositories: [str]}
@optional {lock_repositories: bool # Lock the repositories being migrated at the start of the migration, exclude_metadata: bool # Indicates whether metadata should be excluded and only git source should be included for the migration., exclude_git_data: bool # Indicates whether the repository git data should be excluded from the migration., exclude_attachments: bool # Do not include attachments in the migration, exclude_releases: bool # Do not include releases in the migration, exclude_owner_projects: bool # Indicates whether projects owned by the organization or users should be excluded., org_metadata_only: bool=False # Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags)., exclude: [str] # Exclude attributes from the API response to improve performance}
@returns(201) {id: int(int64), owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, guid: str, state: str, lock_repositories: bool, exclude_metadata: bool, exclude_git_data: bool, exclude_attachments: bool, exclude_releases: bool, exclude_owner_projects: bool, org_metadata_only: bool, repositories: [map], url: str(uri), created_at: str(date-time), updated_at: str(date-time), node_id: str, archive_url: str(uri), exclude: [str]} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 403: Forbidden, 401: Requires authentication}
@example_request {"repositories":["octocat/Hello-World"],"lock_repositories":true}

@endpoint GET /user/migrations/{migration_id}
@desc Get a user migration status
@required {migration_id: int # The unique identifier of the migration.}
@optional {exclude: [str]}
@returns(200) {id: int(int64), owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, guid: str, state: str, lock_repositories: bool, exclude_metadata: bool, exclude_git_data: bool, exclude_attachments: bool, exclude_releases: bool, exclude_owner_projects: bool, org_metadata_only: bool, repositories: [map], url: str(uri), created_at: str(date-time), updated_at: str(date-time), node_id: str, archive_url: str(uri), exclude: [str]} # Response
@errors {404: Resource not found, 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/migrations/{migration_id}/archive
@desc Download a user migration archive
@required {migration_id: int # The unique identifier of the migration.}
@errors {302: Response, 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint DELETE /user/migrations/{migration_id}/archive
@desc Delete a user migration archive
@required {migration_id: int # The unique identifier of the migration.}
@returns(204) Response
@errors {404: Resource not found, 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock
@desc Unlock a user repository
@required {migration_id: int # The unique identifier of the migration., repo_name: str # repo_name parameter}
@returns(204) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/migrations/{migration_id}/repositories
@desc List repositories for a user migration
@required {migration_id: int # The unique identifier of the migration.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {404: Resource not found}

@endpoint GET /user/orgs
@desc List organizations for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/packages
@desc List packages for the authenticated user's namespace
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.}
@optional {visibility: str(public/private/internal) # The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`. For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {400: The value of `per_page` multiplied by `page` cannot be greater than 10000.}

@endpoint GET /user/packages/{package_type}/{package_name}
@desc Get a package for the authenticated user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package.}
@returns(200) {id: int, name: str, package_type: str, url: str, html_url: str, version_count: int, visibility: str, owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map?{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint DELETE /user/packages/{package_type}/{package_name}
@desc Delete a package for the authenticated user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package.}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /user/packages/{package_type}/{package_name}/restore
@desc Restore a package for the authenticated user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package.}
@optional {token: str # package token}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/packages/{package_type}/{package_name}/versions
@desc List package versions for a package owned by the authenticated user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package.}
@optional {page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", state: str(active/deleted)=active # The state of the package, either active or deleted.}
@returns(200) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}
@desc Get a package version for the authenticated user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., package_version_id: int # Unique identifier of the package version.}
@returns(200) {id: int, name: str, url: str, package_html_url: str, html_url: str, license: str, description: str, created_at: str(date-time), updated_at: str(date-time), deleted_at: str(date-time), metadata: map{package_type: str, container: map{tags: [str]}, docker: map{tag: [str]}}} # Response

@endpoint DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}
@desc Delete a package version for the authenticated user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., package_version_id: int # Unique identifier of the package version.}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
@desc Restore a package version for the authenticated user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., package_version_id: int # Unique identifier of the package version.}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/public_emails
@desc List public email addresses for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/repos
@desc List repositories for the authenticated user
@optional {visibility: str(all/public/private)=all # Limit results to repositories with the specified visibility., affiliation: str=owner,collaborator,organization_member # Comma-separated list of values. Can include:    * `owner`: Repositories that are owned by the authenticated user.    * `collaborator`: Repositories that the user has been added to as a collaborator.    * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on., type: str(all/owner/public/private/member)=all # Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**., sort: str(created/updated/pushed/full_name)=full_name # The property to sort the results by., direction: str(asc/desc) # The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", since: str(date-time) # Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., before: str(date-time) # Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint POST /user/repos
@desc Create a repository for the authenticated user
@required {name: str # The name of the repository.}
@optional {description: str # A short description of the repository., homepage: str # A URL with more information about the repository., private: bool=False # Whether the repository is private., has_issues: bool=True # Whether issues are enabled., has_projects: bool=True # Whether projects are enabled., has_wiki: bool=True # Whether the wiki is enabled., has_discussions: bool=False # Whether discussions are enabled., team_id: int # The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization., auto_init: bool=False # Whether the repository is initialized with a minimal README., gitignore_template: str # The desired language or platform to apply to the .gitignore., license_template: str # The license keyword of the open source license for this repository., allow_squash_merge: bool=True # Whether to allow squash merges for pull requests., allow_merge_commit: bool=True # Whether to allow merge commits for pull requests., allow_rebase_merge: bool=True # Whether to allow rebase merges for pull requests., allow_auto_merge: bool=False # Whether to allow Auto-merge to be used on pull requests., delete_branch_on_merge: bool=False # Whether to delete head branches when pull requests are merged, squash_merge_commit_title: str(PR_TITLE/COMMIT_OR_PR_TITLE) # Required when using `squash_merge_commit_message`.  The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)., squash_merge_commit_message: str(PR_BODY/COMMIT_MESSAGES/BLANK) # The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message., merge_commit_title: str(PR_TITLE/MERGE_MESSAGE) # Required when using `merge_commit_message`.  The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)., merge_commit_message: str(PR_BODY/PR_TITLE/BLANK) # The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message., has_downloads: bool=True # Whether downloads are enabled., is_template: bool=False # Whether this repository acts as a template that can be used to generate new repositories.}
@returns(201) {id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time), created_at: str(date-time), updated_at: str(date-time), permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, allow_rebase_merge: bool, template_repository: map?{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, temp_clone_token: str?, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_merge_commit: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_forking: bool, web_commit_signoff_required: bool, subscribers_count: int, network_count: int, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, organization: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, parent: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, source: map{id: int(int64), node_id: str, name: str, full_name: str, license: map?{key: str, name: str, url: str(uri)?, spdx_id: str?, node_id: str, html_url: str(uri)}, forks: int, permissions: map{admin: bool, pull: bool, triage: bool, push: bool, maintain: bool}, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str(uri)?, hooks_url: str(uri), svn_url: str(uri), homepage: str(uri)?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, allow_rebase_merge: bool, temp_clone_token: str, allow_squash_merge: bool, allow_auto_merge: bool, delete_branch_on_merge: bool, allow_update_branch: bool, use_squash_pr_title_as_default: bool, squash_merge_commit_title: str, squash_merge_commit_message: str, merge_commit_title: str, merge_commit_message: str, allow_merge_commit: bool, allow_forking: bool, web_commit_signoff_required: bool, open_issues: int, watchers: int, master_branch: str, starred_at: str, anonymous_access_enabled: bool, code_search_index_status: map{lexical_search_ok: bool, lexical_commit_sha: str}}, forks: int, master_branch: str, open_issues: int, watchers: int, anonymous_access_enabled: bool, code_of_conduct: map{url: str(uri), key: str, name: str, html_url: str(uri)?}, security_and_analysis: map?{advanced_security: map{status: str}, code_security: map{status: str}, dependabot_security_updates: map{status: str}, secret_scanning: map{status: str}, secret_scanning_push_protection: map{status: str}, secret_scanning_non_provider_patterns: map{status: str}, secret_scanning_ai_detection: map{status: str}, secret_scanning_delegated_alert_dismissal: map{status: str}}, custom_properties: map} # Response
@errors {401: Requires authentication, 304: Not modified, 404: Resource not found, 403: Forbidden, 422: Validation failed, or the endpoint has been spammed., 400: Bad Request}
@example_request {"name":"Hello-World","description":"This is your first repo!","homepage":"https://github.com","private":false,"is_template":true}

@endpoint GET /user/repository_invitations
@desc List repository invitations for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint PATCH /user/repository_invitations/{invitation_id}
@desc Accept a repository invitation
@required {invitation_id: int # The unique identifier of the invitation.}
@returns(204) Response
@errors {403: Forbidden, 409: Conflict, 404: Resource not found, 304: Not modified}

@endpoint DELETE /user/repository_invitations/{invitation_id}
@desc Decline a repository invitation
@required {invitation_id: int # The unique identifier of the invitation.}
@returns(204) Response
@errors {409: Conflict, 304: Not modified, 404: Resource not found, 403: Forbidden}

@endpoint GET /user/social_accounts
@desc List social accounts for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /user/social_accounts
@desc Add social accounts for the authenticated user
@required {account_urls: [str] # Full URLs for the social media profiles to add.}
@returns(201) Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}
@example_request {"account_urls":["https://facebook.com/GitHub","https://www.youtube.com/@GitHub"]}

@endpoint DELETE /user/social_accounts
@desc Delete social accounts for the authenticated user
@required {account_urls: [str] # Full URLs for the social media profiles to delete.}
@returns(204) Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}
@example_request {"account_urls":["https://facebook.com/GitHub","https://www.youtube.com/@GitHub"]}

@endpoint GET /user/ssh_signing_keys
@desc List SSH signing keys for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /user/ssh_signing_keys
@desc Create a SSH signing key for the authenticated user
@required {key: str # The public SSH key to add to your GitHub account. For more information, see "[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)."}
@optional {title: str # A descriptive name for the new key.}
@returns(201) {key: str, id: int, title: str, created_at: str(date-time)} # Response
@errors {422: Validation failed, or the endpoint has been spammed., 304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}
@example_request {"key":"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvv1234","title":"ssh-rsa AAAAB3NzaC1yc2EAAA"}

@endpoint GET /user/ssh_signing_keys/{ssh_signing_key_id}
@desc Get an SSH signing key for the authenticated user
@required {ssh_signing_key_id: int # The unique identifier of the SSH signing key.}
@returns(200) {key: str, id: int, title: str, created_at: str(date-time)} # Response
@errors {404: Resource not found, 304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint DELETE /user/ssh_signing_keys/{ssh_signing_key_id}
@desc Delete an SSH signing key for the authenticated user
@required {ssh_signing_key_id: int # The unique identifier of the SSH signing key.}
@returns(204) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/starred
@desc List repositories starred by the authenticated user
@optional {sort: str(created/updated)=created # The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to., direction: str(asc/desc)=desc # The direction to sort the results by., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/starred/{owner}/{repo}
@desc Check if a repository is starred by the authenticated user
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response if this repository is starred by you
@errors {404: Not Found if this repository is not starred by you, 401: Requires authentication, 304: Not modified, 403: Forbidden}

@endpoint PUT /user/starred/{owner}/{repo}
@desc Star a repository for the authenticated user
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response
@errors {403: Forbidden, 404: Resource not found, 401: Requires authentication, 304: Not modified}

@endpoint DELETE /user/starred/{owner}/{repo}
@desc Unstar a repository for the authenticated user
@required {owner: str # The account owner of the repository. The name is not case sensitive., repo: str # The name of the repository without the `.git` extension. The name is not case sensitive.}
@returns(204) Response
@errors {404: Resource not found, 401: Requires authentication, 304: Not modified, 403: Forbidden}

@endpoint GET /user/subscriptions
@desc List repositories watched by the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /user/teams
@desc List teams for the authenticated user
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 404: Resource not found, 403: Forbidden}

@endpoint GET /user/{account_id}
@desc Get a user using their ID
@required {account_id: int # account_id parameter}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /user/{user_id}/projectsV2/{project_number}/drafts
@desc Create draft item for user owned project
@required {user_id: str # The unique identifier of the user., project_number: int # The project's number., title: str # The title of the draft issue item to create in the project.}
@optional {body: str # The body content of the draft issue item to create in the project.}
@returns(201) {id: num, node_id: str, content: any, content_type: str, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, project_url: str(uri), item_url: str(uri)} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}
@example_request {"title":"Sample Draft Issue Title"}

@endgroup

@group users
@endpoint GET /users
@desc List users
@optional {since: int # A user ID. Only return users with an ID greater than this ID., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified}

@endpoint POST /users/{user_id}/projectsV2/{project_number}/views
@desc Create a view for a user-owned project
@required {user_id: str # The unique identifier of the user., project_number: int # The project's number., name: str # The name of the view., layout: str(table/board/roadmap) # The layout of the view.}
@optional {filter: str # The filter query for the view. See [Filtering projects](https://docs.github.com/issues/planning-and-tracking-with-projects/customizing-views-in-your-project/filtering-projects) for more information., visible_fields: [int] # `visible_fields` is not applicable to `roadmap` layout views. For `table` and `board` layouts, this represents the field IDs that should be visible in the view. If not provided, the default visible fields will be used.}
@returns(201) {id: int, number: int, name: str, layout: str, node_id: str, project_url: str, html_url: str(uri), creator: any, created_at: str(date-time), updated_at: str(date-time), filter: str?, visible_fields: [int], sort_by: [[any]], group_by: [int], vertical_group_by: [int]} # Response for creating a view in a user-owned project.
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed., 503: Service unavailable}
@example_request {"name":"All Issues","layout":"table","filter":"is:issue","visible_fields":[123,456,789]}

@endpoint GET /users/{username}
@desc Get a user
@required {username: str # The handle for the GitHub user account.}
@returns(200) Response
@errors {404: Resource not found}

@endpoint POST /users/{username}/attestations/bulk-list
@desc List attestations by bulk subject digests
@required {username: str # The handle for the GitHub user account., subject_digests: [str] # List of subject digests to fetch attestations for.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", predicate_type: str # Optional filter for fetching attestations with a given predicate type. This option accepts `provenance`, `sbom`, `release`, or freeform text for custom predicate types.}
@returns(200) {attestations_subject_digests: map, page_info: map{has_next: bool, has_previous: bool, next: str, previous: str}} # Response
@example_request {"subject_digests":["sha256:abc123","sha512:def456"]}

@endpoint POST /users/{username}/attestations/delete-request
@desc Delete attestations in bulk
@required {username: str # The handle for the GitHub user account.}
@returns(200) Response
@errors {404: Resource not found}
@example_request {"subject_digests":["sha256:abc123","sha512:def456"]}

@endpoint DELETE /users/{username}/attestations/digest/{subject_digest}
@desc Delete attestations by subject digest
@required {username: str # The handle for the GitHub user account., subject_digest: str # Subject Digest}
@returns(200) Response
@returns(204) Response
@errors {404: Resource not found}

@endpoint DELETE /users/{username}/attestations/{attestation_id}
@desc Delete attestations by ID
@required {username: str # The handle for the GitHub user account., attestation_id: int # Attestation ID}
@returns(200) Response
@returns(204) Response
@errors {403: Forbidden, 404: Resource not found}

@endpoint GET /users/{username}/attestations/{subject_digest}
@desc List attestations
@required {username: str # The handle for the GitHub user account., subject_digest: str # Subject Digest}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", predicate_type: str # Optional filter for fetching attestations with a given predicate type. This option accepts `provenance`, `sbom`, `release`, or freeform text for custom predicate types.}
@returns(200) {attestations: [map]} # Response
@returns(201) Response
@returns(204) Response
@errors {404: Resource not found}

@endpoint GET /users/{username}/docker/conflicts
@desc Get list of conflicting packages during Docker migration for user
@required {username: str # The handle for the GitHub user account.}
@returns(200) Response
@errors {403: Forbidden, 401: Requires authentication}

@endpoint GET /users/{username}/events
@desc List events for the authenticated user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/events/orgs/{org}
@desc List organization events for the authenticated user
@required {username: str # The handle for the GitHub user account., org: str # The organization name. The name is not case sensitive.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/events/public
@desc List public events for a user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/followers
@desc List followers of a user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/following
@desc List the people a user follows
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/following/{target_user}
@desc Check if a user follows another user
@required {username: str # The handle for the GitHub user account., target_user: str}
@returns(204) if the user follows the target user
@errors {404: if the user does not follow the target user}

@endpoint GET /users/{username}/gists
@desc List gists for a user
@required {username: str # The handle for the GitHub user account.}
@optional {since: str(date-time) # Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /users/{username}/gpg_keys
@desc List GPG keys for a user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/hovercard
@desc Get contextual information for a user
@required {username: str # The handle for the GitHub user account.}
@optional {subject_type: str(organization/repository/issue/pull_request) # Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`., subject_id: str # Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.}
@returns(200) {contexts: [map]} # Response
@errors {404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}

@endpoint GET /users/{username}/installation
@desc Get a user installation for the authenticated app
@required {username: str # The handle for the GitHub user account.}
@returns(200) {id: int, account: any?, repository_selection: str, access_tokens_url: str(uri), repositories_url: str(uri), html_url: str(uri), app_id: int, client_id: str, target_id: int, target_type: str, permissions: map{actions: str, administration: str, artifact_metadata: str, attestations: str, checks: str, codespaces: str, contents: str, dependabot_secrets: str, deployments: str, discussions: str, environments: str, issues: str, merge_queues: str, metadata: str, packages: str, pages: str, pull_requests: str, repository_custom_properties: str, repository_hooks: str, repository_projects: str, secret_scanning_alerts: str, secrets: str, security_events: str, single_file: str, statuses: str, vulnerability_alerts: str, workflows: str, custom_properties_for_organizations: str, members: str, organization_administration: str, organization_custom_roles: str, organization_custom_org_roles: str, organization_custom_properties: str, organization_copilot_seat_management: str, organization_announcement_banners: str, organization_events: str, organization_hooks: str, organization_personal_access_tokens: str, organization_personal_access_token_requests: str, organization_plan: str, organization_projects: str, organization_packages: str, organization_secrets: str, organization_self_hosted_runners: str, organization_user_blocking: str, email_addresses: str, followers: str, git_ssh_keys: str, gpg_keys: str, interaction_limits: str, profile: str, starring: str, enterprise_custom_properties_for_organizations: str}, events: [str], created_at: str(date-time), updated_at: str(date-time), single_file_name: str?, has_multiple_single_files: bool, single_file_paths: [str], app_slug: str, suspended_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, suspended_at: str(date-time)?, contact_email: str?} # Response

@endpoint GET /users/{username}/keys
@desc List public keys for a user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/orgs
@desc List organizations for a user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/packages
@desc List packages for a user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., username: str # The handle for the GitHub user account.}
@optional {visibility: str(public/private/internal) # The selected visibility of the packages.  This parameter is optional and only filters an existing result set.  The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`. For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {403: Forbidden, 401: Requires authentication, 400: The value of `per_page` multiplied by `page` cannot be greater than 10000.}

@endpoint GET /users/{username}/packages/{package_type}/{package_name}
@desc Get a package for a user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., username: str # The handle for the GitHub user account.}
@returns(200) {id: int, name: str, package_type: str, url: str, html_url: str, version_count: int, visibility: str, owner: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, repository: map?{id: int(int64), node_id: str, name: str, full_name: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, private: bool, html_url: str(uri), description: str?, fork: bool, url: str(uri), archive_url: str, assignees_url: str, blobs_url: str, branches_url: str, collaborators_url: str, comments_url: str, commits_url: str, compare_url: str, contents_url: str, contributors_url: str(uri), deployments_url: str(uri), downloads_url: str(uri), events_url: str(uri), forks_url: str(uri), git_commits_url: str, git_refs_url: str, git_tags_url: str, git_url: str, issue_comment_url: str, issue_events_url: str, issues_url: str, keys_url: str, labels_url: str, languages_url: str(uri), merges_url: str(uri), milestones_url: str, notifications_url: str, pulls_url: str, releases_url: str, ssh_url: str, stargazers_url: str(uri), statuses_url: str, subscribers_url: str(uri), subscription_url: str(uri), tags_url: str(uri), teams_url: str(uri), trees_url: str, clone_url: str, mirror_url: str?, hooks_url: str(uri), svn_url: str, homepage: str?, language: str?, forks_count: int, stargazers_count: int, watchers_count: int, size: int, default_branch: str, open_issues_count: int, is_template: bool, topics: [str], has_issues: bool, has_projects: bool, has_wiki: bool, has_pages: bool, has_downloads: bool, has_discussions: bool, has_pull_requests: bool, archived: bool, disabled: bool, visibility: str, pushed_at: str(date-time)?, created_at: str(date-time)?, updated_at: str(date-time)?, permissions: map{admin: bool, maintain: bool, push: bool, triage: bool, pull: bool}, role_name: str, temp_clone_token: str, delete_branch_on_merge: bool, subscribers_count: int, network_count: int, code_of_conduct: map{key: str, name: str, url: str(uri), body: str, html_url: str(uri)?}, license: map?{key: str, name: str, spdx_id: str, url: str?, node_id: str}, forks: int, open_issues: int, watchers: int, allow_forking: bool, web_commit_signoff_required: bool, security_and_analysis: map?{advanced_security: map, code_security: map, dependabot_security_updates: map, secret_scanning: map, secret_scanning_push_protection: map, secret_scanning_non_provider_patterns: map, secret_scanning_ai_detection: map, secret_scanning_delegated_alert_dismissal: map}, custom_properties: map}, created_at: str(date-time), updated_at: str(date-time)} # Response

@endpoint DELETE /users/{username}/packages/{package_type}/{package_name}
@desc Delete a package for a user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., username: str # The handle for the GitHub user account.}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /users/{username}/packages/{package_type}/{package_name}/restore
@desc Restore a package for a user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., username: str # The handle for the GitHub user account.}
@optional {token: str # package token}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /users/{username}/packages/{package_type}/{package_name}/versions
@desc List package versions for a package owned by a user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., username: str # The handle for the GitHub user account.}
@returns(200) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
@desc Get a package version for a user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., package_version_id: int # Unique identifier of the package version., username: str # The handle for the GitHub user account.}
@returns(200) {id: int, name: str, url: str, package_html_url: str, html_url: str, license: str, description: str, created_at: str(date-time), updated_at: str(date-time), deleted_at: str(date-time), metadata: map{package_type: str, container: map{tags: [str]}, docker: map{tag: [str]}}} # Response

@endpoint DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
@desc Delete package version for a user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., username: str # The handle for the GitHub user account., package_version_id: int # Unique identifier of the package version.}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
@desc Restore package version for a user
@required {package_type: str(npm/maven/rubygems/docker/nuget/container) # The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry., package_name: str # The name of the package., username: str # The handle for the GitHub user account., package_version_id: int # Unique identifier of the package version.}
@returns(204) Response
@errors {404: Resource not found, 403: Forbidden, 401: Requires authentication}

@endpoint GET /users/{username}/projectsV2
@desc List projects for user
@required {username: str # The handle for the GitHub user account.}
@optional {q: str # Limit results to projects of the specified type., before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /users/{username}/projectsV2/{project_number}
@desc Get project for user
@required {project_number: int # The project's number., username: str # The handle for the GitHub user account.}
@returns(200) {id: num, node_id: str, owner: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, title: str, description: str?, public: bool, closed_at: str(date-time)?, created_at: str(date-time), updated_at: str(date-time), number: int, short_description: str?, deleted_at: str(date-time)?, deleted_by: map?{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, state: str, latest_status_update: map?{id: num, node_id: str, project_node_id: str, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), status: str?, start_date: str(date), target_date: str(date), body: str?}, is_template: bool} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /users/{username}/projectsV2/{project_number}/fields
@desc List project fields for user
@required {project_number: int # The project's number., username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint POST /users/{username}/projectsV2/{project_number}/fields
@desc Add field to user owned project
@required {username: str # The handle for the GitHub user account., project_number: int # The project's number.}
@returns(201) {id: int, node_id: str, project_url: str, name: str, data_type: str, options: [map], configuration: map{start_day: int, duration: int, iterations: [map]}, created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"name":"Team notes","data_type":"text"}

@endpoint GET /users/{username}/projectsV2/{project_number}/fields/{field_id}
@desc Get project field for user
@required {project_number: int # The project's number., field_id: int # The unique identifier of the field., username: str # The handle for the GitHub user account.}
@returns(200) {id: int, node_id: str, project_url: str, name: str, data_type: str, options: [map], configuration: map{start_day: int, duration: int, iterations: [map]}, created_at: str(date-time), updated_at: str(date-time)} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint GET /users/{username}/projectsV2/{project_number}/items
@desc List items for a user owned project
@required {project_number: int # The project's number., username: str # The handle for the GitHub user account.}
@optional {before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", q: str # Search query to filter items, see [Filtering projects](https://docs.github.com/issues/planning-and-tracking-with-projects/customizing-views-in-your-project/filtering-projects) for more information., fields: any # Limit results to specific fields, by their IDs. If not specified, the title field will be returned.  Example: `fields[]=123&fields[]=456&fields[]=789` or `fields=123,456,789`}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint POST /users/{username}/projectsV2/{project_number}/items
@desc Add item to user owned project
@required {username: str # The handle for the GitHub user account., project_number: int # The project's number., type: str(Issue/PullRequest) # The type of item to add to the project. Must be either Issue or PullRequest.}
@optional {id: int # The unique identifier of the issue or pull request to add to the project., owner: str # The repository owner login., repo: str # The repository name., number: int # The issue or pull request number.}
@returns(201) {id: num, node_id: str, content: any, content_type: str, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, project_url: str(uri), item_url: str(uri)} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}
@example_request {"type":"Issue","id":3}

@endpoint GET /users/{username}/projectsV2/{project_number}/items/{item_id}
@desc Get an item for a user owned project
@required {project_number: int # The project's number., username: str # The handle for the GitHub user account., item_id: int # The unique identifier of the project item.}
@optional {fields: any # Limit results to specific fields, by their IDs. If not specified, the title field will be returned.  Example: fields[]=123&fields[]=456&fields[]=789 or fields=123,456,789}
@returns(200) {id: num, node_id: str, project_url: str(uri), content_type: str, content: map?, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, item_url: str(uri)?, fields: [map]} # Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication}

@endpoint PATCH /users/{username}/projectsV2/{project_number}/items/{item_id}
@desc Update project item for user
@required {project_number: int # The project's number., username: str # The handle for the GitHub user account., item_id: int # The unique identifier of the project item., fields: [map{id!: int, value!: any}] # A list of field updates to apply.}
@returns(200) {id: num, node_id: str, project_url: str(uri), content_type: str, content: map?, creator: map{name: str?, email: str?, login: str, id: int(int64), node_id: str, avatar_url: str(uri), gravatar_id: str?, url: str(uri), html_url: str(uri), followers_url: str(uri), following_url: str, gists_url: str, starred_url: str, subscriptions_url: str(uri), organizations_url: str(uri), repos_url: str(uri), events_url: str, received_events_url: str(uri), type: str, site_admin: bool, starred_at: str, user_view_type: str}, created_at: str(date-time), updated_at: str(date-time), archived_at: str(date-time)?, item_url: str(uri)?, fields: [map]} # Response
@errors {401: Requires authentication, 403: Forbidden, 404: Resource not found, 422: Validation failed, or the endpoint has been spammed.}
@example_request {"fields":[{"id":123,"value":"Updated text value"}]}

@endpoint DELETE /users/{username}/projectsV2/{project_number}/items/{item_id}
@desc Delete project item for user
@required {project_number: int # The project's number., username: str # The handle for the GitHub user account., item_id: int # The unique identifier of the project item.}
@returns(204) Response
@errors {403: Forbidden, 401: Requires authentication}

@endpoint GET /users/{username}/projectsV2/{project_number}/views/{view_number}/items
@desc List items for a user project view
@required {project_number: int # The project's number., username: str # The handle for the GitHub user account., view_number: int # The number that identifies the project view.}
@optional {fields: any # Limit results to specific fields, by their IDs. If not specified, the title field will be returned.  Example: `fields[]=123&fields[]=456&fields[]=789` or `fields=123,456,789`, before: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", after: str # A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response
@errors {304: Not modified, 403: Forbidden, 401: Requires authentication, 404: Resource not found}

@endpoint GET /users/{username}/received_events
@desc List events received by the authenticated user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/received_events/public
@desc List public events received by a user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/repos
@desc List repositories for a user
@required {username: str # The handle for the GitHub user account.}
@optional {type: str(all/owner/member)=owner # Limit results to repositories of the specified type., sort: str(created/updated/pushed/full_name)=full_name # The property to sort the results by., direction: str(asc/desc) # The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/settings/billing/premium_request/usage
@desc Get billing premium request usage report for a user
@required {username: str # The handle for the GitHub user account.}
@optional {year: int # If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year., month: int # If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. Default value is the current month. If no year is specified the default `year` is used., day: int # If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used., model: str # The model name to query usage for. The name is not case sensitive., product: str # The product name to query usage for. The name is not case sensitive.}
@returns(200) {timePeriod: map{year: int, month: int, day: int}, user: str, product: str, model: str, usageItems: [map]} # Response when getting a billing premium request usage report
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found, 500: Internal Error, 503: Service unavailable}

@endpoint GET /users/{username}/settings/billing/usage
@desc Get billing usage report for a user
@required {username: str # The handle for the GitHub user account.}
@optional {year: int # If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year., month: int # If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used., day: int # If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.}
@returns(200) {usageItems: [map]} # Response when getting a billing usage report
@errors {400: Bad Request, 403: Forbidden, 500: Internal Error, 503: Service unavailable}

@endpoint GET /users/{username}/settings/billing/usage/summary
@desc Get billing usage summary for a user
@required {username: str # The handle for the GitHub user account.}
@optional {year: int # If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year., month: int # If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. Default value is the current month. If no year is specified the default `year` is used., day: int # If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used., repository: str # The repository name to query for usage in the format owner/repository., product: str # The product name to query usage for. The name is not case sensitive., sku: str # The SKU to query for usage.}
@returns(200) {timePeriod: map{year: int, month: int, day: int}, user: str, repository: str, product: str, sku: str, usageItems: [map]} # Response when getting a billing usage summary
@errors {400: Bad Request, 403: Forbidden, 404: Resource not found, 500: Internal Error, 503: Service unavailable}

@endpoint GET /users/{username}/social_accounts
@desc List social accounts for a user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/ssh_signing_keys
@desc List SSH signing keys for a user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/starred
@desc List repositories starred by a user
@required {username: str # The handle for the GitHub user account.}
@optional {sort: str(created/updated)=created # The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to., direction: str(asc/desc)=desc # The direction to sort the results by., per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endpoint GET /users/{username}/subscriptions
@desc List repositories watched by a user
@required {username: str # The handle for the GitHub user account.}
@optional {per_page: int=30 # The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).", page: int=1 # The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."}
@returns(200) Response

@endgroup

@group versions
@endpoint GET /versions
@desc Get all API versions
@returns(200) Response
@errors {404: Resource not found}

@endgroup

@group zen
@endpoint GET /zen
@desc Get the Zen of GitHub
@returns(200) Response

@endgroup

@end
